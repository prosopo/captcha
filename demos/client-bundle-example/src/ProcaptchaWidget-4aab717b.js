var Rv = Object.defineProperty;
var Iv = (n, e, t) => e in n ? Rv(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t;
var b = (n, e, t) => (Iv(n, typeof e != "symbol" ? e + "" : e, t), t);
import { g as tu, a as nu, c as Ie, z as G, r as we, e as Ov, l as Ls, d as Ds, j as ge, b as dn, f as H, A as li, C as Mv, N as Lv, h as ka, P as Dv, i as Nm, R as Uv, L as Vv } from "./index-eb743309.js";
function Bv(n, e) {
  for (var t = 0; t < e.length; t++) {
    const r = e[t];
    if (typeof r != "string" && !Array.isArray(r)) {
      for (const i in r)
        if (i !== "default" && !(i in n)) {
          const s = Object.getOwnPropertyDescriptor(r, i);
          s && Object.defineProperty(n, i, s.get ? s : {
            enumerable: !0,
            get: () => r[i]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, { value: "Module" }));
}
function Hv(n) {
  return n("return this");
}
const Vd = typeof globalThis < "u" ? globalThis : typeof global < "u" ? global : typeof self < "u" ? self : typeof window < "u" ? window : Hv(Function);
function Fv(n, e) {
  return typeof Vd[n] > "u" ? e : Vd[n];
}
let jv = class {
  constructor(e) {
    b(this, "__encoding");
    this.__encoding = e;
  }
  decode(e) {
    let t = "";
    for (let r = 0, i = e.length; r < i; r++)
      t += String.fromCharCode(e[r]);
    return t;
  }
};
const Wv = { name: "@polkadot/x-textdecoder", path: import.meta && import.meta.url ? new URL(import.meta.url).pathname.substring(0, new URL(import.meta.url).pathname.lastIndexOf("/") + 1) : "auto", type: "esm", version: "12.6.1" }, qv = /* @__PURE__ */ Fv("TextDecoder", jv);
function zv(n) {
  return n("return this");
}
const Bd = typeof globalThis < "u" ? globalThis : typeof global < "u" ? global : typeof self < "u" ? self : typeof window < "u" ? window : zv(Function);
function Xv(n, e) {
  return typeof Bd[n] > "u" ? e : Bd[n];
}
let Gv = class {
  encode(e) {
    const t = e.length, r = new Uint8Array(t);
    for (let i = 0; i < t; i++)
      r[i] = e.charCodeAt(i);
    return r;
  }
};
const Zv = { name: "@polkadot/x-textencoder", path: import.meta && import.meta.url ? new URL(import.meta.url).pathname.substring(0, new URL(import.meta.url).pathname.lastIndexOf("/") + 1) : "auto", type: "esm", version: "12.6.1" }, Jv = /* @__PURE__ */ Xv("TextEncoder", Gv), Kv = [Wv, Zv], Rm = { name: "@polkadot/util", path: import.meta && import.meta.url ? new URL(import.meta.url).pathname.substring(0, new URL(import.meta.url).pathname.lastIndexOf("/") + 1) : "auto", type: "esm", version: "12.6.1" };
function Yv(n) {
  return n("return this");
}
const On = typeof globalThis < "u" ? globalThis : typeof global < "u" ? global : typeof self < "u" ? self : typeof window < "u" ? window : Yv(Function);
function Qv(n, e) {
  return typeof On[n] > "u" ? e : On[n];
}
function ue(n) {
  return typeof n == "function";
}
const Im = "POLKADOTJS_DISABLE_ESM_CJS_WARNING";
function $v(n) {
  const e = On;
  return e.__polkadotjs || (e.__polkadotjs = {}), e.__polkadotjs[n] || (e.__polkadotjs[n] = []), e.__polkadotjs[n];
}
function e1(n, e) {
  if (n)
    return n;
  if (ue(e))
    try {
      return e() || "";
    } catch {
      return "";
    }
  return e || "";
}
function Om({ name: n, path: e, type: t, version: r }, i, s = []) {
  var f, m;
  if (!n.startsWith("@polkadot"))
    throw new Error(`Invalid package descriptor ${n}`);
  const a = $v(n);
  a.push({ path: e1(e, i), type: t, version: r });
  const o = a.every((y) => y.version === r), c = ((m = (f = On.process) == null ? void 0 : f.env) == null ? void 0 : m[Im]) === "1";
  a.length !== 1 && !(c && o) || s.filter((_) => _ && _.version !== r).length;
}
Om(Rm, null, Kv);
function Qc(n, e) {
  const t = Math.ceil(n.length / e);
  if (t === 1)
    return [n];
  const r = Array(t);
  for (let i = 0; i < t; i++) {
    const s = i * e;
    r[i] = n.slice(s, s + e);
  }
  return r;
}
function t1(n, e = !0) {
  return n.filter((t) => t !== void 0 && (e || t !== null));
}
function ma(n) {
  const e = n.length;
  if (e === 0)
    return [];
  if (e === 1)
    return n[0];
  let t = 0;
  for (let s = 0; s < e; s++)
    t += n[s].length;
  const r = new Array(t);
  let i = -1;
  for (let s = 0; s < e; s++) {
    const a = n[s];
    for (let o = 0, c = a.length; o < c; o++)
      r[++i] = a[o];
  }
  return r;
}
function n1(n, e = 0) {
  if (n <= 0)
    throw new Error("Expected non-zero, positive number as a range size");
  const t = new Array(n);
  for (let r = 0; r < n; r++)
    t[r] = r + e;
  return t;
}
function r1(n) {
  const e = n.slice();
  let t = e.length;
  if (t === 1)
    return e;
  for (; t !== 0; ) {
    const r = ~~(Math.random() * t);
    t--, [e[t], e[r]] = [e[r], e[t]];
  }
  return e;
}
function i1(n) {
  const e = n.length, t = new Array(e), r = new Array(e);
  for (let i = 0; i < e; i++)
    [t[i], r[i]] = n[i];
  return [t, r];
}
function s1(n, e) {
  const t = n.length, r = new Array(t);
  for (let i = 0; i < t; i++)
    r[i] = [n[i], e[i]];
  return r;
}
function Mm(n, e) {
  if (!n)
    throw new Error(ue(e) ? e() : e);
}
function zn(n, e) {
  return Mm(n != null, e), n;
}
function ru(n) {
  throw new Error(`This codepath should be unreachable. Unhandled input: ${n}`);
}
function ao(n) {
  return (...e) => {
    const t = e.length;
    if (t === 0)
      throw new Error("Must provide one or more arguments");
    let r = e[0];
    for (let i = 1; i < t; i++)
      n(e[i], r) && (r = e[i]);
    return r;
  };
}
const a1 = /* @__PURE__ */ ao((n, e) => n > e), o1 = /* @__PURE__ */ ao((n, e) => n < e);
function c1() {
  return Number.NaN;
}
const he = /* @__PURE__ */ Qv("BigInt", c1), ii = /* @__PURE__ */ he(0), Br = /* @__PURE__ */ he(1), l1 = /* @__PURE__ */ he(2), u1 = /* @__PURE__ */ he(3), d1 = /* @__PURE__ */ he(4), f1 = /* @__PURE__ */ he(5), h1 = /* @__PURE__ */ he(6), p1 = /* @__PURE__ */ he(7), m1 = /* @__PURE__ */ he(8), g1 = /* @__PURE__ */ he(9), y1 = /* @__PURE__ */ he(10), _1 = /* @__PURE__ */ he(100), v1 = /* @__PURE__ */ he(1e3), b1 = /* @__PURE__ */ he(1e6), $c = /* @__PURE__ */ he(1e9), w1 = $c * $c, Lm = /* @__PURE__ */ he(Number.MAX_SAFE_INTEGER), Dm = /* @__PURE__ */ he(94906265), Hd = he(256), Fd = he(256 * 256), x1 = he("0x10000000000000000");
function Ta(n, { isLe: e = !0, isNegative: t = !1 } = {}) {
  e || (n = n.slice().reverse());
  const r = n.length;
  if (t && r && n[r - 1] & 128) {
    switch (r) {
      case 0:
        return he(0);
      case 1:
        return he((n[0] ^ 255) * -1 - 1);
      case 2:
        return he((n[0] + (n[1] << 8) ^ 65535) * -1 - 1);
      case 4:
        return he((n[0] + (n[1] << 8) + (n[2] << 16) + n[3] * 16777216 ^ 4294967295) * -1 - 1);
    }
    const s = new DataView(n.buffer, n.byteOffset);
    if (r === 8)
      return s.getBigInt64(0, !0);
    let a = he(0);
    const o = r % 2;
    for (let c = r - 2; c >= o; c -= 2)
      a = a * Fd + he(s.getUint16(c, !0) ^ 65535);
    return o && (a = a * Hd + he(n[0] ^ 255)), a * -Br - Br;
  }
  switch (r) {
    case 0:
      return he(0);
    case 1:
      return he(n[0]);
    case 2:
      return he(n[0] + (n[1] << 8));
    case 4:
      return he(n[0] + (n[1] << 8) + (n[2] << 16) + n[3] * 16777216);
  }
  const i = new DataView(n.buffer, n.byteOffset);
  switch (r) {
    case 8:
      return i.getBigUint64(0, !0);
    case 16:
      return i.getBigUint64(8, !0) * x1 + i.getBigUint64(0, !0);
    default: {
      let s = he(0);
      const a = r % 2;
      for (let o = r - 2; o >= a; o -= 2)
        s = s * Fd + he(i.getUint16(o, !0));
      return a && (s = s * Hd + he(n[0])), s;
    }
  }
}
const nc = "0123456789abcdef", Na = new Uint8Array(256), Um = new Uint8Array(256 * 256);
for (let n = 0, e = nc.length; n < e; n++)
  Na[nc[n].charCodeAt(0) | 0] = n | 0, n > 9 && (Na[nc[n].toUpperCase().charCodeAt(0) | 0] = n | 0);
for (let n = 0; n < 256; n++) {
  const e = n << 8;
  for (let t = 0; t < 256; t++)
    Um[e | t] = Na[n] << 4 | Na[t];
}
function Mt(n, e = -1) {
  if (!n)
    return new Uint8Array();
  let t = n.startsWith("0x") ? 2 : 0;
  const r = Math.ceil((n.length - t) / 2), i = Math.ceil(e === -1 ? r : e / 8), s = new Uint8Array(i), a = i > r ? i - r : 0;
  for (let o = a; o < i; o++, t += 2)
    s[o] = Um[n.charCodeAt(t) << 8 | n.charCodeAt(t + 1)];
  return s;
}
function Vm(n, { isLe: e = !1, isNegative: t = !1 } = {}) {
  return !n || n === "0x" ? he(0) : Ta(Mt(n), { isLe: e, isNegative: t });
}
var iu = { exports: {} };
const S1 = {}, E1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: S1
}, Symbol.toStringTag, { value: "Module" })), C1 = /* @__PURE__ */ tu(E1);
iu.exports;
(function(n) {
  (function(e, t) {
    function r(P, d) {
      if (!P)
        throw new Error(d || "Assertion failed");
    }
    function i(P, d) {
      P.super_ = d;
      var h = function() {
      };
      h.prototype = d.prototype, P.prototype = new h(), P.prototype.constructor = P;
    }
    function s(P, d, h) {
      if (s.isBN(P))
        return P;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, P !== null && ((d === "le" || d === "be") && (h = d, d = 10), this._init(P || 0, d || 10, h || "be"));
    }
    typeof e == "object" ? e.exports = s : t.BN = s, s.BN = s, s.wordSize = 26;
    var a;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? a = window.Buffer : a = C1.Buffer;
    } catch {
    }
    s.isBN = function(d) {
      return d instanceof s ? !0 : d !== null && typeof d == "object" && d.constructor.wordSize === s.wordSize && Array.isArray(d.words);
    }, s.max = function(d, h) {
      return d.cmp(h) > 0 ? d : h;
    }, s.min = function(d, h) {
      return d.cmp(h) < 0 ? d : h;
    }, s.prototype._init = function(d, h, g) {
      if (typeof d == "number")
        return this._initNumber(d, h, g);
      if (typeof d == "object")
        return this._initArray(d, h, g);
      h === "hex" && (h = 16), r(h === (h | 0) && h >= 2 && h <= 36), d = d.toString().replace(/\s+/g, "");
      var E = 0;
      d[0] === "-" && (E++, this.negative = 1), E < d.length && (h === 16 ? this._parseHex(d, E, g) : (this._parseBase(d, h, E), g === "le" && this._initArray(this.toArray(), h, g)));
    }, s.prototype._initNumber = function(d, h, g) {
      d < 0 && (this.negative = 1, d = -d), d < 67108864 ? (this.words = [d & 67108863], this.length = 1) : d < 4503599627370496 ? (this.words = [
        d & 67108863,
        d / 67108864 & 67108863
      ], this.length = 2) : (r(d < 9007199254740992), this.words = [
        d & 67108863,
        d / 67108864 & 67108863,
        1
      ], this.length = 3), g === "le" && this._initArray(this.toArray(), h, g);
    }, s.prototype._initArray = function(d, h, g) {
      if (r(typeof d.length == "number"), d.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(d.length / 3), this.words = new Array(this.length);
      for (var E = 0; E < this.length; E++)
        this.words[E] = 0;
      var w, x, T = 0;
      if (g === "be")
        for (E = d.length - 1, w = 0; E >= 0; E -= 3)
          x = d[E] | d[E - 1] << 8 | d[E - 2] << 16, this.words[w] |= x << T & 67108863, this.words[w + 1] = x >>> 26 - T & 67108863, T += 24, T >= 26 && (T -= 26, w++);
      else if (g === "le")
        for (E = 0, w = 0; E < d.length; E += 3)
          x = d[E] | d[E + 1] << 8 | d[E + 2] << 16, this.words[w] |= x << T & 67108863, this.words[w + 1] = x >>> 26 - T & 67108863, T += 24, T >= 26 && (T -= 26, w++);
      return this._strip();
    };
    function o(P, d) {
      var h = P.charCodeAt(d);
      if (h >= 48 && h <= 57)
        return h - 48;
      if (h >= 65 && h <= 70)
        return h - 55;
      if (h >= 97 && h <= 102)
        return h - 87;
      r(!1, "Invalid character in " + P);
    }
    function c(P, d, h) {
      var g = o(P, h);
      return h - 1 >= d && (g |= o(P, h - 1) << 4), g;
    }
    s.prototype._parseHex = function(d, h, g) {
      this.length = Math.ceil((d.length - h) / 6), this.words = new Array(this.length);
      for (var E = 0; E < this.length; E++)
        this.words[E] = 0;
      var w = 0, x = 0, T;
      if (g === "be")
        for (E = d.length - 1; E >= h; E -= 2)
          T = c(d, h, E) << w, this.words[x] |= T & 67108863, w >= 18 ? (w -= 18, x += 1, this.words[x] |= T >>> 26) : w += 8;
      else {
        var S = d.length - h;
        for (E = S % 2 === 0 ? h + 1 : h; E < d.length; E += 2)
          T = c(d, h, E) << w, this.words[x] |= T & 67108863, w >= 18 ? (w -= 18, x += 1, this.words[x] |= T >>> 26) : w += 8;
      }
      this._strip();
    };
    function l(P, d, h, g) {
      for (var E = 0, w = 0, x = Math.min(P.length, h), T = d; T < x; T++) {
        var S = P.charCodeAt(T) - 48;
        E *= g, S >= 49 ? w = S - 49 + 10 : S >= 17 ? w = S - 17 + 10 : w = S, r(S >= 0 && w < g, "Invalid character"), E += w;
      }
      return E;
    }
    s.prototype._parseBase = function(d, h, g) {
      this.words = [0], this.length = 1;
      for (var E = 0, w = 1; w <= 67108863; w *= h)
        E++;
      E--, w = w / h | 0;
      for (var x = d.length - g, T = x % E, S = Math.min(x, x - T) + g, p = 0, k = g; k < S; k += E)
        p = l(d, k, k + E, h), this.imuln(w), this.words[0] + p < 67108864 ? this.words[0] += p : this._iaddn(p);
      if (T !== 0) {
        var q = 1;
        for (p = l(d, k, d.length, h), k = 0; k < T; k++)
          q *= h;
        this.imuln(q), this.words[0] + p < 67108864 ? this.words[0] += p : this._iaddn(p);
      }
      this._strip();
    }, s.prototype.copy = function(d) {
      d.words = new Array(this.length);
      for (var h = 0; h < this.length; h++)
        d.words[h] = this.words[h];
      d.length = this.length, d.negative = this.negative, d.red = this.red;
    };
    function u(P, d) {
      P.words = d.words, P.length = d.length, P.negative = d.negative, P.red = d.red;
    }
    if (s.prototype._move = function(d) {
      u(d, this);
    }, s.prototype.clone = function() {
      var d = new s(null);
      return this.copy(d), d;
    }, s.prototype._expand = function(d) {
      for (; this.length < d; )
        this.words[this.length++] = 0;
      return this;
    }, s.prototype._strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, s.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, typeof Symbol < "u" && typeof Symbol.for == "function")
      try {
        s.prototype[Symbol.for("nodejs.util.inspect.custom")] = f;
      } catch {
        s.prototype.inspect = f;
      }
    else
      s.prototype.inspect = f;
    function f() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var m = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], y = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], _ = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    s.prototype.toString = function(d, h) {
      d = d || 10, h = h | 0 || 1;
      var g;
      if (d === 16 || d === "hex") {
        g = "";
        for (var E = 0, w = 0, x = 0; x < this.length; x++) {
          var T = this.words[x], S = ((T << E | w) & 16777215).toString(16);
          w = T >>> 24 - E & 16777215, E += 2, E >= 26 && (E -= 26, x--), w !== 0 || x !== this.length - 1 ? g = m[6 - S.length] + S + g : g = S + g;
        }
        for (w !== 0 && (g = w.toString(16) + g); g.length % h !== 0; )
          g = "0" + g;
        return this.negative !== 0 && (g = "-" + g), g;
      }
      if (d === (d | 0) && d >= 2 && d <= 36) {
        var p = y[d], k = _[d];
        g = "";
        var q = this.clone();
        for (q.negative = 0; !q.isZero(); ) {
          var X = q.modrn(k).toString(d);
          q = q.idivn(k), q.isZero() ? g = X + g : g = m[p - X.length] + X + g;
        }
        for (this.isZero() && (g = "0" + g); g.length % h !== 0; )
          g = "0" + g;
        return this.negative !== 0 && (g = "-" + g), g;
      }
      r(!1, "Base should be between 2 and 36");
    }, s.prototype.toNumber = function() {
      var d = this.words[0];
      return this.length === 2 ? d += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? d += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -d : d;
    }, s.prototype.toJSON = function() {
      return this.toString(16, 2);
    }, a && (s.prototype.toBuffer = function(d, h) {
      return this.toArrayLike(a, d, h);
    }), s.prototype.toArray = function(d, h) {
      return this.toArrayLike(Array, d, h);
    };
    var v = function(d, h) {
      return d.allocUnsafe ? d.allocUnsafe(h) : new d(h);
    };
    s.prototype.toArrayLike = function(d, h, g) {
      this._strip();
      var E = this.byteLength(), w = g || Math.max(1, E);
      r(E <= w, "byte array longer than desired length"), r(w > 0, "Requested array length <= 0");
      var x = v(d, w), T = h === "le" ? "LE" : "BE";
      return this["_toArrayLike" + T](x, E), x;
    }, s.prototype._toArrayLikeLE = function(d, h) {
      for (var g = 0, E = 0, w = 0, x = 0; w < this.length; w++) {
        var T = this.words[w] << x | E;
        d[g++] = T & 255, g < d.length && (d[g++] = T >> 8 & 255), g < d.length && (d[g++] = T >> 16 & 255), x === 6 ? (g < d.length && (d[g++] = T >> 24 & 255), E = 0, x = 0) : (E = T >>> 24, x += 2);
      }
      if (g < d.length)
        for (d[g++] = E; g < d.length; )
          d[g++] = 0;
    }, s.prototype._toArrayLikeBE = function(d, h) {
      for (var g = d.length - 1, E = 0, w = 0, x = 0; w < this.length; w++) {
        var T = this.words[w] << x | E;
        d[g--] = T & 255, g >= 0 && (d[g--] = T >> 8 & 255), g >= 0 && (d[g--] = T >> 16 & 255), x === 6 ? (g >= 0 && (d[g--] = T >> 24 & 255), E = 0, x = 0) : (E = T >>> 24, x += 2);
      }
      if (g >= 0)
        for (d[g--] = E; g >= 0; )
          d[g--] = 0;
    }, Math.clz32 ? s.prototype._countBits = function(d) {
      return 32 - Math.clz32(d);
    } : s.prototype._countBits = function(d) {
      var h = d, g = 0;
      return h >= 4096 && (g += 13, h >>>= 13), h >= 64 && (g += 7, h >>>= 7), h >= 8 && (g += 4, h >>>= 4), h >= 2 && (g += 2, h >>>= 2), g + h;
    }, s.prototype._zeroBits = function(d) {
      if (d === 0)
        return 26;
      var h = d, g = 0;
      return h & 8191 || (g += 13, h >>>= 13), h & 127 || (g += 7, h >>>= 7), h & 15 || (g += 4, h >>>= 4), h & 3 || (g += 2, h >>>= 2), h & 1 || g++, g;
    }, s.prototype.bitLength = function() {
      var d = this.words[this.length - 1], h = this._countBits(d);
      return (this.length - 1) * 26 + h;
    };
    function C(P) {
      for (var d = new Array(P.bitLength()), h = 0; h < d.length; h++) {
        var g = h / 26 | 0, E = h % 26;
        d[h] = P.words[g] >>> E & 1;
      }
      return d;
    }
    s.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var d = 0, h = 0; h < this.length; h++) {
        var g = this._zeroBits(this.words[h]);
        if (d += g, g !== 26)
          break;
      }
      return d;
    }, s.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, s.prototype.toTwos = function(d) {
      return this.negative !== 0 ? this.abs().inotn(d).iaddn(1) : this.clone();
    }, s.prototype.fromTwos = function(d) {
      return this.testn(d - 1) ? this.notn(d).iaddn(1).ineg() : this.clone();
    }, s.prototype.isNeg = function() {
      return this.negative !== 0;
    }, s.prototype.neg = function() {
      return this.clone().ineg();
    }, s.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, s.prototype.iuor = function(d) {
      for (; this.length < d.length; )
        this.words[this.length++] = 0;
      for (var h = 0; h < d.length; h++)
        this.words[h] = this.words[h] | d.words[h];
      return this._strip();
    }, s.prototype.ior = function(d) {
      return r((this.negative | d.negative) === 0), this.iuor(d);
    }, s.prototype.or = function(d) {
      return this.length > d.length ? this.clone().ior(d) : d.clone().ior(this);
    }, s.prototype.uor = function(d) {
      return this.length > d.length ? this.clone().iuor(d) : d.clone().iuor(this);
    }, s.prototype.iuand = function(d) {
      var h;
      this.length > d.length ? h = d : h = this;
      for (var g = 0; g < h.length; g++)
        this.words[g] = this.words[g] & d.words[g];
      return this.length = h.length, this._strip();
    }, s.prototype.iand = function(d) {
      return r((this.negative | d.negative) === 0), this.iuand(d);
    }, s.prototype.and = function(d) {
      return this.length > d.length ? this.clone().iand(d) : d.clone().iand(this);
    }, s.prototype.uand = function(d) {
      return this.length > d.length ? this.clone().iuand(d) : d.clone().iuand(this);
    }, s.prototype.iuxor = function(d) {
      var h, g;
      this.length > d.length ? (h = this, g = d) : (h = d, g = this);
      for (var E = 0; E < g.length; E++)
        this.words[E] = h.words[E] ^ g.words[E];
      if (this !== h)
        for (; E < h.length; E++)
          this.words[E] = h.words[E];
      return this.length = h.length, this._strip();
    }, s.prototype.ixor = function(d) {
      return r((this.negative | d.negative) === 0), this.iuxor(d);
    }, s.prototype.xor = function(d) {
      return this.length > d.length ? this.clone().ixor(d) : d.clone().ixor(this);
    }, s.prototype.uxor = function(d) {
      return this.length > d.length ? this.clone().iuxor(d) : d.clone().iuxor(this);
    }, s.prototype.inotn = function(d) {
      r(typeof d == "number" && d >= 0);
      var h = Math.ceil(d / 26) | 0, g = d % 26;
      this._expand(h), g > 0 && h--;
      for (var E = 0; E < h; E++)
        this.words[E] = ~this.words[E] & 67108863;
      return g > 0 && (this.words[E] = ~this.words[E] & 67108863 >> 26 - g), this._strip();
    }, s.prototype.notn = function(d) {
      return this.clone().inotn(d);
    }, s.prototype.setn = function(d, h) {
      r(typeof d == "number" && d >= 0);
      var g = d / 26 | 0, E = d % 26;
      return this._expand(g + 1), h ? this.words[g] = this.words[g] | 1 << E : this.words[g] = this.words[g] & ~(1 << E), this._strip();
    }, s.prototype.iadd = function(d) {
      var h;
      if (this.negative !== 0 && d.negative === 0)
        return this.negative = 0, h = this.isub(d), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && d.negative !== 0)
        return d.negative = 0, h = this.isub(d), d.negative = 1, h._normSign();
      var g, E;
      this.length > d.length ? (g = this, E = d) : (g = d, E = this);
      for (var w = 0, x = 0; x < E.length; x++)
        h = (g.words[x] | 0) + (E.words[x] | 0) + w, this.words[x] = h & 67108863, w = h >>> 26;
      for (; w !== 0 && x < g.length; x++)
        h = (g.words[x] | 0) + w, this.words[x] = h & 67108863, w = h >>> 26;
      if (this.length = g.length, w !== 0)
        this.words[this.length] = w, this.length++;
      else if (g !== this)
        for (; x < g.length; x++)
          this.words[x] = g.words[x];
      return this;
    }, s.prototype.add = function(d) {
      var h;
      return d.negative !== 0 && this.negative === 0 ? (d.negative = 0, h = this.sub(d), d.negative ^= 1, h) : d.negative === 0 && this.negative !== 0 ? (this.negative = 0, h = d.sub(this), this.negative = 1, h) : this.length > d.length ? this.clone().iadd(d) : d.clone().iadd(this);
    }, s.prototype.isub = function(d) {
      if (d.negative !== 0) {
        d.negative = 0;
        var h = this.iadd(d);
        return d.negative = 1, h._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(d), this.negative = 1, this._normSign();
      var g = this.cmp(d);
      if (g === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var E, w;
      g > 0 ? (E = this, w = d) : (E = d, w = this);
      for (var x = 0, T = 0; T < w.length; T++)
        h = (E.words[T] | 0) - (w.words[T] | 0) + x, x = h >> 26, this.words[T] = h & 67108863;
      for (; x !== 0 && T < E.length; T++)
        h = (E.words[T] | 0) + x, x = h >> 26, this.words[T] = h & 67108863;
      if (x === 0 && T < E.length && E !== this)
        for (; T < E.length; T++)
          this.words[T] = E.words[T];
      return this.length = Math.max(this.length, T), E !== this && (this.negative = 1), this._strip();
    }, s.prototype.sub = function(d) {
      return this.clone().isub(d);
    };
    function A(P, d, h) {
      h.negative = d.negative ^ P.negative;
      var g = P.length + d.length | 0;
      h.length = g, g = g - 1 | 0;
      var E = P.words[0] | 0, w = d.words[0] | 0, x = E * w, T = x & 67108863, S = x / 67108864 | 0;
      h.words[0] = T;
      for (var p = 1; p < g; p++) {
        for (var k = S >>> 26, q = S & 67108863, X = Math.min(p, d.length - 1), W = Math.max(0, p - P.length + 1); W <= X; W++) {
          var se = p - W | 0;
          E = P.words[se] | 0, w = d.words[W] | 0, x = E * w + q, k += x / 67108864 | 0, q = x & 67108863;
        }
        h.words[p] = q | 0, S = k | 0;
      }
      return S !== 0 ? h.words[p] = S | 0 : h.length--, h._strip();
    }
    var R = function(d, h, g) {
      var E = d.words, w = h.words, x = g.words, T = 0, S, p, k, q = E[0] | 0, X = q & 8191, W = q >>> 13, se = E[1] | 0, ce = se & 8191, le = se >>> 13, De = E[2] | 0, de = De & 8191, me = De >>> 13, Re = E[3] | 0, be = Re & 8191, Te = Re >>> 13, xr = E[4] | 0, je = xr & 8191, Je = xr >>> 13, Ks = E[5] | 0, Ke = Ks & 8191, Ye = Ks >>> 13, Gi = E[6] | 0, We = Gi & 8191, Ue = Gi >>> 13, Zi = E[7] | 0, qe = Zi & 8191, ze = Zi >>> 13, Ji = E[8] | 0, Xe = Ji & 8191, Qe = Ji >>> 13, Ys = E[9] | 0, $e = Ys & 8191, et = Ys >>> 13, kd = w[0] | 0, rt = kd & 8191, it = kd >>> 13, Td = w[1] | 0, st = Td & 8191, at = Td >>> 13, Nd = w[2] | 0, ot = Nd & 8191, ct = Nd >>> 13, Rd = w[3] | 0, lt = Rd & 8191, ut = Rd >>> 13, Id = w[4] | 0, dt = Id & 8191, ft = Id >>> 13, Od = w[5] | 0, ht = Od & 8191, pt = Od >>> 13, Md = w[6] | 0, mt = Md & 8191, gt = Md >>> 13, Ld = w[7] | 0, yt = Ld & 8191, _t = Ld >>> 13, Dd = w[8] | 0, vt = Dd & 8191, bt = Dd >>> 13, Ud = w[9] | 0, wt = Ud & 8191, xt = Ud >>> 13;
      g.negative = d.negative ^ h.negative, g.length = 19, S = Math.imul(X, rt), p = Math.imul(X, it), p = p + Math.imul(W, rt) | 0, k = Math.imul(W, it);
      var Uo = (T + S | 0) + ((p & 8191) << 13) | 0;
      T = (k + (p >>> 13) | 0) + (Uo >>> 26) | 0, Uo &= 67108863, S = Math.imul(ce, rt), p = Math.imul(ce, it), p = p + Math.imul(le, rt) | 0, k = Math.imul(le, it), S = S + Math.imul(X, st) | 0, p = p + Math.imul(X, at) | 0, p = p + Math.imul(W, st) | 0, k = k + Math.imul(W, at) | 0;
      var Vo = (T + S | 0) + ((p & 8191) << 13) | 0;
      T = (k + (p >>> 13) | 0) + (Vo >>> 26) | 0, Vo &= 67108863, S = Math.imul(de, rt), p = Math.imul(de, it), p = p + Math.imul(me, rt) | 0, k = Math.imul(me, it), S = S + Math.imul(ce, st) | 0, p = p + Math.imul(ce, at) | 0, p = p + Math.imul(le, st) | 0, k = k + Math.imul(le, at) | 0, S = S + Math.imul(X, ot) | 0, p = p + Math.imul(X, ct) | 0, p = p + Math.imul(W, ot) | 0, k = k + Math.imul(W, ct) | 0;
      var Bo = (T + S | 0) + ((p & 8191) << 13) | 0;
      T = (k + (p >>> 13) | 0) + (Bo >>> 26) | 0, Bo &= 67108863, S = Math.imul(be, rt), p = Math.imul(be, it), p = p + Math.imul(Te, rt) | 0, k = Math.imul(Te, it), S = S + Math.imul(de, st) | 0, p = p + Math.imul(de, at) | 0, p = p + Math.imul(me, st) | 0, k = k + Math.imul(me, at) | 0, S = S + Math.imul(ce, ot) | 0, p = p + Math.imul(ce, ct) | 0, p = p + Math.imul(le, ot) | 0, k = k + Math.imul(le, ct) | 0, S = S + Math.imul(X, lt) | 0, p = p + Math.imul(X, ut) | 0, p = p + Math.imul(W, lt) | 0, k = k + Math.imul(W, ut) | 0;
      var Ho = (T + S | 0) + ((p & 8191) << 13) | 0;
      T = (k + (p >>> 13) | 0) + (Ho >>> 26) | 0, Ho &= 67108863, S = Math.imul(je, rt), p = Math.imul(je, it), p = p + Math.imul(Je, rt) | 0, k = Math.imul(Je, it), S = S + Math.imul(be, st) | 0, p = p + Math.imul(be, at) | 0, p = p + Math.imul(Te, st) | 0, k = k + Math.imul(Te, at) | 0, S = S + Math.imul(de, ot) | 0, p = p + Math.imul(de, ct) | 0, p = p + Math.imul(me, ot) | 0, k = k + Math.imul(me, ct) | 0, S = S + Math.imul(ce, lt) | 0, p = p + Math.imul(ce, ut) | 0, p = p + Math.imul(le, lt) | 0, k = k + Math.imul(le, ut) | 0, S = S + Math.imul(X, dt) | 0, p = p + Math.imul(X, ft) | 0, p = p + Math.imul(W, dt) | 0, k = k + Math.imul(W, ft) | 0;
      var Fo = (T + S | 0) + ((p & 8191) << 13) | 0;
      T = (k + (p >>> 13) | 0) + (Fo >>> 26) | 0, Fo &= 67108863, S = Math.imul(Ke, rt), p = Math.imul(Ke, it), p = p + Math.imul(Ye, rt) | 0, k = Math.imul(Ye, it), S = S + Math.imul(je, st) | 0, p = p + Math.imul(je, at) | 0, p = p + Math.imul(Je, st) | 0, k = k + Math.imul(Je, at) | 0, S = S + Math.imul(be, ot) | 0, p = p + Math.imul(be, ct) | 0, p = p + Math.imul(Te, ot) | 0, k = k + Math.imul(Te, ct) | 0, S = S + Math.imul(de, lt) | 0, p = p + Math.imul(de, ut) | 0, p = p + Math.imul(me, lt) | 0, k = k + Math.imul(me, ut) | 0, S = S + Math.imul(ce, dt) | 0, p = p + Math.imul(ce, ft) | 0, p = p + Math.imul(le, dt) | 0, k = k + Math.imul(le, ft) | 0, S = S + Math.imul(X, ht) | 0, p = p + Math.imul(X, pt) | 0, p = p + Math.imul(W, ht) | 0, k = k + Math.imul(W, pt) | 0;
      var jo = (T + S | 0) + ((p & 8191) << 13) | 0;
      T = (k + (p >>> 13) | 0) + (jo >>> 26) | 0, jo &= 67108863, S = Math.imul(We, rt), p = Math.imul(We, it), p = p + Math.imul(Ue, rt) | 0, k = Math.imul(Ue, it), S = S + Math.imul(Ke, st) | 0, p = p + Math.imul(Ke, at) | 0, p = p + Math.imul(Ye, st) | 0, k = k + Math.imul(Ye, at) | 0, S = S + Math.imul(je, ot) | 0, p = p + Math.imul(je, ct) | 0, p = p + Math.imul(Je, ot) | 0, k = k + Math.imul(Je, ct) | 0, S = S + Math.imul(be, lt) | 0, p = p + Math.imul(be, ut) | 0, p = p + Math.imul(Te, lt) | 0, k = k + Math.imul(Te, ut) | 0, S = S + Math.imul(de, dt) | 0, p = p + Math.imul(de, ft) | 0, p = p + Math.imul(me, dt) | 0, k = k + Math.imul(me, ft) | 0, S = S + Math.imul(ce, ht) | 0, p = p + Math.imul(ce, pt) | 0, p = p + Math.imul(le, ht) | 0, k = k + Math.imul(le, pt) | 0, S = S + Math.imul(X, mt) | 0, p = p + Math.imul(X, gt) | 0, p = p + Math.imul(W, mt) | 0, k = k + Math.imul(W, gt) | 0;
      var Wo = (T + S | 0) + ((p & 8191) << 13) | 0;
      T = (k + (p >>> 13) | 0) + (Wo >>> 26) | 0, Wo &= 67108863, S = Math.imul(qe, rt), p = Math.imul(qe, it), p = p + Math.imul(ze, rt) | 0, k = Math.imul(ze, it), S = S + Math.imul(We, st) | 0, p = p + Math.imul(We, at) | 0, p = p + Math.imul(Ue, st) | 0, k = k + Math.imul(Ue, at) | 0, S = S + Math.imul(Ke, ot) | 0, p = p + Math.imul(Ke, ct) | 0, p = p + Math.imul(Ye, ot) | 0, k = k + Math.imul(Ye, ct) | 0, S = S + Math.imul(je, lt) | 0, p = p + Math.imul(je, ut) | 0, p = p + Math.imul(Je, lt) | 0, k = k + Math.imul(Je, ut) | 0, S = S + Math.imul(be, dt) | 0, p = p + Math.imul(be, ft) | 0, p = p + Math.imul(Te, dt) | 0, k = k + Math.imul(Te, ft) | 0, S = S + Math.imul(de, ht) | 0, p = p + Math.imul(de, pt) | 0, p = p + Math.imul(me, ht) | 0, k = k + Math.imul(me, pt) | 0, S = S + Math.imul(ce, mt) | 0, p = p + Math.imul(ce, gt) | 0, p = p + Math.imul(le, mt) | 0, k = k + Math.imul(le, gt) | 0, S = S + Math.imul(X, yt) | 0, p = p + Math.imul(X, _t) | 0, p = p + Math.imul(W, yt) | 0, k = k + Math.imul(W, _t) | 0;
      var qo = (T + S | 0) + ((p & 8191) << 13) | 0;
      T = (k + (p >>> 13) | 0) + (qo >>> 26) | 0, qo &= 67108863, S = Math.imul(Xe, rt), p = Math.imul(Xe, it), p = p + Math.imul(Qe, rt) | 0, k = Math.imul(Qe, it), S = S + Math.imul(qe, st) | 0, p = p + Math.imul(qe, at) | 0, p = p + Math.imul(ze, st) | 0, k = k + Math.imul(ze, at) | 0, S = S + Math.imul(We, ot) | 0, p = p + Math.imul(We, ct) | 0, p = p + Math.imul(Ue, ot) | 0, k = k + Math.imul(Ue, ct) | 0, S = S + Math.imul(Ke, lt) | 0, p = p + Math.imul(Ke, ut) | 0, p = p + Math.imul(Ye, lt) | 0, k = k + Math.imul(Ye, ut) | 0, S = S + Math.imul(je, dt) | 0, p = p + Math.imul(je, ft) | 0, p = p + Math.imul(Je, dt) | 0, k = k + Math.imul(Je, ft) | 0, S = S + Math.imul(be, ht) | 0, p = p + Math.imul(be, pt) | 0, p = p + Math.imul(Te, ht) | 0, k = k + Math.imul(Te, pt) | 0, S = S + Math.imul(de, mt) | 0, p = p + Math.imul(de, gt) | 0, p = p + Math.imul(me, mt) | 0, k = k + Math.imul(me, gt) | 0, S = S + Math.imul(ce, yt) | 0, p = p + Math.imul(ce, _t) | 0, p = p + Math.imul(le, yt) | 0, k = k + Math.imul(le, _t) | 0, S = S + Math.imul(X, vt) | 0, p = p + Math.imul(X, bt) | 0, p = p + Math.imul(W, vt) | 0, k = k + Math.imul(W, bt) | 0;
      var zo = (T + S | 0) + ((p & 8191) << 13) | 0;
      T = (k + (p >>> 13) | 0) + (zo >>> 26) | 0, zo &= 67108863, S = Math.imul($e, rt), p = Math.imul($e, it), p = p + Math.imul(et, rt) | 0, k = Math.imul(et, it), S = S + Math.imul(Xe, st) | 0, p = p + Math.imul(Xe, at) | 0, p = p + Math.imul(Qe, st) | 0, k = k + Math.imul(Qe, at) | 0, S = S + Math.imul(qe, ot) | 0, p = p + Math.imul(qe, ct) | 0, p = p + Math.imul(ze, ot) | 0, k = k + Math.imul(ze, ct) | 0, S = S + Math.imul(We, lt) | 0, p = p + Math.imul(We, ut) | 0, p = p + Math.imul(Ue, lt) | 0, k = k + Math.imul(Ue, ut) | 0, S = S + Math.imul(Ke, dt) | 0, p = p + Math.imul(Ke, ft) | 0, p = p + Math.imul(Ye, dt) | 0, k = k + Math.imul(Ye, ft) | 0, S = S + Math.imul(je, ht) | 0, p = p + Math.imul(je, pt) | 0, p = p + Math.imul(Je, ht) | 0, k = k + Math.imul(Je, pt) | 0, S = S + Math.imul(be, mt) | 0, p = p + Math.imul(be, gt) | 0, p = p + Math.imul(Te, mt) | 0, k = k + Math.imul(Te, gt) | 0, S = S + Math.imul(de, yt) | 0, p = p + Math.imul(de, _t) | 0, p = p + Math.imul(me, yt) | 0, k = k + Math.imul(me, _t) | 0, S = S + Math.imul(ce, vt) | 0, p = p + Math.imul(ce, bt) | 0, p = p + Math.imul(le, vt) | 0, k = k + Math.imul(le, bt) | 0, S = S + Math.imul(X, wt) | 0, p = p + Math.imul(X, xt) | 0, p = p + Math.imul(W, wt) | 0, k = k + Math.imul(W, xt) | 0;
      var Xo = (T + S | 0) + ((p & 8191) << 13) | 0;
      T = (k + (p >>> 13) | 0) + (Xo >>> 26) | 0, Xo &= 67108863, S = Math.imul($e, st), p = Math.imul($e, at), p = p + Math.imul(et, st) | 0, k = Math.imul(et, at), S = S + Math.imul(Xe, ot) | 0, p = p + Math.imul(Xe, ct) | 0, p = p + Math.imul(Qe, ot) | 0, k = k + Math.imul(Qe, ct) | 0, S = S + Math.imul(qe, lt) | 0, p = p + Math.imul(qe, ut) | 0, p = p + Math.imul(ze, lt) | 0, k = k + Math.imul(ze, ut) | 0, S = S + Math.imul(We, dt) | 0, p = p + Math.imul(We, ft) | 0, p = p + Math.imul(Ue, dt) | 0, k = k + Math.imul(Ue, ft) | 0, S = S + Math.imul(Ke, ht) | 0, p = p + Math.imul(Ke, pt) | 0, p = p + Math.imul(Ye, ht) | 0, k = k + Math.imul(Ye, pt) | 0, S = S + Math.imul(je, mt) | 0, p = p + Math.imul(je, gt) | 0, p = p + Math.imul(Je, mt) | 0, k = k + Math.imul(Je, gt) | 0, S = S + Math.imul(be, yt) | 0, p = p + Math.imul(be, _t) | 0, p = p + Math.imul(Te, yt) | 0, k = k + Math.imul(Te, _t) | 0, S = S + Math.imul(de, vt) | 0, p = p + Math.imul(de, bt) | 0, p = p + Math.imul(me, vt) | 0, k = k + Math.imul(me, bt) | 0, S = S + Math.imul(ce, wt) | 0, p = p + Math.imul(ce, xt) | 0, p = p + Math.imul(le, wt) | 0, k = k + Math.imul(le, xt) | 0;
      var Go = (T + S | 0) + ((p & 8191) << 13) | 0;
      T = (k + (p >>> 13) | 0) + (Go >>> 26) | 0, Go &= 67108863, S = Math.imul($e, ot), p = Math.imul($e, ct), p = p + Math.imul(et, ot) | 0, k = Math.imul(et, ct), S = S + Math.imul(Xe, lt) | 0, p = p + Math.imul(Xe, ut) | 0, p = p + Math.imul(Qe, lt) | 0, k = k + Math.imul(Qe, ut) | 0, S = S + Math.imul(qe, dt) | 0, p = p + Math.imul(qe, ft) | 0, p = p + Math.imul(ze, dt) | 0, k = k + Math.imul(ze, ft) | 0, S = S + Math.imul(We, ht) | 0, p = p + Math.imul(We, pt) | 0, p = p + Math.imul(Ue, ht) | 0, k = k + Math.imul(Ue, pt) | 0, S = S + Math.imul(Ke, mt) | 0, p = p + Math.imul(Ke, gt) | 0, p = p + Math.imul(Ye, mt) | 0, k = k + Math.imul(Ye, gt) | 0, S = S + Math.imul(je, yt) | 0, p = p + Math.imul(je, _t) | 0, p = p + Math.imul(Je, yt) | 0, k = k + Math.imul(Je, _t) | 0, S = S + Math.imul(be, vt) | 0, p = p + Math.imul(be, bt) | 0, p = p + Math.imul(Te, vt) | 0, k = k + Math.imul(Te, bt) | 0, S = S + Math.imul(de, wt) | 0, p = p + Math.imul(de, xt) | 0, p = p + Math.imul(me, wt) | 0, k = k + Math.imul(me, xt) | 0;
      var Zo = (T + S | 0) + ((p & 8191) << 13) | 0;
      T = (k + (p >>> 13) | 0) + (Zo >>> 26) | 0, Zo &= 67108863, S = Math.imul($e, lt), p = Math.imul($e, ut), p = p + Math.imul(et, lt) | 0, k = Math.imul(et, ut), S = S + Math.imul(Xe, dt) | 0, p = p + Math.imul(Xe, ft) | 0, p = p + Math.imul(Qe, dt) | 0, k = k + Math.imul(Qe, ft) | 0, S = S + Math.imul(qe, ht) | 0, p = p + Math.imul(qe, pt) | 0, p = p + Math.imul(ze, ht) | 0, k = k + Math.imul(ze, pt) | 0, S = S + Math.imul(We, mt) | 0, p = p + Math.imul(We, gt) | 0, p = p + Math.imul(Ue, mt) | 0, k = k + Math.imul(Ue, gt) | 0, S = S + Math.imul(Ke, yt) | 0, p = p + Math.imul(Ke, _t) | 0, p = p + Math.imul(Ye, yt) | 0, k = k + Math.imul(Ye, _t) | 0, S = S + Math.imul(je, vt) | 0, p = p + Math.imul(je, bt) | 0, p = p + Math.imul(Je, vt) | 0, k = k + Math.imul(Je, bt) | 0, S = S + Math.imul(be, wt) | 0, p = p + Math.imul(be, xt) | 0, p = p + Math.imul(Te, wt) | 0, k = k + Math.imul(Te, xt) | 0;
      var Jo = (T + S | 0) + ((p & 8191) << 13) | 0;
      T = (k + (p >>> 13) | 0) + (Jo >>> 26) | 0, Jo &= 67108863, S = Math.imul($e, dt), p = Math.imul($e, ft), p = p + Math.imul(et, dt) | 0, k = Math.imul(et, ft), S = S + Math.imul(Xe, ht) | 0, p = p + Math.imul(Xe, pt) | 0, p = p + Math.imul(Qe, ht) | 0, k = k + Math.imul(Qe, pt) | 0, S = S + Math.imul(qe, mt) | 0, p = p + Math.imul(qe, gt) | 0, p = p + Math.imul(ze, mt) | 0, k = k + Math.imul(ze, gt) | 0, S = S + Math.imul(We, yt) | 0, p = p + Math.imul(We, _t) | 0, p = p + Math.imul(Ue, yt) | 0, k = k + Math.imul(Ue, _t) | 0, S = S + Math.imul(Ke, vt) | 0, p = p + Math.imul(Ke, bt) | 0, p = p + Math.imul(Ye, vt) | 0, k = k + Math.imul(Ye, bt) | 0, S = S + Math.imul(je, wt) | 0, p = p + Math.imul(je, xt) | 0, p = p + Math.imul(Je, wt) | 0, k = k + Math.imul(Je, xt) | 0;
      var Ko = (T + S | 0) + ((p & 8191) << 13) | 0;
      T = (k + (p >>> 13) | 0) + (Ko >>> 26) | 0, Ko &= 67108863, S = Math.imul($e, ht), p = Math.imul($e, pt), p = p + Math.imul(et, ht) | 0, k = Math.imul(et, pt), S = S + Math.imul(Xe, mt) | 0, p = p + Math.imul(Xe, gt) | 0, p = p + Math.imul(Qe, mt) | 0, k = k + Math.imul(Qe, gt) | 0, S = S + Math.imul(qe, yt) | 0, p = p + Math.imul(qe, _t) | 0, p = p + Math.imul(ze, yt) | 0, k = k + Math.imul(ze, _t) | 0, S = S + Math.imul(We, vt) | 0, p = p + Math.imul(We, bt) | 0, p = p + Math.imul(Ue, vt) | 0, k = k + Math.imul(Ue, bt) | 0, S = S + Math.imul(Ke, wt) | 0, p = p + Math.imul(Ke, xt) | 0, p = p + Math.imul(Ye, wt) | 0, k = k + Math.imul(Ye, xt) | 0;
      var Yo = (T + S | 0) + ((p & 8191) << 13) | 0;
      T = (k + (p >>> 13) | 0) + (Yo >>> 26) | 0, Yo &= 67108863, S = Math.imul($e, mt), p = Math.imul($e, gt), p = p + Math.imul(et, mt) | 0, k = Math.imul(et, gt), S = S + Math.imul(Xe, yt) | 0, p = p + Math.imul(Xe, _t) | 0, p = p + Math.imul(Qe, yt) | 0, k = k + Math.imul(Qe, _t) | 0, S = S + Math.imul(qe, vt) | 0, p = p + Math.imul(qe, bt) | 0, p = p + Math.imul(ze, vt) | 0, k = k + Math.imul(ze, bt) | 0, S = S + Math.imul(We, wt) | 0, p = p + Math.imul(We, xt) | 0, p = p + Math.imul(Ue, wt) | 0, k = k + Math.imul(Ue, xt) | 0;
      var Qo = (T + S | 0) + ((p & 8191) << 13) | 0;
      T = (k + (p >>> 13) | 0) + (Qo >>> 26) | 0, Qo &= 67108863, S = Math.imul($e, yt), p = Math.imul($e, _t), p = p + Math.imul(et, yt) | 0, k = Math.imul(et, _t), S = S + Math.imul(Xe, vt) | 0, p = p + Math.imul(Xe, bt) | 0, p = p + Math.imul(Qe, vt) | 0, k = k + Math.imul(Qe, bt) | 0, S = S + Math.imul(qe, wt) | 0, p = p + Math.imul(qe, xt) | 0, p = p + Math.imul(ze, wt) | 0, k = k + Math.imul(ze, xt) | 0;
      var $o = (T + S | 0) + ((p & 8191) << 13) | 0;
      T = (k + (p >>> 13) | 0) + ($o >>> 26) | 0, $o &= 67108863, S = Math.imul($e, vt), p = Math.imul($e, bt), p = p + Math.imul(et, vt) | 0, k = Math.imul(et, bt), S = S + Math.imul(Xe, wt) | 0, p = p + Math.imul(Xe, xt) | 0, p = p + Math.imul(Qe, wt) | 0, k = k + Math.imul(Qe, xt) | 0;
      var ec = (T + S | 0) + ((p & 8191) << 13) | 0;
      T = (k + (p >>> 13) | 0) + (ec >>> 26) | 0, ec &= 67108863, S = Math.imul($e, wt), p = Math.imul($e, xt), p = p + Math.imul(et, wt) | 0, k = Math.imul(et, xt);
      var tc = (T + S | 0) + ((p & 8191) << 13) | 0;
      return T = (k + (p >>> 13) | 0) + (tc >>> 26) | 0, tc &= 67108863, x[0] = Uo, x[1] = Vo, x[2] = Bo, x[3] = Ho, x[4] = Fo, x[5] = jo, x[6] = Wo, x[7] = qo, x[8] = zo, x[9] = Xo, x[10] = Go, x[11] = Zo, x[12] = Jo, x[13] = Ko, x[14] = Yo, x[15] = Qo, x[16] = $o, x[17] = ec, x[18] = tc, T !== 0 && (x[19] = T, g.length++), g;
    };
    Math.imul || (R = A);
    function I(P, d, h) {
      h.negative = d.negative ^ P.negative, h.length = P.length + d.length;
      for (var g = 0, E = 0, w = 0; w < h.length - 1; w++) {
        var x = E;
        E = 0;
        for (var T = g & 67108863, S = Math.min(w, d.length - 1), p = Math.max(0, w - P.length + 1); p <= S; p++) {
          var k = w - p, q = P.words[k] | 0, X = d.words[p] | 0, W = q * X, se = W & 67108863;
          x = x + (W / 67108864 | 0) | 0, se = se + T | 0, T = se & 67108863, x = x + (se >>> 26) | 0, E += x >>> 26, x &= 67108863;
        }
        h.words[w] = T, g = x, x = E;
      }
      return g !== 0 ? h.words[w] = g : h.length--, h._strip();
    }
    function D(P, d, h) {
      return I(P, d, h);
    }
    s.prototype.mulTo = function(d, h) {
      var g, E = this.length + d.length;
      return this.length === 10 && d.length === 10 ? g = R(this, d, h) : E < 63 ? g = A(this, d, h) : E < 1024 ? g = I(this, d, h) : g = D(this, d, h), g;
    }, s.prototype.mul = function(d) {
      var h = new s(null);
      return h.words = new Array(this.length + d.length), this.mulTo(d, h);
    }, s.prototype.mulf = function(d) {
      var h = new s(null);
      return h.words = new Array(this.length + d.length), D(this, d, h);
    }, s.prototype.imul = function(d) {
      return this.clone().mulTo(d, this);
    }, s.prototype.imuln = function(d) {
      var h = d < 0;
      h && (d = -d), r(typeof d == "number"), r(d < 67108864);
      for (var g = 0, E = 0; E < this.length; E++) {
        var w = (this.words[E] | 0) * d, x = (w & 67108863) + (g & 67108863);
        g >>= 26, g += w / 67108864 | 0, g += x >>> 26, this.words[E] = x & 67108863;
      }
      return g !== 0 && (this.words[E] = g, this.length++), h ? this.ineg() : this;
    }, s.prototype.muln = function(d) {
      return this.clone().imuln(d);
    }, s.prototype.sqr = function() {
      return this.mul(this);
    }, s.prototype.isqr = function() {
      return this.imul(this.clone());
    }, s.prototype.pow = function(d) {
      var h = C(d);
      if (h.length === 0)
        return new s(1);
      for (var g = this, E = 0; E < h.length && h[E] === 0; E++, g = g.sqr())
        ;
      if (++E < h.length)
        for (var w = g.sqr(); E < h.length; E++, w = w.sqr())
          h[E] !== 0 && (g = g.mul(w));
      return g;
    }, s.prototype.iushln = function(d) {
      r(typeof d == "number" && d >= 0);
      var h = d % 26, g = (d - h) / 26, E = 67108863 >>> 26 - h << 26 - h, w;
      if (h !== 0) {
        var x = 0;
        for (w = 0; w < this.length; w++) {
          var T = this.words[w] & E, S = (this.words[w] | 0) - T << h;
          this.words[w] = S | x, x = T >>> 26 - h;
        }
        x && (this.words[w] = x, this.length++);
      }
      if (g !== 0) {
        for (w = this.length - 1; w >= 0; w--)
          this.words[w + g] = this.words[w];
        for (w = 0; w < g; w++)
          this.words[w] = 0;
        this.length += g;
      }
      return this._strip();
    }, s.prototype.ishln = function(d) {
      return r(this.negative === 0), this.iushln(d);
    }, s.prototype.iushrn = function(d, h, g) {
      r(typeof d == "number" && d >= 0);
      var E;
      h ? E = (h - h % 26) / 26 : E = 0;
      var w = d % 26, x = Math.min((d - w) / 26, this.length), T = 67108863 ^ 67108863 >>> w << w, S = g;
      if (E -= x, E = Math.max(0, E), S) {
        for (var p = 0; p < x; p++)
          S.words[p] = this.words[p];
        S.length = x;
      }
      if (x !== 0)
        if (this.length > x)
          for (this.length -= x, p = 0; p < this.length; p++)
            this.words[p] = this.words[p + x];
        else
          this.words[0] = 0, this.length = 1;
      var k = 0;
      for (p = this.length - 1; p >= 0 && (k !== 0 || p >= E); p--) {
        var q = this.words[p] | 0;
        this.words[p] = k << 26 - w | q >>> w, k = q & T;
      }
      return S && k !== 0 && (S.words[S.length++] = k), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
    }, s.prototype.ishrn = function(d, h, g) {
      return r(this.negative === 0), this.iushrn(d, h, g);
    }, s.prototype.shln = function(d) {
      return this.clone().ishln(d);
    }, s.prototype.ushln = function(d) {
      return this.clone().iushln(d);
    }, s.prototype.shrn = function(d) {
      return this.clone().ishrn(d);
    }, s.prototype.ushrn = function(d) {
      return this.clone().iushrn(d);
    }, s.prototype.testn = function(d) {
      r(typeof d == "number" && d >= 0);
      var h = d % 26, g = (d - h) / 26, E = 1 << h;
      if (this.length <= g)
        return !1;
      var w = this.words[g];
      return !!(w & E);
    }, s.prototype.imaskn = function(d) {
      r(typeof d == "number" && d >= 0);
      var h = d % 26, g = (d - h) / 26;
      if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= g)
        return this;
      if (h !== 0 && g++, this.length = Math.min(g, this.length), h !== 0) {
        var E = 67108863 ^ 67108863 >>> h << h;
        this.words[this.length - 1] &= E;
      }
      return this._strip();
    }, s.prototype.maskn = function(d) {
      return this.clone().imaskn(d);
    }, s.prototype.iaddn = function(d) {
      return r(typeof d == "number"), r(d < 67108864), d < 0 ? this.isubn(-d) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= d ? (this.words[0] = d - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(d), this.negative = 1, this) : this._iaddn(d);
    }, s.prototype._iaddn = function(d) {
      this.words[0] += d;
      for (var h = 0; h < this.length && this.words[h] >= 67108864; h++)
        this.words[h] -= 67108864, h === this.length - 1 ? this.words[h + 1] = 1 : this.words[h + 1]++;
      return this.length = Math.max(this.length, h + 1), this;
    }, s.prototype.isubn = function(d) {
      if (r(typeof d == "number"), r(d < 67108864), d < 0)
        return this.iaddn(-d);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(d), this.negative = 1, this;
      if (this.words[0] -= d, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var h = 0; h < this.length && this.words[h] < 0; h++)
          this.words[h] += 67108864, this.words[h + 1] -= 1;
      return this._strip();
    }, s.prototype.addn = function(d) {
      return this.clone().iaddn(d);
    }, s.prototype.subn = function(d) {
      return this.clone().isubn(d);
    }, s.prototype.iabs = function() {
      return this.negative = 0, this;
    }, s.prototype.abs = function() {
      return this.clone().iabs();
    }, s.prototype._ishlnsubmul = function(d, h, g) {
      var E = d.length + g, w;
      this._expand(E);
      var x, T = 0;
      for (w = 0; w < d.length; w++) {
        x = (this.words[w + g] | 0) + T;
        var S = (d.words[w] | 0) * h;
        x -= S & 67108863, T = (x >> 26) - (S / 67108864 | 0), this.words[w + g] = x & 67108863;
      }
      for (; w < this.length - g; w++)
        x = (this.words[w + g] | 0) + T, T = x >> 26, this.words[w + g] = x & 67108863;
      if (T === 0)
        return this._strip();
      for (r(T === -1), T = 0, w = 0; w < this.length; w++)
        x = -(this.words[w] | 0) + T, T = x >> 26, this.words[w] = x & 67108863;
      return this.negative = 1, this._strip();
    }, s.prototype._wordDiv = function(d, h) {
      var g = this.length - d.length, E = this.clone(), w = d, x = w.words[w.length - 1] | 0, T = this._countBits(x);
      g = 26 - T, g !== 0 && (w = w.ushln(g), E.iushln(g), x = w.words[w.length - 1] | 0);
      var S = E.length - w.length, p;
      if (h !== "mod") {
        p = new s(null), p.length = S + 1, p.words = new Array(p.length);
        for (var k = 0; k < p.length; k++)
          p.words[k] = 0;
      }
      var q = E.clone()._ishlnsubmul(w, 1, S);
      q.negative === 0 && (E = q, p && (p.words[S] = 1));
      for (var X = S - 1; X >= 0; X--) {
        var W = (E.words[w.length + X] | 0) * 67108864 + (E.words[w.length + X - 1] | 0);
        for (W = Math.min(W / x | 0, 67108863), E._ishlnsubmul(w, W, X); E.negative !== 0; )
          W--, E.negative = 0, E._ishlnsubmul(w, 1, X), E.isZero() || (E.negative ^= 1);
        p && (p.words[X] = W);
      }
      return p && p._strip(), E._strip(), h !== "div" && g !== 0 && E.iushrn(g), {
        div: p || null,
        mod: E
      };
    }, s.prototype.divmod = function(d, h, g) {
      if (r(!d.isZero()), this.isZero())
        return {
          div: new s(0),
          mod: new s(0)
        };
      var E, w, x;
      return this.negative !== 0 && d.negative === 0 ? (x = this.neg().divmod(d, h), h !== "mod" && (E = x.div.neg()), h !== "div" && (w = x.mod.neg(), g && w.negative !== 0 && w.iadd(d)), {
        div: E,
        mod: w
      }) : this.negative === 0 && d.negative !== 0 ? (x = this.divmod(d.neg(), h), h !== "mod" && (E = x.div.neg()), {
        div: E,
        mod: x.mod
      }) : this.negative & d.negative ? (x = this.neg().divmod(d.neg(), h), h !== "div" && (w = x.mod.neg(), g && w.negative !== 0 && w.isub(d)), {
        div: x.div,
        mod: w
      }) : d.length > this.length || this.cmp(d) < 0 ? {
        div: new s(0),
        mod: this
      } : d.length === 1 ? h === "div" ? {
        div: this.divn(d.words[0]),
        mod: null
      } : h === "mod" ? {
        div: null,
        mod: new s(this.modrn(d.words[0]))
      } : {
        div: this.divn(d.words[0]),
        mod: new s(this.modrn(d.words[0]))
      } : this._wordDiv(d, h);
    }, s.prototype.div = function(d) {
      return this.divmod(d, "div", !1).div;
    }, s.prototype.mod = function(d) {
      return this.divmod(d, "mod", !1).mod;
    }, s.prototype.umod = function(d) {
      return this.divmod(d, "mod", !0).mod;
    }, s.prototype.divRound = function(d) {
      var h = this.divmod(d);
      if (h.mod.isZero())
        return h.div;
      var g = h.div.negative !== 0 ? h.mod.isub(d) : h.mod, E = d.ushrn(1), w = d.andln(1), x = g.cmp(E);
      return x < 0 || w === 1 && x === 0 ? h.div : h.div.negative !== 0 ? h.div.isubn(1) : h.div.iaddn(1);
    }, s.prototype.modrn = function(d) {
      var h = d < 0;
      h && (d = -d), r(d <= 67108863);
      for (var g = (1 << 26) % d, E = 0, w = this.length - 1; w >= 0; w--)
        E = (g * E + (this.words[w] | 0)) % d;
      return h ? -E : E;
    }, s.prototype.modn = function(d) {
      return this.modrn(d);
    }, s.prototype.idivn = function(d) {
      var h = d < 0;
      h && (d = -d), r(d <= 67108863);
      for (var g = 0, E = this.length - 1; E >= 0; E--) {
        var w = (this.words[E] | 0) + g * 67108864;
        this.words[E] = w / d | 0, g = w % d;
      }
      return this._strip(), h ? this.ineg() : this;
    }, s.prototype.divn = function(d) {
      return this.clone().idivn(d);
    }, s.prototype.egcd = function(d) {
      r(d.negative === 0), r(!d.isZero());
      var h = this, g = d.clone();
      h.negative !== 0 ? h = h.umod(d) : h = h.clone();
      for (var E = new s(1), w = new s(0), x = new s(0), T = new s(1), S = 0; h.isEven() && g.isEven(); )
        h.iushrn(1), g.iushrn(1), ++S;
      for (var p = g.clone(), k = h.clone(); !h.isZero(); ) {
        for (var q = 0, X = 1; !(h.words[0] & X) && q < 26; ++q, X <<= 1)
          ;
        if (q > 0)
          for (h.iushrn(q); q-- > 0; )
            (E.isOdd() || w.isOdd()) && (E.iadd(p), w.isub(k)), E.iushrn(1), w.iushrn(1);
        for (var W = 0, se = 1; !(g.words[0] & se) && W < 26; ++W, se <<= 1)
          ;
        if (W > 0)
          for (g.iushrn(W); W-- > 0; )
            (x.isOdd() || T.isOdd()) && (x.iadd(p), T.isub(k)), x.iushrn(1), T.iushrn(1);
        h.cmp(g) >= 0 ? (h.isub(g), E.isub(x), w.isub(T)) : (g.isub(h), x.isub(E), T.isub(w));
      }
      return {
        a: x,
        b: T,
        gcd: g.iushln(S)
      };
    }, s.prototype._invmp = function(d) {
      r(d.negative === 0), r(!d.isZero());
      var h = this, g = d.clone();
      h.negative !== 0 ? h = h.umod(d) : h = h.clone();
      for (var E = new s(1), w = new s(0), x = g.clone(); h.cmpn(1) > 0 && g.cmpn(1) > 0; ) {
        for (var T = 0, S = 1; !(h.words[0] & S) && T < 26; ++T, S <<= 1)
          ;
        if (T > 0)
          for (h.iushrn(T); T-- > 0; )
            E.isOdd() && E.iadd(x), E.iushrn(1);
        for (var p = 0, k = 1; !(g.words[0] & k) && p < 26; ++p, k <<= 1)
          ;
        if (p > 0)
          for (g.iushrn(p); p-- > 0; )
            w.isOdd() && w.iadd(x), w.iushrn(1);
        h.cmp(g) >= 0 ? (h.isub(g), E.isub(w)) : (g.isub(h), w.isub(E));
      }
      var q;
      return h.cmpn(1) === 0 ? q = E : q = w, q.cmpn(0) < 0 && q.iadd(d), q;
    }, s.prototype.gcd = function(d) {
      if (this.isZero())
        return d.abs();
      if (d.isZero())
        return this.abs();
      var h = this.clone(), g = d.clone();
      h.negative = 0, g.negative = 0;
      for (var E = 0; h.isEven() && g.isEven(); E++)
        h.iushrn(1), g.iushrn(1);
      do {
        for (; h.isEven(); )
          h.iushrn(1);
        for (; g.isEven(); )
          g.iushrn(1);
        var w = h.cmp(g);
        if (w < 0) {
          var x = h;
          h = g, g = x;
        } else if (w === 0 || g.cmpn(1) === 0)
          break;
        h.isub(g);
      } while (!0);
      return g.iushln(E);
    }, s.prototype.invm = function(d) {
      return this.egcd(d).a.umod(d);
    }, s.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, s.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, s.prototype.andln = function(d) {
      return this.words[0] & d;
    }, s.prototype.bincn = function(d) {
      r(typeof d == "number");
      var h = d % 26, g = (d - h) / 26, E = 1 << h;
      if (this.length <= g)
        return this._expand(g + 1), this.words[g] |= E, this;
      for (var w = E, x = g; w !== 0 && x < this.length; x++) {
        var T = this.words[x] | 0;
        T += w, w = T >>> 26, T &= 67108863, this.words[x] = T;
      }
      return w !== 0 && (this.words[x] = w, this.length++), this;
    }, s.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, s.prototype.cmpn = function(d) {
      var h = d < 0;
      if (this.negative !== 0 && !h)
        return -1;
      if (this.negative === 0 && h)
        return 1;
      this._strip();
      var g;
      if (this.length > 1)
        g = 1;
      else {
        h && (d = -d), r(d <= 67108863, "Number is too big");
        var E = this.words[0] | 0;
        g = E === d ? 0 : E < d ? -1 : 1;
      }
      return this.negative !== 0 ? -g | 0 : g;
    }, s.prototype.cmp = function(d) {
      if (this.negative !== 0 && d.negative === 0)
        return -1;
      if (this.negative === 0 && d.negative !== 0)
        return 1;
      var h = this.ucmp(d);
      return this.negative !== 0 ? -h | 0 : h;
    }, s.prototype.ucmp = function(d) {
      if (this.length > d.length)
        return 1;
      if (this.length < d.length)
        return -1;
      for (var h = 0, g = this.length - 1; g >= 0; g--) {
        var E = this.words[g] | 0, w = d.words[g] | 0;
        if (E !== w) {
          E < w ? h = -1 : E > w && (h = 1);
          break;
        }
      }
      return h;
    }, s.prototype.gtn = function(d) {
      return this.cmpn(d) === 1;
    }, s.prototype.gt = function(d) {
      return this.cmp(d) === 1;
    }, s.prototype.gten = function(d) {
      return this.cmpn(d) >= 0;
    }, s.prototype.gte = function(d) {
      return this.cmp(d) >= 0;
    }, s.prototype.ltn = function(d) {
      return this.cmpn(d) === -1;
    }, s.prototype.lt = function(d) {
      return this.cmp(d) === -1;
    }, s.prototype.lten = function(d) {
      return this.cmpn(d) <= 0;
    }, s.prototype.lte = function(d) {
      return this.cmp(d) <= 0;
    }, s.prototype.eqn = function(d) {
      return this.cmpn(d) === 0;
    }, s.prototype.eq = function(d) {
      return this.cmp(d) === 0;
    }, s.red = function(d) {
      return new O(d);
    }, s.prototype.toRed = function(d) {
      return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), d.convertTo(this)._forceRed(d);
    }, s.prototype.fromRed = function() {
      return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, s.prototype._forceRed = function(d) {
      return this.red = d, this;
    }, s.prototype.forceRed = function(d) {
      return r(!this.red, "Already a number in reduction context"), this._forceRed(d);
    }, s.prototype.redAdd = function(d) {
      return r(this.red, "redAdd works only with red numbers"), this.red.add(this, d);
    }, s.prototype.redIAdd = function(d) {
      return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, d);
    }, s.prototype.redSub = function(d) {
      return r(this.red, "redSub works only with red numbers"), this.red.sub(this, d);
    }, s.prototype.redISub = function(d) {
      return r(this.red, "redISub works only with red numbers"), this.red.isub(this, d);
    }, s.prototype.redShl = function(d) {
      return r(this.red, "redShl works only with red numbers"), this.red.shl(this, d);
    }, s.prototype.redMul = function(d) {
      return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, d), this.red.mul(this, d);
    }, s.prototype.redIMul = function(d) {
      return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, d), this.red.imul(this, d);
    }, s.prototype.redSqr = function() {
      return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, s.prototype.redISqr = function() {
      return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, s.prototype.redSqrt = function() {
      return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, s.prototype.redInvm = function() {
      return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, s.prototype.redNeg = function() {
      return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, s.prototype.redPow = function(d) {
      return r(this.red && !d.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, d);
    };
    var L = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function V(P, d) {
      this.name = P, this.p = new s(d, 16), this.n = this.p.bitLength(), this.k = new s(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    V.prototype._tmp = function() {
      var d = new s(null);
      return d.words = new Array(Math.ceil(this.n / 13)), d;
    }, V.prototype.ireduce = function(d) {
      var h = d, g;
      do
        this.split(h, this.tmp), h = this.imulK(h), h = h.iadd(this.tmp), g = h.bitLength();
      while (g > this.n);
      var E = g < this.n ? -1 : h.ucmp(this.p);
      return E === 0 ? (h.words[0] = 0, h.length = 1) : E > 0 ? h.isub(this.p) : h.strip !== void 0 ? h.strip() : h._strip(), h;
    }, V.prototype.split = function(d, h) {
      d.iushrn(this.n, 0, h);
    }, V.prototype.imulK = function(d) {
      return d.imul(this.k);
    };
    function F() {
      V.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    i(F, V), F.prototype.split = function(d, h) {
      for (var g = 4194303, E = Math.min(d.length, 9), w = 0; w < E; w++)
        h.words[w] = d.words[w];
      if (h.length = E, d.length <= 9) {
        d.words[0] = 0, d.length = 1;
        return;
      }
      var x = d.words[9];
      for (h.words[h.length++] = x & g, w = 10; w < d.length; w++) {
        var T = d.words[w] | 0;
        d.words[w - 10] = (T & g) << 4 | x >>> 22, x = T;
      }
      x >>>= 22, d.words[w - 10] = x, x === 0 && d.length > 10 ? d.length -= 10 : d.length -= 9;
    }, F.prototype.imulK = function(d) {
      d.words[d.length] = 0, d.words[d.length + 1] = 0, d.length += 2;
      for (var h = 0, g = 0; g < d.length; g++) {
        var E = d.words[g] | 0;
        h += E * 977, d.words[g] = h & 67108863, h = E * 64 + (h / 67108864 | 0);
      }
      return d.words[d.length - 1] === 0 && (d.length--, d.words[d.length - 1] === 0 && d.length--), d;
    };
    function U() {
      V.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    i(U, V);
    function Y() {
      V.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    i(Y, V);
    function Q() {
      V.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    i(Q, V), Q.prototype.imulK = function(d) {
      for (var h = 0, g = 0; g < d.length; g++) {
        var E = (d.words[g] | 0) * 19 + h, w = E & 67108863;
        E >>>= 26, d.words[g] = w, h = E;
      }
      return h !== 0 && (d.words[d.length++] = h), d;
    }, s._prime = function(d) {
      if (L[d])
        return L[d];
      var h;
      if (d === "k256")
        h = new F();
      else if (d === "p224")
        h = new U();
      else if (d === "p192")
        h = new Y();
      else if (d === "p25519")
        h = new Q();
      else
        throw new Error("Unknown prime " + d);
      return L[d] = h, h;
    };
    function O(P) {
      if (typeof P == "string") {
        var d = s._prime(P);
        this.m = d.p, this.prime = d;
      } else
        r(P.gtn(1), "modulus must be greater than 1"), this.m = P, this.prime = null;
    }
    O.prototype._verify1 = function(d) {
      r(d.negative === 0, "red works only with positives"), r(d.red, "red works only with red numbers");
    }, O.prototype._verify2 = function(d, h) {
      r((d.negative | h.negative) === 0, "red works only with positives"), r(
        d.red && d.red === h.red,
        "red works only with red numbers"
      );
    }, O.prototype.imod = function(d) {
      return this.prime ? this.prime.ireduce(d)._forceRed(this) : (u(d, d.umod(this.m)._forceRed(this)), d);
    }, O.prototype.neg = function(d) {
      return d.isZero() ? d.clone() : this.m.sub(d)._forceRed(this);
    }, O.prototype.add = function(d, h) {
      this._verify2(d, h);
      var g = d.add(h);
      return g.cmp(this.m) >= 0 && g.isub(this.m), g._forceRed(this);
    }, O.prototype.iadd = function(d, h) {
      this._verify2(d, h);
      var g = d.iadd(h);
      return g.cmp(this.m) >= 0 && g.isub(this.m), g;
    }, O.prototype.sub = function(d, h) {
      this._verify2(d, h);
      var g = d.sub(h);
      return g.cmpn(0) < 0 && g.iadd(this.m), g._forceRed(this);
    }, O.prototype.isub = function(d, h) {
      this._verify2(d, h);
      var g = d.isub(h);
      return g.cmpn(0) < 0 && g.iadd(this.m), g;
    }, O.prototype.shl = function(d, h) {
      return this._verify1(d), this.imod(d.ushln(h));
    }, O.prototype.imul = function(d, h) {
      return this._verify2(d, h), this.imod(d.imul(h));
    }, O.prototype.mul = function(d, h) {
      return this._verify2(d, h), this.imod(d.mul(h));
    }, O.prototype.isqr = function(d) {
      return this.imul(d, d.clone());
    }, O.prototype.sqr = function(d) {
      return this.mul(d, d);
    }, O.prototype.sqrt = function(d) {
      if (d.isZero())
        return d.clone();
      var h = this.m.andln(3);
      if (r(h % 2 === 1), h === 3) {
        var g = this.m.add(new s(1)).iushrn(2);
        return this.pow(d, g);
      }
      for (var E = this.m.subn(1), w = 0; !E.isZero() && E.andln(1) === 0; )
        w++, E.iushrn(1);
      r(!E.isZero());
      var x = new s(1).toRed(this), T = x.redNeg(), S = this.m.subn(1).iushrn(1), p = this.m.bitLength();
      for (p = new s(2 * p * p).toRed(this); this.pow(p, S).cmp(T) !== 0; )
        p.redIAdd(T);
      for (var k = this.pow(p, E), q = this.pow(d, E.addn(1).iushrn(1)), X = this.pow(d, E), W = w; X.cmp(x) !== 0; ) {
        for (var se = X, ce = 0; se.cmp(x) !== 0; ce++)
          se = se.redSqr();
        r(ce < W);
        var le = this.pow(k, new s(1).iushln(W - ce - 1));
        q = q.redMul(le), k = le.redSqr(), X = X.redMul(k), W = ce;
      }
      return q;
    }, O.prototype.invm = function(d) {
      var h = d._invmp(this.m);
      return h.negative !== 0 ? (h.negative = 0, this.imod(h).redNeg()) : this.imod(h);
    }, O.prototype.pow = function(d, h) {
      if (h.isZero())
        return new s(1).toRed(this);
      if (h.cmpn(1) === 0)
        return d.clone();
      var g = 4, E = new Array(1 << g);
      E[0] = new s(1).toRed(this), E[1] = d;
      for (var w = 2; w < E.length; w++)
        E[w] = this.mul(E[w - 1], d);
      var x = E[0], T = 0, S = 0, p = h.bitLength() % 26;
      for (p === 0 && (p = 26), w = h.length - 1; w >= 0; w--) {
        for (var k = h.words[w], q = p - 1; q >= 0; q--) {
          var X = k >> q & 1;
          if (x !== E[0] && (x = this.sqr(x)), X === 0 && T === 0) {
            S = 0;
            continue;
          }
          T <<= 1, T |= X, S++, !(S !== g && (w !== 0 || q !== 0)) && (x = this.mul(x, E[T]), S = 0, T = 0);
        }
        p = 26;
      }
      return x;
    }, O.prototype.convertTo = function(d) {
      var h = d.umod(this.m);
      return h === d ? h.clone() : h;
    }, O.prototype.convertFrom = function(d) {
      var h = d.clone();
      return h.red = null, h;
    }, s.mont = function(d) {
      return new B(d);
    };
    function B(P) {
      O.call(this, P), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new s(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    i(B, O), B.prototype.convertTo = function(d) {
      return this.imod(d.ushln(this.shift));
    }, B.prototype.convertFrom = function(d) {
      var h = this.imod(d.mul(this.rinv));
      return h.red = null, h;
    }, B.prototype.imul = function(d, h) {
      if (d.isZero() || h.isZero())
        return d.words[0] = 0, d.length = 1, d;
      var g = d.imul(h), E = g.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), w = g.isub(E).iushrn(this.shift), x = w;
      return w.cmp(this.m) >= 0 ? x = w.isub(this.m) : w.cmpn(0) < 0 && (x = w.iadd(this.m)), x._forceRed(this);
    }, B.prototype.mul = function(d, h) {
      if (d.isZero() || h.isZero())
        return new s(0)._forceRed(this);
      var g = d.mul(h), E = g.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), w = g.isub(E).iushrn(this.shift), x = w;
      return w.cmp(this.m) >= 0 ? x = w.isub(this.m) : w.cmpn(0) < 0 && (x = w.iadd(this.m)), x._forceRed(this);
    }, B.prototype.invm = function(d) {
      var h = this.imod(d._invmp(this.m).mul(this.r2));
      return h._forceRed(this);
    };
  })(n, Ie);
})(iu);
var su = iu.exports;
const Z = /* @__PURE__ */ nu(su);
function Yt(n) {
  return Z.isBN(n);
}
const Bm = /^0x[\da-fA-F]+$/, A1 = /^[\da-fA-F]+$/;
function ye(n, e = -1, t) {
  return typeof n == "string" && (n === "0x" || Bm.test(n)) && (e === -1 ? t || n.length % 2 === 0 : n.length === 2 + Math.ceil(e / 4));
}
function qt(n) {
  return !!n && typeof n == "object";
}
function au(...n) {
  return (e) => (qt(e) || ue(e)) && n.every((t) => ue(e[t]));
}
function P1(...n) {
  return (e) => ue(e) && n.every((t) => ue(e[t]));
}
function oo(...n) {
  return (e) => qt(e) && n.every((t) => ue(e[t]));
}
const ou = /* @__PURE__ */ au("toBigInt"), cu = /* @__PURE__ */ au("toBn");
function lu(n) {
  return typeof n == "bigint" ? n : n ? ye(n) ? Vm(n.toString()) : Yt(n) ? he(n.toString()) : ou(n) ? n.toBigInt() : cu(n) ? he(n.toBn().toString()) : he(n) : he(0);
}
function k1(n) {
  const e = lu(n);
  if (e < ii)
    throw new Error("square root of negative numbers is not supported");
  if (e <= Lm)
    return he(~~Math.sqrt(Number(e)));
  let t = Dm;
  for (; ; ) {
    const r = e / t + t >> Br;
    if (t === r || t === r - Br)
      return t;
    t = r;
  }
}
function Hm(n) {
  throw new Error('Could not dynamically require "' + n + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
const Rt = typeof he == "function" && typeof he.asIntN == "function", Fm = typeof Hm == "function" && typeof module < "u", T1 = typeof __dirname < "u", N1 = !Fm, R1 = typeof WebAssembly < "u", uu = typeof On.Buffer == "function" && typeof On.Buffer.isBuffer == "function", I1 = typeof On.process == "object";
function du(n) {
  return uu && !!n && ue(n.readDoubleLE) && On.Buffer.isBuffer(n);
}
function te(n) {
  return (n && n.constructor) === Uint8Array || n instanceof Uint8Array;
}
const O1 = new Jv();
function Ze(n) {
  return n ? O1.encode(n.toString()) : new Uint8Array();
}
function j(n) {
  return te(n) ? du(n) ? new Uint8Array(n) : n : ye(n) ? Mt(n) : Array.isArray(n) ? new Uint8Array(n) : Ze(n);
}
function jm(n, e) {
  const t = j(n), r = j(e);
  let i = 0;
  for (; ; ) {
    const s = i >= t.length, a = i >= r.length;
    if (s && a)
      return 0;
    if (s)
      return -1;
    if (a)
      return 1;
    if (t[i] !== r[i])
      return t[i] > r[i] ? 1 : -1;
    i++;
  }
}
function Me(...n) {
  const e = n.length, t = new Array(e);
  let r = 0;
  for (let i = 0; i < e; i++)
    t[i] = j(n[i]), r += t[i].length;
  return Wt(t, r);
}
function Wt(n, e = 0) {
  const t = n.length;
  let r = 0;
  if (!e)
    for (let s = 0; s < t; s++)
      e += n[s].length;
  const i = new Uint8Array(e);
  for (let s = 0; s < t; s++)
    i.set(n[s], r), r += n[s].length;
  return i;
}
function fu(n) {
  const e = n.length | 0;
  for (let t = 0; t < e; t++)
    if (n[t] | 0)
      return !1;
  return !0;
}
function jt(n, e) {
  const t = j(n), r = j(e);
  if (t.length === r.length) {
    const i = new DataView(t.buffer, t.byteOffset), s = new DataView(r.buffer, r.byteOffset), a = t.length % 4 | 0, o = t.length - a | 0;
    for (let c = 0; c < o; c += 4)
      if (i.getUint32(c) !== s.getUint32(c))
        return !1;
    for (let c = o, l = t.length; c < l; c++)
      if (t[c] !== r[c])
        return !1;
    return !0;
  }
  return !1;
}
function Wm(n, e = -1, t = !1) {
  const r = Math.ceil(e / 8);
  if (e === -1 || n.length === r)
    return n;
  if (n.length > r)
    return n.subarray(0, r);
  const i = new Uint8Array(r);
  return i.set(n, t ? 0 : r - n.length), i;
}
function M1(n) {
  return n.sort(jm);
}
function fn(n, { isLe: e = !0, isNegative: t = !1 } = {}) {
  e || (n = n.slice().reverse());
  const r = n.length;
  if (t && r && n[r - 1] & 128)
    switch (r) {
      case 0:
        return new Z(0);
      case 1:
        return new Z((n[0] ^ 255) * -1 - 1);
      case 2:
        return new Z((n[0] + (n[1] << 8) ^ 65535) * -1 - 1);
      case 3:
        return new Z((n[0] + (n[1] << 8) + (n[2] << 16) ^ 16777215) * -1 - 1);
      case 4:
        return new Z((n[0] + (n[1] << 8) + (n[2] << 16) + n[3] * 16777216 ^ 4294967295) * -1 - 1);
      case 5:
        return new Z(((n[0] + (n[1] << 8) + (n[2] << 16) + n[3] * 16777216 ^ 4294967295) + (n[4] ^ 255) * 4294967296) * -1 - 1);
      case 6:
        return new Z(((n[0] + (n[1] << 8) + (n[2] << 16) + n[3] * 16777216 ^ 4294967295) + (n[4] + (n[5] << 8) ^ 65535) * 4294967296) * -1 - 1);
      default:
        return new Z(n, "le").fromTwos(r * 8);
    }
  switch (r) {
    case 0:
      return new Z(0);
    case 1:
      return new Z(n[0]);
    case 2:
      return new Z(n[0] + (n[1] << 8));
    case 3:
      return new Z(n[0] + (n[1] << 8) + (n[2] << 16));
    case 4:
      return new Z(n[0] + (n[1] << 8) + (n[2] << 16) + n[3] * 16777216);
    case 5:
      return new Z(n[0] + (n[1] << 8) + (n[2] << 16) + (n[3] + (n[4] << 8)) * 16777216);
    case 6:
      return new Z(n[0] + (n[1] << 8) + (n[2] << 16) + (n[3] + (n[4] << 8) + (n[5] << 16)) * 16777216);
    default:
      return new Z(n, "le");
  }
}
function L1(n) {
  return uu ? On.Buffer.from(n || []) : new Uint8Array(n || []);
}
function qm(n, { bitLength: e = 32, isLe: t = !0 } = {}) {
  if (e !== 32 && e !== 64)
    throw new Error("Invalid bitLength provided, expected 32 or 64");
  if (n.length < e / 8)
    throw new Error(`Invalid input buffer provided, expected at least ${e / 8} bytes, found ${n.length}`);
  const r = new DataView(n.buffer, n.byteOffset);
  return e === 32 ? r.getFloat32(0, t) : r.getFloat64(0, t);
}
const Ra = new Array(256), zm = new Array(256 * 256);
for (let n = 0; n < 256; n++)
  Ra[n] = n.toString(16).padStart(2, "0");
for (let n = 0; n < 256; n++) {
  const e = n << 8;
  for (let t = 0; t < 256; t++)
    zm[e | t] = Ra[n] + Ra[t];
}
function rc(n, e) {
  const t = n.length % 2 | 0, r = n.length - t | 0;
  for (let i = 0; i < r; i += 2)
    e += zm[n[i] << 8 | n[i + 1]];
  return t && (e += Ra[n[r] | 0]), e;
}
function pe(n, e = -1, t = !0) {
  const r = t ? "0x" : "";
  if (n != null && n.length) {
    if (e > 0) {
      const i = Math.ceil(e / 8);
      if (n.length > i)
        return `${rc(n.subarray(0, i / 2), r)}${rc(n.subarray(n.length - i / 2), "")}`;
    }
  } else
    return r;
  return rc(n, r);
}
function Xm(n, { isLe: e = !0, isNegative: t = !1 } = {}) {
  e || (n = n.slice().reverse());
  const r = n.length;
  if (t && r && n[r - 1] & 128)
    switch (r) {
      case 0:
        return 0;
      case 1:
        return (n[0] ^ 255) * -1 - 1;
      case 2:
        return (n[0] + (n[1] << 8) ^ 65535) * -1 - 1;
      case 3:
        return (n[0] + (n[1] << 8) + (n[2] << 16) ^ 16777215) * -1 - 1;
      case 4:
        return (n[0] + (n[1] << 8) + (n[2] << 16) + n[3] * 16777216 ^ 4294967295) * -1 - 1;
      case 5:
        return ((n[0] + (n[1] << 8) + (n[2] << 16) + n[3] * 16777216 ^ 4294967295) + (n[4] ^ 255) * 4294967296) * -1 - 1;
      case 6:
        return ((n[0] + (n[1] << 8) + (n[2] << 16) + n[3] * 16777216 ^ 4294967295) + (n[4] + (n[5] << 8) ^ 65535) * 4294967296) * -1 - 1;
      default:
        throw new Error("Value more than 48-bits cannot be reliably converted");
    }
  switch (r) {
    case 0:
      return 0;
    case 1:
      return n[0];
    case 2:
      return n[0] + (n[1] << 8);
    case 3:
      return n[0] + (n[1] << 8) + (n[2] << 16);
    case 4:
      return n[0] + (n[1] << 8) + (n[2] << 16) + n[3] * 16777216;
    case 5:
      return n[0] + (n[1] << 8) + (n[2] << 16) + (n[3] + (n[4] << 8)) * 16777216;
    case 6:
      return n[0] + (n[1] << 8) + (n[2] << 16) + (n[3] + (n[4] << 8) + (n[5] << 16)) * 16777216;
    default:
      throw new Error("Value more than 48-bits cannot be reliably converted");
  }
}
const D1 = new qv("utf-8");
function Nn(n) {
  return n ? D1.decode(n) : "";
}
const ga = /* @__PURE__ */ j(`Ethereum Signed Message:
`), ki = /* @__PURE__ */ j("<Bytes>"), Ti = /* @__PURE__ */ j("</Bytes>"), U1 = ki.length + Ti.length;
function vs(n, e) {
  return n.length >= U1 && jt(n.subarray(0, ki.length), ki) && jt(n.slice(-Ti.length), Ti) || e && n.length >= ga.length && jt(n.subarray(0, ga.length), ga);
}
function Gm(n) {
  const e = j(n);
  return vs(e, !1) ? e.subarray(ki.length, e.length - Ti.length) : e;
}
function Zm(n) {
  const e = j(n);
  return vs(e, !0) ? e : Wt([ki, e, Ti]);
}
const jd = he(256), V1 = he(255);
function B1(n, e, t) {
  const r = [], i = t && n < ii;
  for (i && (n = (n + Br) * -Br); n !== ii; ) {
    const s = n % jd, a = Number(i ? s ^ V1 : s);
    e ? r.push(a) : r.unshift(a), n = (n - s) / jd;
  }
  return Uint8Array.from(r);
}
function hu(n, { bitLength: e = -1, isLe: t = !0, isNegative: r = !1 } = {}) {
  const i = lu(n);
  if (i === ii)
    return e === -1 ? new Uint8Array(1) : new Uint8Array(Math.ceil((e || 0) / 8));
  const s = B1(i, t, r);
  if (e === -1)
    return s;
  const a = Math.ceil((e || 0) / 8), o = new Uint8Array(a);
  return r && o.fill(255), o.set(s, t ? 0 : a - s.length), o;
}
function H1(n, { bitLength: e = -1, isLe: t = !1, isNegative: r = !1 } = {}) {
  return pe(hu(n || 0, { bitLength: e, isLe: t, isNegative: r }));
}
function ps(n) {
  if (!n || n === "0x")
    return "";
  if (Bm.test(n))
    return n.substring(2);
  if (A1.test(n))
    return n;
  throw new Error(`Expected hex value to convert, found '${n}'`);
}
function Ni(n, { isLe: e = !1, isNegative: t = !1 } = {}) {
  if (!n || n === "0x")
    return new Z(0);
  const r = ps(n), i = new Z(r, 16, e ? "le" : "be");
  return t ? i.fromTwos(r.length * 4) : i;
}
const pu = /* @__PURE__ */ ao((n, e) => n.gt(e)), Jm = /* @__PURE__ */ ao((n, e) => n.lt(e)), At = /* @__PURE__ */ new Z(0), _r = /* @__PURE__ */ new Z(1), Us = /* @__PURE__ */ new Z(2), F1 = /* @__PURE__ */ new Z(3), j1 = /* @__PURE__ */ new Z(4), W1 = /* @__PURE__ */ new Z(5), q1 = /* @__PURE__ */ new Z(6), z1 = /* @__PURE__ */ new Z(7), X1 = /* @__PURE__ */ new Z(8), G1 = /* @__PURE__ */ new Z(9), el = /* @__PURE__ */ new Z(10), mu = /* @__PURE__ */ new Z(100), Z1 = /* @__PURE__ */ new Z(1e3), $r = /* @__PURE__ */ new Z(1e6), Ia = /* @__PURE__ */ new Z(1e9), Km = Ia.mul(Ia), Ym = /* @__PURE__ */ new Z(Number.MAX_SAFE_INTEGER), Qm = /* @__PURE__ */ new Z(94906265);
function vr(n) {
  return typeof n == "bigint";
}
function Tt(n) {
  return n ? Z.isBN(n) ? n : ye(n) ? Ni(n.toString()) : vr(n) ? new Z(n.toString()) : cu(n) ? n.toBn() : ou(n) ? new Z(n.toBigInt().toString()) : new Z(n) : new Z(0);
}
function J1(n) {
  const e = Tt(n);
  if (e.isNeg())
    throw new Error("square root of negative numbers is not supported");
  if (e.lte(Ym))
    return new Z(~~Math.sqrt(e.toNumber()));
  let t = Qm.clone();
  for (; ; ) {
    const r = e.div(t).iadd(t).ishrn(1);
    if (t.eq(r) || t.eq(r.sub(_r)))
      return t;
    t = r;
  }
}
const K1 = { bitLength: -1, isLe: !0, isNegative: !1 };
function Lt(n, { bitLength: e = -1, isLe: t = !0, isNegative: r = !1 } = K1) {
  const i = Tt(n), s = Math.ceil(e === -1 ? i.bitLength() / 8 : (e || 0) / 8);
  if (!n)
    return e === -1 ? new Uint8Array(1) : new Uint8Array(s);
  const a = new Uint8Array(s), o = r ? i.toTwos(s * 8) : i;
  return a.set(o.toArray(t ? "le" : "be", s), 0), a;
}
function $m(n, { bitLength: e = -1, isLe: t = !1, isNegative: r = !1 } = {}) {
  return pe(Lt(n, { bitLength: e, isLe: t, isNegative: r }));
}
function Y1(n) {
  return new Uint8Array(n || []);
}
const Q1 = Us.pow(new Z(8 - 2)).isub(_r), $1 = Us.pow(new Z(16 - 2)).isub(_r), eb = Us.pow(new Z(32 - 2)).isub(_r), tb = { bitLength: 16 }, nb = { bitLength: 32 };
function nt(n) {
  const e = Tt(n);
  if (e.lte(Q1))
    return new Uint8Array([e.toNumber() << 2]);
  if (e.lte($1))
    return Lt(e.shln(2).iadd(_r), tb);
  if (e.lte(eb))
    return Lt(e.shln(2).iadd(Us), nb);
  const t = Lt(e);
  let r = t.length;
  for (; t[r - 1] === 0; )
    r--;
  if (r < 4)
    throw new Error("Invalid length, previous checks match anything less than 2^30");
  return Wt([
    // subtract 4 as minimum (also catered for in decoding)
    new Uint8Array([(r - 4 << 2) + 3]),
    t.subarray(0, r)
  ]);
}
function wn(n) {
  return Wt([
    nt(n.length),
    n
  ]);
}
function co(n) {
  const e = j(n);
  switch (e[0] & 3) {
    case 0:
      return [1, new Z(e[0] >>> 2)];
    case 1:
      return [2, new Z(e[0] + (e[1] << 8) >>> 2)];
    case 2:
      return [4, new Z(e[0] + (e[1] << 8) + (e[2] << 16) + e[3] * 16777216 >>> 2)];
    default: {
      const t = (e[0] >>> 2) + 5;
      switch (t) {
        case 5:
          return [5, new Z(e[1] + (e[2] << 8) + (e[3] << 16) + e[4] * 16777216)];
        case 6:
          return [6, new Z(e[1] + (e[2] << 8) + (e[3] << 16) + (e[4] + (e[5] << 8)) * 16777216)];
        case 7:
          return [7, new Z(e[1] + (e[2] << 8) + (e[3] << 16) + (e[4] + (e[5] << 8) + (e[6] << 16)) * 16777216)];
        default:
          return [t, fn(e.subarray(1, t))];
      }
    }
  }
}
function qr(n) {
  switch (n[0] & 3) {
    case 0:
      return [1, n[0] >>> 2];
    case 1:
      return [2, n[0] + (n[1] << 8) >>> 2];
    case 2:
      return [4, n[0] + (n[1] << 8) + (n[2] << 16) + n[3] * 16777216 >>> 2];
    default:
      switch ((n[0] >>> 2) + 5) {
        case 5:
          return [5, n[1] + (n[2] << 8) + (n[3] << 16) + n[4] * 16777216];
        case 6:
          return [6, n[1] + (n[2] << 8) + (n[3] << 16) + (n[4] + (n[5] << 8)) * 16777216];
        case 7:
          return [7, n[1] + (n[2] << 8) + (n[3] << 16) + (n[4] + (n[5] << 8) + (n[6] << 16)) * 16777216];
        default:
          throw new Error("Compact input is > Number.MAX_SAFE_INTEGER");
      }
  }
}
function Ri(n) {
  const [e, t] = co(n), r = e + t.toNumber();
  return [
    r,
    n.subarray(e, r)
  ];
}
const eg = 60 * 1e3, tg = eg * 60, rb = tg * 24, Wd = { days: 0, hours: 0, milliseconds: 0, minutes: 0, seconds: 0 };
function ls(n, e) {
  return {
    days: (n.days || 0) + e.days,
    hours: (n.hours || 0) + e.hours,
    milliseconds: (n.milliseconds || 0) + e.milliseconds,
    minutes: (n.minutes || 0) + e.minutes,
    seconds: (n.seconds || 0) + e.seconds
  };
}
function ib(n) {
  const e = n / 1e3;
  if (e < 60) {
    const s = ~~e;
    return ls({ seconds: s }, us(n - s * 1e3));
  }
  const t = e / 60;
  if (t < 60) {
    const s = ~~t;
    return ls({ minutes: s }, us(n - s * eg));
  }
  const r = t / 60;
  if (r < 24) {
    const s = ~~r;
    return ls({ hours: s }, us(n - s * tg));
  }
  const i = ~~(r / 24);
  return ls({ days: i }, us(n - i * rb));
}
function us(n) {
  return n ? n < 1e3 ? ls({ milliseconds: n }, Wd) : ib(n) : Wd;
}
function ng(n = 0, { bitLength: e = 32, isLe: t = !0 } = {}) {
  if (e !== 32 && e !== 64)
    throw new Error("Invalid bitLength provided, expected 32 or 64");
  const r = new Uint8Array(e / 8), i = new DataView(r.buffer, r.byteOffset);
  return e === 32 ? i.setFloat32(0, Number(n), t) : i.setFloat64(0, Number(n), t), r;
}
function bs(n) {
  return typeof n == "boolean";
}
const qd = new RegExp("(\\d+?)(?=(\\d{3})+(?!\\d)|$)", "g");
function gu(n, e = ",") {
  const t = n[0].startsWith("-"), r = t ? n.substring(1).match(qd) : n.match(qd);
  return r ? `${t ? "-" : ""}${r.join(e)}` : n;
}
function rg(n) {
  return {
    decimal: 0.1.toLocaleString(n).substring(1, 2),
    thousand: 1e3.toLocaleString(n).substring(1, 2)
  };
}
const Vs = 8, Tn = [
  { power: -24, text: "yocto", value: "y" },
  { power: -21, text: "zepto", value: "z" },
  { power: -18, text: "atto", value: "a" },
  { power: -15, text: "femto", value: "f" },
  { power: -12, text: "pico", value: "p" },
  { power: -9, text: "nano", value: "n" },
  { power: -6, text: "micro", value: "" },
  { power: -3, text: "milli", value: "m" },
  { power: 0, text: "Unit", value: "-" },
  { power: 3, text: "Kilo", value: "k" },
  { power: 6, text: "Mill", value: "M" },
  { power: 9, text: "Bill", value: "B" },
  { power: 12, text: "Tril", value: "T" },
  { power: 15, text: "Peta", value: "P" },
  { power: 18, text: "Exa", value: "E" },
  { power: 21, text: "Zeta", value: "Z" },
  { power: 24, text: "Yotta", value: "Y" }
];
function yu(n) {
  for (let e = 0, t = Tn.length; e < t; e++)
    if (Tn[e].value === n)
      return Tn[e];
  return Tn[Vs];
}
function _u(n, e, t) {
  if (t)
    return yu(t);
  const r = Vs - 1 + Math.ceil((n.length - e) / 3);
  return Tn[r] || Tn[r < 0 ? 0 : Tn.length - 1];
}
const sb = 0, ab = Tn[Vs].text;
let Ii = sb, ya = ab;
function ob(n, { decimals: e = Ii, forceUnit: t, locale: r = "en", withAll: i = !1, withSi: s = !0, withSiFull: a = !1, withUnit: o = !0, withZero: c = !0 } = {}) {
  let l = Tt(n).toString();
  if (l.length === 0 || l === "0")
    return "0";
  let u = "";
  l[0].startsWith("-") && (u = "-", l = l.substring(1));
  const f = _u(l, e, t), m = l.length - (e + f.power), y = m <= 0 ? "0" : l.substring(0, m);
  let _ = l.padStart(m < 0 ? e : 1, "0").substring(m < 0 ? 0 : m).padEnd(i ? Math.max(e, 4) : 4, "0").substring(0, i ? Math.max(4, e + f.power) : 4);
  if (!c) {
    let I = _.length - 1;
    do
      _[I] === "0" && I--;
    while (_[I] === "0");
    _ = _.substring(0, I + 1);
  }
  const v = bs(o) ? Tn[Vs].text : o, C = s || a ? f.value === "-" ? o ? ` ${v}` : "" : ` ${a ? `${f.text}${o ? " " : ""}` : f.value}${o ? v : ""}` : "", { decimal: A, thousand: R } = rg(r);
  return `${u}${gu(y, R)}${_ && `${A}${_}`}${C}`;
}
const zr = ob;
zr.calcSi = (n, e = Ii) => _u(n, e);
zr.findSi = yu;
zr.getDefaults = () => ({
  decimals: Ii,
  unit: ya
});
zr.getOptions = (n = Ii) => Tn.filter(({ power: e }) => e < 0 ? n + e >= 0 : !0);
zr.setDefaults = ({ decimals: n, unit: e }) => {
  Ii = (Array.isArray(n) ? n[0] : n) ?? Ii, ya = (Array.isArray(e) ? e[0] : e) ?? ya, Tn[Vs].text = ya;
};
function Ki(n) {
  return n.toString().padStart(2, "0");
}
function ig(n) {
  const e = n.getFullYear().toString(), t = Ki(n.getMonth() + 1), r = Ki(n.getDate()), i = Ki(n.getHours()), s = Ki(n.getMinutes()), a = Ki(n.getSeconds());
  return `${e}-${t}-${r} ${i}:${s}:${a}`;
}
function cb(n) {
  return n < 15 ? `${n.toFixed(1)}s` : n < 60 ? `${n | 0}s` : n < 3600 ? `${n / 60 | 0}m` : `${n / 3600 | 0}h`;
}
function lb(n, e) {
  const t = (n == null ? void 0 : n.getTime()) || 0, r = e instanceof Date ? e.getTime() : Tt(e).toNumber();
  return t && r ? cb(Math.max(Math.abs(t - r), 0) / 1e3) : "0.0s";
}
function Oa(n, { locale: e = "en" } = {}) {
  const { thousand: t } = rg(e);
  return gu(Tt(n).toString(), t);
}
function sg(n) {
  return !!n && ye(n, -1);
}
function ag(n) {
  return n && sg(n) ? n : `0x${n && n.length % 2 === 1 ? "0" : ""}${n || ""}`;
}
function og(n, e = -1, t = !1) {
  const r = Math.ceil(e / 4), i = r + 2;
  return ag(e === -1 || n.length === i || !t && n.length < i ? ps(n) : n.length > i ? ps(n).slice(-1 * r) : `${"0".repeat(r)}${ps(n)}`.slice(-1 * r));
}
function cg(n) {
  return n ? Ni(n).toNumber() : NaN;
}
function lg(n) {
  return Nn(Mt(n));
}
function ub(n) {
  return Array.isArray(n);
}
function Pe(n) {
  return typeof n == "string" || n instanceof String;
}
function db(n) {
  for (let e = 0, t = n.length; e < t; e++) {
    const r = n.charCodeAt(e);
    if (r < 32 || r > 126)
      return !1;
  }
  return !0;
}
function zd(n) {
  for (let e = 0, t = n.length; e < t; e++) {
    const r = n[e] | 0;
    if (r < 32 || r > 126)
      return !1;
  }
  return !0;
}
function tl(n) {
  return Pe(n) ? ye(n) ? zd(j(n)) : db(n) : n ? zd(n) : !1;
}
const nl = /* @__PURE__ */ P1("isPrototypeOf", "hasOwnProperty");
function ug(n, e) {
  return nl(e) && nl(n) ? n === e || n.isPrototypeOf(e) : !1;
}
const fb = /* @__PURE__ */ oo("toHex", "toHuman", "toU8a"), hb = /* @__PURE__ */ oo("get");
function Jn(n) {
  return fb(n) && hb(n.registry);
}
const vu = /* @__PURE__ */ oo("toBigInt", "toBn", "toNumber", "unwrap");
function pb(n) {
  return (n && n.constructor) === Error || n instanceof Error;
}
function mb(n, e) {
  return (n && n.constructor) === e || n instanceof e;
}
const ir = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}", St = "[a-fA-F\\d]{1,4}", dg = `
(?:
(?:${St}:){7}(?:${St}|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:${St}:){6}(?:${ir}|:${St}|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:${St}:){5}(?::${ir}|(?::${St}){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:${St}:){4}(?:(?::${St}){0,1}:${ir}|(?::${St}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:${St}:){3}(?:(?::${St}){0,2}:${ir}|(?::${St}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:${St}:){2}(?:(?::${St}){0,3}:${ir}|(?::${St}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:${St}:){1}(?:(?::${St}){0,4}:${ir}|(?::${St}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::${St}){0,5}:${ir}|(?::${St}){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`.replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim(), gb = new RegExp(`(?:^${ir}$)|(?:^${dg}$)`), yb = new RegExp(`^${ir}$`), _b = new RegExp(`^${dg}$`);
function vb(n, e) {
  switch (e) {
    case "v4":
      return yb.test(n);
    case "v6":
      return _b.test(n);
    default:
      return gb.test(n);
  }
}
function bb(n, e) {
  return vr(e) ? e.toString() : e;
}
function _e(n, e) {
  return JSON.stringify(n, bb, e);
}
function wb(n) {
  const e = typeof n != "string" ? _e(n) : n;
  try {
    const t = JSON.parse(e);
    return typeof t == "object" && t !== null;
  } catch {
    return !1;
  }
}
function Mr(n) {
  return n === null;
}
function xe(n) {
  return typeof n == "number";
}
const xb = /* @__PURE__ */ au("next"), Sb = /* @__PURE__ */ oo("catch", "then"), Eb = new Uint8Array([127, 69, 76, 70]), Cb = new Uint8Array([80, 86, 77, 0]);
function Ab(n) {
  if (te(n)) {
    const e = n.subarray(0, 4);
    return jt(e, Cb) || jt(e, Eb);
  }
  return !1;
}
const Pb = /(Development|Local Testnet)$/;
function kb(n) {
  return n ? !!Pb.test(n.toString()) : !1;
}
function Ne(n) {
  return n === void 0;
}
function fg(n) {
  if (!n)
    return Pe(n);
  const e = j(n), t = e.length;
  let r = 0;
  for (; r < t; )
    if (e[r] <= 127)
      r += 1;
    else if (e[r] >= 194 && e[r] <= 223) {
      if (r + 1 < t) {
        if (e[r + 1] < 128 || e[r + 1] > 191)
          return !1;
      } else
        return !1;
      r += 2;
    } else if (e[r] === 224) {
      if (r + 2 < t) {
        if (e[r + 1] < 160 || e[r + 1] > 191 || e[r + 2] < 128 || e[r + 2] > 191)
          return !1;
      } else
        return !1;
      r += 3;
    } else if (e[r] >= 225 && e[r] <= 236) {
      if (r + 2 < t) {
        if (e[r + 1] < 128 || e[r + 1] > 191 || e[r + 2] < 128 || e[r + 2] > 191)
          return !1;
      } else
        return !1;
      r += 3;
    } else if (e[r] === 237) {
      if (r + 2 < t) {
        if (e[r + 1] < 128 || e[r + 1] > 159 || e[r + 2] < 128 || e[r + 2] > 191)
          return !1;
      } else
        return !1;
      r += 3;
    } else if (e[r] >= 238 && e[r] <= 239) {
      if (r + 2 < t) {
        if (e[r + 1] < 128 || e[r + 1] > 191 || e[r + 2] < 128 || e[r + 2] > 191)
          return !1;
      } else
        return !1;
      r += 3;
    } else if (e[r] === 240) {
      if (r + 3 < t) {
        if (e[r + 1] < 144 || e[r + 1] > 191 || e[r + 2] < 128 || e[r + 2] > 191 || e[r + 3] < 128 || e[r + 3] > 191)
          return !1;
      } else
        return !1;
      r += 4;
    } else if (e[r] >= 241 && e[r] <= 243) {
      if (r + 3 < t) {
        if (e[r + 1] < 128 || e[r + 1] > 191 || e[r + 2] < 128 || e[r + 2] > 191 || e[r + 3] < 128 || e[r + 3] > 191)
          return !1;
      } else
        return !1;
      r += 4;
    } else if (e[r] === 244) {
      if (r + 3 < t) {
        if (e[r + 1] < 128 || e[r + 1] > 143 || e[r + 2] < 128 || e[r + 2] > 191 || e[r + 3] < 128 || e[r + 3] > 191)
          return !1;
      } else
        return !1;
      r += 4;
    } else
      return !1;
  return !0;
}
const Tb = new Uint8Array([0, 97, 115, 109]);
function Nb(n) {
  return te(n) && jt(n.subarray(0, 4), Tb);
}
function Ut(n, e, t, r, i = 0) {
  const s = r ? r(e, i) : e.toString();
  let a;
  Object.defineProperty(n, s, {
    // This allows for re-configuration with the embedded defineProperty below
    // and ensures that on tested browsers and Node, it _will_ be redefined
    // and thus short-circuited for future access
    configurable: !0,
    enumerable: !0,
    // Use a function here, we don't want to capture the outer this, i.e.
    // don't use arrow functions in this context since we have a this inside
    get: function() {
      if (a === void 0) {
        a = t(e, i, this);
        try {
          Object.defineProperty(this, s, { value: a });
        } catch {
        }
      }
      return a;
    }
  });
}
function Lr(n, e, t, r) {
  for (let i = 0, s = e.length; i < s; i++)
    Ut(n, e[i], t, r, i);
  return n;
}
function Xr(n) {
  return n;
}
function Kn() {
}
const Rb = {
  debug: "log",
  error: "error",
  log: "log",
  warn: "warn"
};
function Ib(n) {
  if (n && qt(n) && n.constructor === Object) {
    const e = {};
    for (const [t, r] of Object.entries(n))
      e[t] = lo(r);
    return e;
  }
  return n;
}
function lo(n) {
  return Array.isArray(n) ? n.map(lo) : Yt(n) ? n.toString() : te(n) || du(n) ? pe(j(n)) : Ib(n);
}
function Ob(n) {
  return (e) => {
    if (n <= 0)
      return e;
    const t = `${e}`;
    return t.length < n ? e : `${t.substring(0, n)} ...`;
  };
}
function ds(n, e, t, r = -1) {
  if (t.length === 1 && ue(t[0])) {
    const i = t[0]();
    return ds(n, e, Array.isArray(i) ? i : [i], r);
  }
  console[Rb[n]](ig(/* @__PURE__ */ new Date()), e, ...t.map(lo).map(Ob(r)));
}
function Mb(n, e) {
  return !!n && (n === "*" || e === n || n.endsWith("*") && e.startsWith(n.slice(0, -1)));
}
function Lb(n, e) {
  return !!n && n.startsWith("-") && (e === n.slice(1) || n.endsWith("*") && e.startsWith(n.slice(1, -1)));
}
function Db(n, e) {
  let t = !1;
  for (const r of n)
    Mb(r, e) ? t = !0 : Lb(r, e) && (t = !1);
  return t;
}
function Ub(n) {
  var t, r, i, s;
  const e = parseInt(((r = (t = On.process) == null ? void 0 : t.env) == null ? void 0 : r.DEBUG_MAX) || "-1", 10);
  return [
    Db((((s = (i = On.process) == null ? void 0 : i.env) == null ? void 0 : s.DEBUG) || "").toLowerCase().split(","), n),
    isNaN(e) ? -1 : e
  ];
}
function Qt(n) {
  const e = `${n.toUpperCase()}:`.padStart(16), [t, r] = Ub(n.toLowerCase());
  return {
    debug: t ? (...i) => ds("debug", e, i, r) : Kn,
    error: (...i) => ds("error", e, i),
    log: (...i) => ds("log", e, i),
    noop: Kn,
    warn: (...i) => ds("warn", e, i)
  };
}
function Vb() {
  return "none";
}
function wi(n, { getInstanceId: e = Vb } = {}) {
  const t = {}, r = (...i) => {
    const s = _e(i), a = e();
    return t[a] || (t[a] = {}), t[a][s] === void 0 && (t[a][s] = n(...i)), t[a][s];
  };
  return r.unmemoize = (...i) => {
    var o;
    const s = _e(i), a = e();
    ((o = t[a]) == null ? void 0 : o[s]) !== void 0 && delete t[a][s];
  }, r;
}
function ws(n, e) {
  setTimeout(() => {
    Promise.resolve().then(() => {
      n();
    }).catch((t) => {
      e ? e(t) : console.error(t);
    });
  }, 0);
}
function hg(n, e = -1) {
  const t = (!n || Number.isNaN(n) ? 0 : n).toString(16);
  return og(t.length % 2 ? `0${t}` : t, e, !0);
}
function Bb(n, e = -1) {
  return Mt(hg(n, e));
}
function pg(n) {
  const e = Object.keys(n);
  for (let t = 0, r = e.length; t < r; t++)
    delete n[e[t]];
  return n;
}
function J(n, ...e) {
  for (let t = 0, r = e.length; t < r; t++) {
    const i = e[t];
    if (i)
      if (typeof i.entries == "function")
        for (const [s, a] of i.entries())
          n[s] = a;
      else
        Object.assign(n, i);
  }
  return n;
}
function Hb(n) {
  return J({}, n);
}
function Fb(n) {
  return Object.entries(n);
}
function jb(n) {
  return Object.keys(n);
}
function uo(n, e, t, r, i = 0) {
  const s = r ? r(e, i) : e;
  s in n || Object.defineProperty(n, s, {
    enumerable: !0,
    // Unlike in lazy, we always call into the upper function, i.e. this method
    // does not cache old values (it is expected to be used for dynamic values)
    get: function() {
      return t(e, i, this);
    }
  });
}
function Hr(n, e, t, r) {
  for (let i = 0, s = e.length; i < s; i++)
    uo(n, e[i], t, r, i);
}
function Wb(n) {
  return Object.values(n);
}
function qb(n, e, ...t) {
  return new Promise((r, i) => {
    e.apply(n, t.concat((s, a) => {
      s ? i(s) : r(a);
    }));
  });
}
const Oi = new Array(256), bu = new Array(256);
for (let n = 0, e = Oi.length; n < e; n++)
  bu[n] = String.fromCharCode(n).toLowerCase(), Oi[n] = String.fromCharCode(n).toUpperCase();
function zb(n) {
  return n.slice(0, n.length - 1).toLowerCase() + Oi[n.charCodeAt(n.length - 1)];
}
function mg(n) {
  return (e) => {
    const t = e.replace(/[-_., ]+/g, " ").trim().split(" ");
    let r = "";
    for (let i = 0, s = t.length; i < s; i++) {
      const a = t[i];
      r += n(/^[\dA-Z]+$/.test(a) ? a.toLowerCase() : a.replace(/^[\dA-Z]{2,}[^a-z]/, zb), i);
    }
    return r;
  };
}
const Ee = /* @__PURE__ */ mg((n, e) => (e ? Oi[n.charCodeAt(0)] : bu[n.charCodeAt(0)]) + n.slice(1)), fo = /* @__PURE__ */ mg((n) => Oi[n.charCodeAt(0)] + n.slice(1));
function gg(n) {
  return (e) => e ? n[e.charCodeAt(0)] + e.slice(1) : "";
}
const Xb = /* @__PURE__ */ gg(bu), yg = /* @__PURE__ */ gg(Oi);
function Gb(n, e = 6) {
  return n.length <= 2 + 2 * e ? n.toString() : `${n.substring(0, e)}${n.slice(-e)}`;
}
function wu(n) {
  return pe(Ze(n));
}
const Zb = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BN: Z,
  BN_BILLION: Ia,
  BN_EIGHT: X1,
  BN_FIVE: W1,
  BN_FOUR: j1,
  BN_HUNDRED: mu,
  BN_MAX_INTEGER: Ym,
  BN_MILLION: $r,
  BN_NINE: G1,
  BN_ONE: _r,
  BN_QUINTILL: Km,
  BN_SEVEN: z1,
  BN_SIX: q1,
  BN_SQRT_MAX_INTEGER: Qm,
  BN_TEN: el,
  BN_THOUSAND: Z1,
  BN_THREE: F1,
  BN_TWO: Us,
  BN_ZERO: At,
  POLKADOTJS_DISABLE_ESM_CJS_WARNING_FLAG: Im,
  U8A_WRAP_ETHEREUM: ga,
  U8A_WRAP_POSTFIX: Ti,
  U8A_WRAP_PREFIX: ki,
  _0n: ii,
  _1000n: v1,
  _100n: _1,
  _10n: y1,
  _1Bn: $c,
  _1Mn: b1,
  _1Qn: w1,
  _1n: Br,
  _2n: l1,
  _2pow53n: Lm,
  _3n: u1,
  _4n: d1,
  _5n: f1,
  _6n: h1,
  _7n: p1,
  _8n: m1,
  _9n: g1,
  _sqrt2pow53n: Dm,
  arrayChunk: Qc,
  arrayFilter: t1,
  arrayFlatten: ma,
  arrayRange: n1,
  arrayShuffle: r1,
  arrayUnzip: i1,
  arrayZip: s1,
  assert: Mm,
  assertReturn: zn,
  assertUnreachable: ru,
  bnFromHex: Ni,
  bnMax: pu,
  bnMin: Jm,
  bnSqrt: J1,
  bnToBn: Tt,
  bnToHex: $m,
  bnToU8a: Lt,
  bufferToU8a: Y1,
  calcSi: _u,
  compactAddLength: wn,
  compactFromU8a: co,
  compactFromU8aLim: qr,
  compactStripLength: Ri,
  compactToU8a: nt,
  detectPackage: Om,
  extractTime: us,
  findSi: yu,
  floatToU8a: ng,
  formatBalance: zr,
  formatDate: ig,
  formatDecimal: gu,
  formatElapsed: lb,
  formatNumber: Oa,
  hasBigInt: Rt,
  hasBuffer: uu,
  hasCjs: Fm,
  hasDirname: T1,
  hasEsm: N1,
  hasProcess: I1,
  hasWasm: R1,
  hexAddPrefix: ag,
  hexFixLength: og,
  hexHasPrefix: sg,
  hexStripPrefix: ps,
  hexToBigInt: Vm,
  hexToBn: Ni,
  hexToNumber: cg,
  hexToString: lg,
  hexToU8a: Mt,
  identity: Xr,
  isArray: ub,
  isAscii: tl,
  isBigInt: vr,
  isBn: Yt,
  isBoolean: bs,
  isBuffer: du,
  isChildClass: ug,
  isClass: nl,
  isCodec: Jn,
  isCompact: vu,
  isError: pb,
  isFunction: ue,
  isHex: ye,
  isInstanceOf: mb,
  isIp: vb,
  isJsonObject: wb,
  isNull: Mr,
  isNumber: xe,
  isObject: qt,
  isObservable: xb,
  isPromise: Sb,
  isRiscV: Ab,
  isString: Pe,
  isTestChain: kb,
  isToBigInt: ou,
  isToBn: cu,
  isU8a: te,
  isUndefined: Ne,
  isUtf8: fg,
  isWasm: Nb,
  lazyMethod: Ut,
  lazyMethods: Lr,
  logger: Qt,
  loggerFormat: lo,
  memoize: wi,
  nMax: a1,
  nMin: o1,
  nSqrt: k1,
  nToBigInt: lu,
  nToHex: H1,
  nToU8a: hu,
  nextTick: ws,
  noop: Kn,
  numberToHex: hg,
  numberToU8a: Bb,
  objectClear: pg,
  objectCopy: Hb,
  objectEntries: Fb,
  objectKeys: jb,
  objectProperties: Hr,
  objectProperty: uo,
  objectSpread: J,
  objectValues: Wb,
  packageInfo: Rm,
  promisify: qb,
  stringCamelCase: Ee,
  stringLowerFirst: Xb,
  stringPascalCase: fo,
  stringShorten: Gb,
  stringToHex: wu,
  stringToU8a: Ze,
  stringUpperFirst: yg,
  stringify: _e,
  u8aCmp: jm,
  u8aConcat: Me,
  u8aConcatStrict: Wt,
  u8aEmpty: fu,
  u8aEq: jt,
  u8aFixLength: Wm,
  u8aIsWrapped: vs,
  u8aSorted: M1,
  u8aToBigInt: Ta,
  u8aToBn: fn,
  u8aToBuffer: L1,
  u8aToFloat: qm,
  u8aToHex: pe,
  u8aToNumber: Xm,
  u8aToString: Nn,
  u8aToU8a: j,
  u8aUnwrapBytes: Gm,
  u8aWrapBytes: Zm
}, Symbol.toStringTag, { value: "Module" }));
class Mi extends Boolean {
  constructor(t, r = !1) {
    super(te(r) ? r[0] === 1 : r instanceof Boolean ? r.valueOf() : !!r);
    b(this, "registry");
    b(this, "createdAtHash");
    b(this, "initialU8aLength", 1);
    b(this, "isStorageFallback");
    this.registry = t;
  }
  /**
   * @description The length of the value when encoded as a Uint8Array
   */
  get encodedLength() {
    return 1;
  }
  /**
   * @description returns a hash of the contents
   */
  get hash() {
    return this.registry.hash(this.toU8a());
  }
  /**
   * @description Checks if the value is an empty value (true when it wraps false/default)
   */
  get isEmpty() {
    return this.isFalse;
  }
  /**
   * @description Checks if the value is an empty value (always false)
   */
  get isFalse() {
    return !this.isTrue;
  }
  /**
   * @description Checks if the value is an empty value (always false)
   */
  get isTrue() {
    return this.valueOf();
  }
  /**
   * @description Compares the value of the input to see if there is a match
   */
  eq(t) {
    return this.valueOf() === (t instanceof Boolean ? t.valueOf() : t);
  }
  /**
   * @description Returns a breakdown of the hex encoding for this Codec
   */
  inspect() {
    return {
      outer: [this.toU8a()]
    };
  }
  /**
   * @description Returns a hex string representation of the value
   */
  toHex() {
    return pe(this.toU8a());
  }
  /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */
  toHuman() {
    return this.toJSON();
  }
  /**
   * @description Converts the Object to JSON, typically used for RPC transfers
   */
  toJSON() {
    return this.valueOf();
  }
  /**
   * @description Converts the value in a best-fit primitive form
   */
  toPrimitive() {
    return this.toJSON();
  }
  /**
   * @description Returns the base runtime type name for this instance
   */
  toRawType() {
    return "bool";
  }
  /**
   * @description Returns the string representation of the value
   */
  toString() {
    return this.toJSON().toString();
  }
  /**
   * @description Encodes the value as a Uint8Array as per the SCALE specifications
   */
  toU8a(t) {
    return new Uint8Array([this.valueOf() ? 1 : 0]);
  }
}
class ho extends Number {
  constructor(t, r, { bitLength: i = 32 } = {}) {
    super(te(r) || ye(r) ? r.length === 0 ? 0 : qm(j(r), { bitLength: i }) : r || 0);
    b(this, "encodedLength");
    b(this, "registry");
    b(this, "createdAtHash");
    b(this, "initialU8aLength");
    b(this, "isStorageFallback");
    b(this, "__internal__bitLength");
    this.__internal__bitLength = i, this.encodedLength = i / 8, this.initialU8aLength = this.encodedLength, this.registry = t;
  }
  static with(t) {
    return class extends ho {
      constructor(r, i) {
        super(r, i, { bitLength: t });
      }
    };
  }
  /**
   * @description returns a hash of the contents
   */
  get hash() {
    return this.registry.hash(this.toU8a());
  }
  /**
   * @description Returns true if the type wraps an empty/default all-0 value
   */
  get isEmpty() {
    return this.valueOf() === 0;
  }
  /**
   * @description Compares the value of the input to see if there is a match
   */
  eq(t) {
    return this.valueOf() === Number(t);
  }
  /**
   * @description Returns a breakdown of the hex encoding for this Codec
   */
  inspect() {
    return {
      outer: [this.toU8a()]
    };
  }
  /**
   * @description Returns a hex string representation of the value
   */
  toHex() {
    return pe(this.toU8a());
  }
  /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */
  toHuman() {
    return this.toString();
  }
  /**
   * @description Converts the Object to JSON, typically used for RPC transfers
   */
  toJSON() {
    return this.toHex();
  }
  /**
   * @description Returns the number representation (Same as valueOf)
   */
  toNumber() {
    return this.valueOf();
  }
  /**
   * @description Converts the value in a best-fit primitive form
   */
  toPrimitive() {
    return this.toNumber();
  }
  /**
   * @description Returns the base runtime type name for this instance
   */
  toRawType() {
    return `f${this.__internal__bitLength}`;
  }
  /**
   * @description Encodes the value as a Uint8Array as per the SCALE specifications
   */
  toU8a(t) {
    return ng(this, {
      bitLength: this.__internal__bitLength
    });
  }
}
function _g(n) {
  return ue(n.eq);
}
function vg(n, e) {
  return Array.isArray(e) ? n.length === e.length && Ne(n.find((t, r) => _g(t) ? !t.eq(e[r]) : t !== e[r])) : !1;
}
function Jb(n, e) {
  return Ne(n) || (_g(n) ? !n.eq(e) : n !== e);
}
function Kb(n) {
  return !Array.isArray(n) || n.length !== 2;
}
function ic(n, e) {
  return n.size === e.length && !e.some((t) => Kb(t) || Jb(n.get(t[0]), t[1]));
}
function xu(n, e) {
  return Array.isArray(e) ? ic(n, e) : e instanceof Map ? ic(n, [...e.entries()]) : qt(e) ? ic(n, Object.entries(e)) : !1;
}
function sc(n, e) {
  return n.size === e.length && !e.some((t) => !n.has(t));
}
function Yb(n, e) {
  return Array.isArray(e) ? sc(n, e) : e instanceof Set ? sc(n, [...e.values()]) : qt(e) ? sc(n, Object.values(e)) : !1;
}
function Su(n, e, t, { message: r }, i, s, a, o, c) {
  let l = "";
  try {
    l = `: ${new o(n).toRawType()}`;
  } catch {
  }
  return `${e}: failed at ${pe(i.subarray(0, 16))}${c ? ` on ${c}` : ""} (index ${s + 1}/${a})${l}:: ${r}`;
}
function Eu(n, e, t, [r, i]) {
  const s = e.length;
  let a = 0, o = 0;
  try {
    for (; o < s; ) {
      const c = new r[o](n, t.subarray(a));
      a += c.initialU8aLength || c.encodedLength, e[o] = c, o++;
    }
  } catch (c) {
    throw new Error(Su(n, "decodeU8a", e, c, t.subarray(a), o, s, r[o], i[o]));
  }
  return [e, a];
}
function Qb(n, e, t, [r, i]) {
  const s = e.length;
  let a = 0, o = 0;
  try {
    for (; o < s; ) {
      const c = new r[o](n, t.subarray(a));
      a += c.initialU8aLength || c.encodedLength, e[o] = [i[o], c], o++;
    }
  } catch (c) {
    throw new Error(Su(n, "decodeU8aStruct", e, c, t.subarray(a), o, s, r[o], i[o]));
  }
  return [e, a];
}
function po(n, e, t, r, i) {
  const s = e.length;
  let a = r, o = 0;
  try {
    for (; o < s; ) {
      const c = new i(n, t.subarray(a));
      a += c.initialU8aLength || c.encodedLength, e[o] = c, o++;
    }
  } catch (c) {
    throw new Error(Su(n, "decodeU8aVec", e, c, t.subarray(a), o, s, i));
  }
  return [a, a - r];
}
const rl = ["BTreeMap", "BTreeSet", "HashMap", "Vec"], $b = rl.concat(["Compact", "DoNotConstruct", "Int", "Linkage", "Range", "RangeInclusive", "Result", "Opaque", "Option", "UInt", "WrapperKeepOpaque", "WrapperOpaque"]), Ma = ["<", "(", "[", '"', ",", " "], Xd = [
  // alias <T::InherentOfflineReport as InherentOfflineReport>::Inherent -> InherentOfflineReport
  Vn("<T::InherentOfflineReport as InherentOfflineReport>::Inherent", "InherentOfflineReport", !1),
  Vn("VecDeque<", "Vec<", !1),
  // <T::Balance as HasCompact>
  tw(),
  // Change BoundedVec<Type, Size> to Vec<Type>
  Gd("Bounded", !0),
  // Change WeakVec<Type> to Vec<Type>
  Gd("Weak", !1),
  // Remove all the trait prefixes
  aw(),
  // remove PairOf<T> -> (T, T)
  sw(),
  // remove boxing, `Box<Proposal>` -> `Proposal`
  ow("Box<"),
  // remove generics, `MisbehaviorReport<Hash, BlockNumber>` -> `MisbehaviorReport`
  iw(),
  // alias String -> Text (compat with jsonrpc methods)
  Vn("String", "Text"),
  // alias Vec<u8> -> Bytes
  Vn("Vec<u8>", "Bytes"),
  Vn("&\\[u8\\]", "Bytes"),
  Vn("&'static\\[u8\\]", "Bytes"),
  // alias RawAddress -> Address
  Vn("RawAddress", "Address"),
  // lookups, mapped to Address/AccountId as appropriate in runtime
  Vn("Lookup::Source", "LookupSource"),
  Vn("Lookup::Target", "LookupTarget"),
  // HACK duplication between contracts & primitives, however contracts prefixed with exec
  Vn("exec::StorageKey", "ContractStorageKey"),
  // flattens tuples with one value, `(AccountId)` -> `AccountId`
  nw(),
  // converts ::Type to Type, <T as Trait<I>>::Proposal -> Proposal
  rw(),
  // remove all trailing spaces - this should always be the last
  ew()
];
function ew() {
  return (n) => n.trim();
}
function Cu(n, e) {
  let t = 0;
  for (let r = e, i = n.length; r < i; r++)
    if (n[r] === ">") {
      if (!t)
        return r;
      t--;
    } else
      n[r] === "<" && t++;
  throw new Error(`Unable to find closing matching <> on '${n}' (start ${e})`);
}
function Vn(n, e, t = !0) {
  const r = new RegExp(`(^${n}|${Ma.map((s) => `\\${s}${n}`).join("|")})`, "g"), i = (s) => (r.lastIndex = 0, t && Ma.includes(s[0]) ? `${s[0]}${e}` : e);
  return (s) => s.replace(r, i);
}
function tw() {
  return (n) => {
    if (n.includes(" as HasCompact")) {
      for (let e = 0, t = n.length; e < t; e++)
        if (n[e] === "<") {
          const r = Cu(n, e + 1) - 14;
          n.substring(r, r + 14) === " as HasCompact" && (n = `Compact<${n.substring(e + 1, r)}>`);
        }
    }
    return n;
  };
}
function nw() {
  const n = /,\)/g, e = /\(([^,]+)\)/;
  return (t) => (n.lastIndex = 0, t.replace(n, ")").replace(e, "$1"));
}
function Au(n, e, t) {
  let r = -1;
  for (; ; ) {
    if (r = n.indexOf(e, r + 1), r === -1)
      return n;
    const i = r + e.length, s = Cu(n, i);
    n = `${n.substring(0, r)}${t(n.substring(i, s))}${n.substring(s + 1)}`;
  }
}
function Gd(n, e) {
  return (t) => {
    for (let r = 0, i = rl.length; r < i; r++) {
      const s = rl[r];
      t = Au(t, `${n}${s}<`, (a) => {
        const o = a.split(",").map((c) => c.trim()).filter((c) => c);
        return e && o.pop(), `${s}<${o.join(",")}>`;
      });
    }
    return t;
  };
}
function rw() {
  return (n) => {
    let e = 0;
    for (; e !== -1; )
      if (e = n.indexOf("::"), e === 0)
        n = n.substring(2);
      else if (e !== -1) {
        let t = e;
        for (; t !== -1 && !Ma.includes(n[t]); )
          t--;
        n = `${n.substring(0, t + 1)}${n.substring(e + 2)}`;
      }
    return n;
  };
}
function iw() {
  return (n) => {
    for (let e = 0, t = n.length; e < t; e++)
      if (n[e] === "<" && !$b.find((i) => {
        const s = e - i.length;
        return s >= 0 && n.substring(s, e) === i && // make sure it is stand-alone, i.e. don't catch ElectionResult<...> as Result<...>
        (s === 0 || Ma.includes(n[s - 1]));
      })) {
        const i = Cu(n, e + 1);
        n = `${n.substring(0, e)}${n.substring(i + 1)}`;
      }
    return n;
  };
}
function sw() {
  const n = (e) => `(${e},${e})`;
  return (e) => Au(e, "PairOf<", n);
}
function aw() {
  const n = /\s/g, e = /(T|Self)::/g, t = /<(T|Self)asTrait>::/g, r = /<Tas[a-z]+::Trait>::/g, i = /<LookupasStaticLookup>/g, s = /::Type/g;
  return (a) => (n.lastIndex = 0, e.lastIndex = 0, t.lastIndex = 0, r.lastIndex = 0, i.lastIndex = 0, s.lastIndex = 0, a.replace(n, "").replace(e, "").replace(t, "").replace(r, "").replace(i, "Lookup").replace(s, ""));
}
function ow(n) {
  const e = (t) => t;
  return (t) => Au(t, n, e);
}
const Zd = /* @__PURE__ */ new Map();
function La(n) {
  const e = n.toString(), t = Zd.get(e);
  if (t)
    return t;
  let r = e;
  for (let i = 0, s = Xd.length; i < s; i++)
    r = Xd[i](r);
  return Zd.set(e, r), r;
}
function Jd(n) {
  return n instanceof Uint8Array || Array.isArray(n);
}
function Kd(n) {
  return Jn(n) && xe(n.index) && Jn(n.value);
}
function Yd(n) {
  return xe(n) || Yt(n) || vr(n);
}
function cw(n, e) {
  let t = 0;
  const r = Math.min(n.length, e.length);
  for (let i = 0; i < r; ++i)
    if (t = ti(n[i], e[i]), t !== 0)
      return t;
  return n.length - e.length;
}
function ti(n, e) {
  if (Yd(n) && Yd(e))
    return Tt(n).cmp(Tt(e));
  if (n instanceof Map && e instanceof Map)
    return ti(Array.from(n.values()), Array.from(e.values()));
  if (Kd(n) && Kd(e))
    return ti(n.index, e.index) || ti(n.value, e.value);
  if (Jd(n) && Jd(e))
    return cw(n, e);
  if (Jn(n) && Jn(e))
    return ti(n.toU8a(!0), e.toU8a(!0));
  throw new Error(`Attempting to sort unrecognized values: ${_e(n)} (typeof ${typeof n}) <-> ${_e(e)} (typeof ${typeof e})`);
}
function lw(n) {
  return new Set(Array.from(n).sort(ti));
}
function uw(n) {
  return new Map(Array.from(n.entries()).sort(([e], [t]) => ti(e, t)));
}
function Mn(n, e) {
  return typeof e == "function" ? e : n.createClassUnsafe(e);
}
function dw(n, e) {
  const t = e.length, r = new Array(t);
  for (let i = 0; i < t; i++)
    r[i] = Mn(n, e[i]);
  return r;
}
function Pu(n, e) {
  const t = Object.entries(e), r = t.length, i = [new Array(r), new Array(r)];
  for (let s = 0; s < r; s++)
    i[1][s] = t[s][0], i[0][s] = Mn(n, t[s][1]);
  return i;
}
function bg(n, [e, t]) {
  const r = {};
  for (let i = 0, s = t.length; i < s; i++)
    r[t[i]] = n.getClassName(e[i]) || new e[i](n).toRawType();
  return r;
}
function fw(n) {
  return Object.entries(n || {});
}
class wg extends Map {
  constructor(t, r) {
    const i = fw(r);
    super(i);
    b(this, "registry");
    b(this, "createdAtHash");
    b(this, "initialU8aLength");
    b(this, "isStorageFallback");
    this.registry = t, Hr(this, i.map(([s]) => s), (s) => this.get(s));
  }
  /**
   * @description Always 0, never encodes as a Uint8Array
   */
  get encodedLength() {
    return 0;
  }
  /**
   * @description returns a hash of the contents
   */
  get hash() {
    return this.registry.hash(this.toU8a());
  }
  /**
   * @description Checks if the value is an empty value
   */
  get isEmpty() {
    return [...this.keys()].length === 0;
  }
  /**
   * @description Compares the value of the input to see if there is a match
   */
  eq(t) {
    return xu(this, t);
  }
  /**
   * @description Returns a typed value from the internal map
   */
  getT(t) {
    return this.get(t);
  }
  /**
   * @description Unimplemented, will throw
   */
  inspect() {
    throw new Error("Unimplemented");
  }
  /**
   * @description Unimplemented, will throw
   */
  toHex() {
    throw new Error("Unimplemented");
  }
  /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */
  toHuman() {
    return [...this.entries()].reduce((t, [r, i]) => (t[r] = ue(i.toHuman) ? i.toHuman() : i, t), {});
  }
  /**
   * @description Converts the Object to JSON, typically used for RPC transfers
   */
  toJSON() {
    return [...this.entries()].reduce((t, [r, i]) => (t[r] = i, t), {});
  }
  /**
   * @description Converts the value in a best-fit primitive form
   */
  toPrimitive() {
    return [...this.entries()].reduce((t, [r, i]) => (t[r] = ue(i.toPrimitive) ? i.toPrimitive() : i, t), {});
  }
  /**
   * @description Returns the base runtime type name for this instance
   */
  toRawType() {
    return "Json";
  }
  /**
   * @description Returns the string representation of the value
   */
  toString() {
    return _e(this.toJSON());
  }
  /**
   * @description Unimplemented, will throw
   */
  toU8a(t) {
    throw new Error("Unimplemented");
  }
}
class bn extends Uint8Array {
  constructor(t, r, i) {
    super(j(r));
    b(this, "registry");
    b(this, "createdAtHash");
    b(this, "initialU8aLength");
    b(this, "isStorageFallback");
    this.registry = t, this.initialU8aLength = i;
  }
  /**
   * @description This ensures that operators such as clice, filter, map, etc. return
   * new Array instances (without this we need to apply overrides)
   */
  static get [Symbol.species]() {
    return Uint8Array;
  }
  /**
   * @description The length of the value when encoded as a Uint8Array
   */
  get encodedLength() {
    return this.length;
  }
  /**
   * @description returns a hash of the contents
   */
  get hash() {
    return this.registry.hash(this.toU8a());
  }
  /**
   * @description Returns true if the wrapped value contains only ASCII printable characters
   */
  get isAscii() {
    return tl(this);
  }
  /**
   * @description Returns true if the type wraps an empty/default all-0 value
   */
  get isEmpty() {
    return !this.length || Ne(this.find((t) => !!t));
  }
  /**
   * @description Returns true if the wrapped value contains only utf8 characters
   */
  get isUtf8() {
    return fg(this);
  }
  /**
   * @description Returns the number of bits in the value
   */
  bitLength() {
    return this.length * 8;
  }
  /**
   * @description Compares the value of the input to see if there is a match
   */
  eq(t) {
    return t instanceof Uint8Array ? this.length === t.length && !this.some((r, i) => r !== t[i]) : this.eq(j(t));
  }
  /**
   * @description Returns a breakdown of the hex encoding for this Codec
   */
  inspect() {
    return {
      outer: [this.toU8a()]
    };
  }
  /**
   * @description Returns a hex string representation of the value
   */
  toHex() {
    return pe(this);
  }
  /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */
  toHuman() {
    return this.toPrimitive();
  }
  /**
   * @description Converts the Object to JSON, typically used for RPC transfers
   */
  toJSON() {
    return this.toHex();
  }
  /**
   * @description Converts the value in a best-fit primitive form
   */
  toPrimitive() {
    if (this.isAscii) {
      const t = this.toUtf8();
      if (tl(t))
        return t;
    }
    return this.toJSON();
  }
  /**
   * @description Returns the base runtime type name for this instance
   */
  toRawType() {
    return "Raw";
  }
  /**
   * @description Returns the string representation of the value
   */
  toString() {
    return this.toHex();
  }
  /**
   * @description Encodes the value as a Uint8Array as per the SCALE specifications
   */
  toU8a(t) {
    return Uint8Array.from(this);
  }
  /**
   * @description Returns the wrapped data as a UTF-8 string
   */
  toUtf8() {
    if (!this.isUtf8)
      throw new Error("The character sequence is not a valid Utf8 string");
    return Nn(this);
  }
}
function xg(n, e) {
  const t = new Z(0);
  for (let r = 0, i = e.length; r < i; r++)
    t.ior(Tt(n[e[r]] || 0));
  return t;
}
function hw(n, e) {
  const t = e.length, r = new Array(t);
  for (let i = 0; i < t; i++) {
    const s = e[i];
    if (Ne(n[s]))
      throw new Error(`Set: Invalid key '${s}' passed to Set, allowed ${Object.keys(n).join(", ")}`);
    r[i] = s;
  }
  return r;
}
function Qd(n, e) {
  const t = Tt(e), r = Object.keys(n), i = [];
  for (let a = 0, o = r.length; a < o; a++) {
    const c = r[a];
    t.and(Tt(n[c])).eq(Tt(n[c])) && i.push(c);
  }
  const s = xg(n, i);
  if (!t.eq(s))
    throw new Error(`Set: Mismatch decoding '${t.toString()}', computed as '${s.toString()}' with ${i.join(", ")}`);
  return i;
}
function Sg(n, e = 0, t) {
  if (t % 8 !== 0)
    throw new Error(`Expected valid bitLength, power of 8, found ${t}`);
  const r = t / 8;
  if (te(e))
    return e.length === 0 ? [] : Qd(n, fn(e.subarray(0, r), { isLe: !0 }));
  if (Pe(e))
    return Sg(n, j(e), r);
  if (e instanceof Set || Array.isArray(e)) {
    const i = Array.isArray(e) ? e : [...e.values()];
    return hw(n, i);
  }
  return Qd(n, e);
}
class ku extends Set {
  constructor(t, r, i, s = 8) {
    super(Sg(r, i, s));
    b(this, "registry");
    b(this, "createdAtHash");
    b(this, "initialU8aLength");
    b(this, "isStorageFallback");
    b(this, "__internal__allowed");
    b(this, "__internal__byteLength");
    /**
     * @description adds a value to the Set (extended to allow for validity checking)
     */
    b(this, "add", (t) => {
      if (this.__internal__allowed && Ne(this.__internal__allowed[t]))
        throw new Error(`Set: Invalid key '${t}' on add`);
      return super.add(t), this;
    });
    this.registry = t, this.__internal__allowed = r, this.__internal__byteLength = s / 8;
  }
  static with(t, r) {
    var i;
    return i = class extends ku {
      constructor(a, o) {
        super(a, t, o, r);
      }
    }, (() => {
      const a = Object.keys(t), o = a.length, c = new Array(o);
      for (let l = 0; l < o; l++)
        c[l] = `is${fo(a[l])}`;
      Hr(i.prototype, c, (l, u, f) => f.strings.includes(a[u]));
    })(), i;
  }
  /**
   * @description The length of the value when encoded as a Uint8Array
   */
  get encodedLength() {
    return this.__internal__byteLength;
  }
  /**
   * @description returns a hash of the contents
   */
  get hash() {
    return this.registry.hash(this.toU8a());
  }
  /**
   * @description true is the Set contains no values
   */
  get isEmpty() {
    return this.size === 0;
  }
  /**
   * @description The actual set values as a string[]
   */
  get strings() {
    return [...super.values()];
  }
  /**
   * @description The encoded value for the set members
   */
  get valueEncoded() {
    return xg(this.__internal__allowed, this.strings);
  }
  /**
   * @description Compares the value of the input to see if there is a match
   */
  eq(t) {
    return Array.isArray(t) ? vg(this.strings.sort(), t.sort()) : t instanceof Set ? this.eq([...t.values()]) : xe(t) || Yt(t) ? this.valueEncoded.eq(Tt(t)) : !1;
  }
  /**
   * @description Returns a breakdown of the hex encoding for this Codec
   */
  inspect() {
    return {
      outer: [this.toU8a()]
    };
  }
  /**
   * @description Returns a hex string representation of the value
   */
  toHex() {
    return pe(this.toU8a());
  }
  /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */
  toHuman() {
    return this.toJSON();
  }
  /**
   * @description Converts the Object to JSON, typically used for RPC transfers
   */
  toJSON() {
    return this.strings;
  }
  /**
   * @description The encoded value for the set members
   */
  toNumber() {
    return this.valueEncoded.toNumber();
  }
  /**
   * @description Converts the value in a best-fit primitive form
   */
  toPrimitive() {
    return this.toJSON();
  }
  /**
   * @description Returns the base runtime type name for this instance
   */
  toRawType() {
    return _e({ _set: this.__internal__allowed });
  }
  /**
   * @description Returns the string representation of the value
   */
  toString() {
    return `[${this.strings.join(", ")}]`;
  }
  /**
   * @description Encodes the value as a Uint8Array as per the SCALE specifications
   */
  toU8a(t) {
    return Lt(this.valueEncoded, {
      bitLength: this.__internal__byteLength * 8,
      isLe: !0
    });
  }
}
function pw(n) {
  return n;
}
function mw(n, [e, t], r, i) {
  let s;
  const a = Array.isArray(r), o = r instanceof Map, c = t.length;
  if (!a && !o && !qt(r))
    throw new Error(`Struct: Cannot decode value ${_e(r)} (typeof ${typeof r}), expected an input object, map or array`);
  if (a && r.length !== c)
    throw new Error(`Struct: Unable to map ${_e(r)} array to object with known keys ${t.join(", ")}`);
  const l = new Array(c);
  for (let u = 0; u < c; u++) {
    const f = t[u], m = i.get(f) || f, y = e[u];
    let _;
    try {
      if (a)
        _ = r[u];
      else if (o)
        _ = m && r.get(m);
      else if (_ = m && r[m], Ne(_)) {
        if (Ne(s)) {
          const v = Object.entries(r);
          s = {};
          for (let C = 0, A = v.length; C < A; C++)
            s[Ee(v[C][0])] = v[C][1];
        }
        _ = m && s[m];
      }
      l[u] = [
        f,
        _ instanceof y ? _ : new y(n, _)
      ];
    } catch (v) {
      let C = y.name;
      try {
        C = new y(n).toRawType();
      } catch {
      }
      throw new Error(`Struct: failed on ${m}: ${C}:: ${v.message}`);
    }
  }
  return [l, 0];
}
class Dt extends Map {
  constructor(t, r, i, s = /* @__PURE__ */ new Map(), { definition: a, setDefinition: o = pw } = {}) {
    const c = a || o(Pu(t, r)), [l, u] = te(i) || ye(i) ? Qb(t, new Array(c[0].length), j(i), c) : i instanceof Dt ? [i, 0] : mw(t, c, i || {}, s);
    super(l);
    b(this, "registry");
    b(this, "createdAtHash");
    b(this, "initialU8aLength");
    b(this, "isStorageFallback");
    b(this, "__internal__jsonMap");
    b(this, "__internal__Types");
    this.initialU8aLength = u, this.registry = t, this.__internal__jsonMap = s, this.__internal__Types = c;
  }
  static with(t, r) {
    var a;
    let i;
    const s = (o) => i = o;
    return a = class extends Dt {
      constructor(c, l) {
        super(c, t, l, r, { definition: i, setDefinition: s });
      }
    }, (() => {
      const c = Object.keys(t);
      Hr(a.prototype, c, (l, u, f) => f.get(l));
    })(), a;
  }
  /**
   * @description The available keys for this struct
   */
  get defKeys() {
    return this.__internal__Types[1];
  }
  /**
   * @description Checks if the value is an empty value
   */
  get isEmpty() {
    for (const t of this.values())
      if (!t.isEmpty)
        return !1;
    return !0;
  }
  /**
   * @description The length of the value when encoded as a Uint8Array
   */
  get encodedLength() {
    let t = 0;
    for (const r of this.values())
      t += r.encodedLength;
    return t;
  }
  /**
   * @description returns a hash of the contents
   */
  get hash() {
    return this.registry.hash(this.toU8a());
  }
  /**
   * @description Returns the Type description of the structure
   */
  get Type() {
    const t = {}, [r, i] = this.__internal__Types;
    for (let s = 0, a = i.length; s < a; s++)
      t[i[s]] = new r[s](this.registry).toRawType();
    return t;
  }
  /**
   * @description Compares the value of the input to see if there is a match
   */
  eq(t) {
    return xu(this, t);
  }
  /**
   * @description Returns a specific names entry in the structure
   * @param key The name of the entry to retrieve
   */
  get(t) {
    return super.get(t);
  }
  /**
   * @description Returns the values of a member at a specific index (Rather use get(name) for performance)
   */
  getAtIndex(t) {
    return this.toArray()[t];
  }
  /**
   * @description Returns the a types value by name
   */
  getT(t) {
    return super.get(t);
  }
  /**
   * @description Returns a breakdown of the hex encoding for this Codec
   */
  inspect(t) {
    const r = [];
    for (const [i, s] of this.entries())
      r.push({
        ...s.inspect(!t || bs(t) ? t : t[i]),
        name: Ee(i)
      });
    return {
      inner: r
    };
  }
  /**
   * @description Converts the Object to an standard JavaScript Array
   */
  toArray() {
    return [...this.values()];
  }
  /**
   * @description Returns a hex string representation of the value
   */
  toHex() {
    return pe(this.toU8a());
  }
  /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */
  toHuman(t) {
    const r = {};
    for (const [i, s] of this.entries())
      r[i] = s.toHuman(t);
    return r;
  }
  /**
   * @description Converts the Object to JSON, typically used for RPC transfers
   */
  toJSON() {
    const t = {};
    for (const [r, i] of this.entries())
      t[this.__internal__jsonMap.get(r) || r] = i.toJSON();
    return t;
  }
  /**
   * @description Converts the value in a best-fit primitive form
   */
  toPrimitive() {
    const t = {};
    for (const [r, i] of this.entries())
      t[r] = i.toPrimitive();
    return t;
  }
  /**
   * @description Returns the base runtime type name for this instance
   */
  toRawType() {
    return _e(bg(this.registry, this.__internal__Types));
  }
  /**
   * @description Returns the string representation of the value
   */
  toString() {
    return _e(this.toJSON());
  }
  /**
   * @description Encodes the value as a Uint8Array as per the SCALE specifications
   * @param isBare true when the value has none of the type-specific prefixes (internal)
   */
  toU8a(t) {
    const r = [];
    for (const [i, s] of this.entries())
      r.push(s.toU8a(!t || bs(t) ? t : t[i]));
    return Wt(r);
  }
}
const $d = 128 * 1024;
function gw(n) {
  if (te(n)) {
    if (!n.length)
      return ["", 0];
    if (n instanceof bn)
      return [Nn(n), 0];
    const [e, t] = qr(n), r = e + t;
    if (t > $d)
      throw new Error(`Text: length ${t.toString()} exceeds ${$d}`);
    if (r > n.length)
      throw new Error(`Text: required length less than remainder, expected at least ${r}, found ${n.length}`);
    return [Nn(n.subarray(e, r)), r];
  } else if (ye(n))
    return [Nn(Mt(n)), 0];
  return [n ? n.toString() : "", 0];
}
class Tu extends String {
  constructor(t, r) {
    const [i, s] = gw(r);
    super(i);
    b(this, "registry");
    b(this, "createdAtHash");
    b(this, "initialU8aLength");
    b(this, "isStorageFallback");
    b(this, "__internal__override", null);
    this.registry = t, this.initialU8aLength = s;
  }
  /**
   * @description The length of the value when encoded as a Uint8Array
   */
  get encodedLength() {
    return this.toU8a().length;
  }
  /**
   * @description returns a hash of the contents
   */
  get hash() {
    return this.registry.hash(this.toU8a());
  }
  /**
   * @description Checks if the value is an empty value
   */
  get isEmpty() {
    return this.length === 0;
  }
  /**
   * @description The length of the value
   */
  get length() {
    return super.length;
  }
  /**
   * @description Compares the value of the input to see if there is a match
   */
  eq(t) {
    return Pe(t) ? this.toString() === t.toString() : !1;
  }
  /**
   * @description Returns a breakdown of the hex encoding for this Codec
   */
  inspect() {
    const t = Ze(super.toString());
    return {
      outer: t.length ? [nt(t.length), t] : [nt(t.length)]
    };
  }
  /**
   * @description Set an override value for this
   */
  setOverride(t) {
    this.__internal__override = t;
  }
  /**
   * @description Returns a hex string representation of the value
   */
  toHex() {
    return pe(this.toU8a(!0));
  }
  /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */
  toHuman() {
    return this.toJSON();
  }
  /**
   * @description Converts the Object to JSON, typically used for RPC transfers
   */
  toJSON() {
    return this.toString();
  }
  /**
   * @description Converts the value in a best-fit primitive form
   */
  toPrimitive() {
    return this.toJSON();
  }
  /**
   * @description Returns the base runtime type name for this instance
   */
  toRawType() {
    return "Text";
  }
  /**
   * @description Returns the string representation of the value
   */
  toString() {
    return this.__internal__override || super.toString();
  }
  /**
   * @description Encodes the value as a Uint8Array as per the SCALE specifications
   * @param isBare true when the value has none of the type-specific prefixes (internal)
   */
  toU8a(t) {
    const r = Ze(super.toString());
    return t ? r : wn(r);
  }
}
const yw = G.object({
  name: G.string(),
  type: G.union([G.number(), G.string()])
}), _w = G.object({
  name: G.string().optional(),
  type: G.number(),
  typeName: G.string().optional()
}), vw = G.object({
  index: G.number(),
  name: G.string()
}), bw = G.object({
  name: G.string(),
  fields: G.array(G.any())
}), ww = G.record(G.number().min(0), bw), xw = G.object({
  id: G.number(),
  type: G.object({
    def: G.object({
      composite: G.object({
        fields: G.array(_w)
      }).optional(),
      variant: G.object({
        variants: G.union([G.array(vw).optional(), ww])
      }).optional(),
      sequence: G.object({
        type: G.number()
      }).optional(),
      array: G.object({
        len: G.number(),
        type: G.number()
      }).optional(),
      primitive: G.string().optional(),
      tuple: G.any().optional()
    }),
    params: G.array(yw).optional(),
    path: G.array(G.string()).optional()
  })
}), Sw = G.object({
  dispatchKey: G.string(),
  variants: G.any()
}), il = G.union([G.instanceof(Tu), G.string()]), Ew = G.object({
  key: il,
  ty: G.union([G.number(), G.string()])
}), Eg = G.array(xw), Cg = G.lazy(() => G.object({
  name: il.optional(),
  layout: G.object({
    leaf: Ew.optional(),
    enum: Sw.optional(),
    root: Cg.optional(),
    struct: Ag.optional()
  }),
  root_key: il.optional()
})), Ag = G.object({
  fields: G.array(Cg),
  name: G.string()
}), Pg = G.object({
  root: G.object({
    layout: G.object({
      struct: Ag.optional()
    })
  })
}), kg = G.object({
  constructors: G.array(G.any()),
  docs: G.array(G.any()),
  events: G.array(G.any()),
  messages: G.array(G.object({
    label: G.string(),
    selector: G.string()
  }))
});
var ms;
(function(n) {
  n.V1 = "V1", n.V2 = "V2", n.V3 = "V3";
})(ms || (ms = {}));
const ac = G.object({
  spec: kg,
  types: Eg,
  storage: Pg
}), Cw = G.object({
  metadataVersion: G.string().optional(),
  source: G.object({
    hash: G.string(),
    language: G.string(),
    compiler: G.string(),
    wasm: G.string().optional()
  }),
  contract: G.object({
    name: G.string(),
    version: G.string(),
    authors: G.array(G.string())
  }),
  [ms.V1]: ac.optional(),
  [ms.V2]: ac.optional(),
  [ms.V3]: ac.optional(),
  spec: kg,
  types: Eg,
  storage: Pg
});
var Tg = [], Aw = Tg.forEach, Pw = Tg.slice;
function kw(n) {
  return Aw.call(Pw.call(arguments, 1), function(e) {
    if (e)
      for (var t in e)
        n[t] === void 0 && (n[t] = e[t]);
  }), n;
}
var ef = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/, Tw = function(e, t, r) {
  var i = r || {};
  i.path = i.path || "/";
  var s = encodeURIComponent(t), a = e + "=" + s;
  if (i.maxAge > 0) {
    var o = i.maxAge - 0;
    if (isNaN(o))
      throw new Error("maxAge should be a Number");
    a += "; Max-Age=" + Math.floor(o);
  }
  if (i.domain) {
    if (!ef.test(i.domain))
      throw new TypeError("option domain is invalid");
    a += "; Domain=" + i.domain;
  }
  if (i.path) {
    if (!ef.test(i.path))
      throw new TypeError("option path is invalid");
    a += "; Path=" + i.path;
  }
  if (i.expires) {
    if (typeof i.expires.toUTCString != "function")
      throw new TypeError("option expires is invalid");
    a += "; Expires=" + i.expires.toUTCString();
  }
  if (i.httpOnly && (a += "; HttpOnly"), i.secure && (a += "; Secure"), i.sameSite) {
    var c = typeof i.sameSite == "string" ? i.sameSite.toLowerCase() : i.sameSite;
    switch (c) {
      case !0:
        a += "; SameSite=Strict";
        break;
      case "lax":
        a += "; SameSite=Lax";
        break;
      case "strict":
        a += "; SameSite=Strict";
        break;
      case "none":
        a += "; SameSite=None";
        break;
      default:
        throw new TypeError("option sameSite is invalid");
    }
  }
  return a;
};
const Nw = {
  name: "cookie",
  lookup: function(e, t, r) {
    var i;
    if (r.lookupCookie && typeof e < "u") {
      var s = r.getCookies(e);
      s && (i = s[r.lookupCookie]);
    }
    return i;
  },
  cacheUserLanguage: function(e, t, r) {
    var i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    if (i.lookupCookie && e !== "undefined") {
      var s = i.cookieExpirationDate;
      s || (s = /* @__PURE__ */ new Date(), s.setFullYear(s.getFullYear() + 1));
      var a = {
        expires: s,
        domain: i.cookieDomain,
        path: i.cookiePath,
        httpOnly: !1,
        overwrite: !0,
        sameSite: i.cookieSameSite
      };
      i.cookieSecure && (a.secure = i.cookieSecure);
      var o = i.getHeader(t, "set-cookie") || i.getHeader(t, "Set-Cookie") || [];
      typeof o == "string" && (o = [o]), Array.isArray(o) || (o = []), o = o.filter(function(c) {
        return c.indexOf("".concat(i.lookupCookie, "=")) !== 0;
      }), o.push(Tw(i.lookupCookie, r, a)), i.setHeader(t, "Set-Cookie", o.length === 1 ? o[0] : o);
    }
  }
}, Rw = {
  name: "querystring",
  lookup: function(e, t, r) {
    var i;
    if (r.lookupQuerystring !== void 0 && typeof e < "u" && (r.getQuery(e) && (i = r.getQuery(e)[r.lookupQuerystring]), !i && r.getUrl(e) && r.getUrl(e).indexOf("?"))) {
      var s = r.getUrl(e).substring(r.getUrl(e).indexOf("?"));
      if (typeof URLSearchParams < "u") {
        var a = new URLSearchParams(s);
        i = a.get(r.lookupQuerystring);
      } else {
        var o = s.indexOf("".concat(r.lookupQuerystring, "="));
        if (o > -1) {
          var c = s.substring(r.lookupQuerystring.length + 2);
          c.indexOf("&") < 0 ? i = c : i = c.substring(0, c.indexOf("&"));
        }
      }
    }
    return i;
  }
}, Iw = {
  name: "path",
  lookup: function(e, t, r) {
    var i;
    if (e === void 0)
      return i;
    if (r.lookupPath !== void 0 && e.params && (i = r.getParams(e)[r.lookupPath]), !i && typeof r.lookupFromPathIndex == "number" && r.getOriginalUrl(e)) {
      var s = r.getOriginalUrl(e).split("?")[0], a = s.split("/");
      a[0] === "" && a.shift(), a.length > r.lookupFromPathIndex && (i = a[r.lookupFromPathIndex]);
    }
    return i;
  }
};
var Ow = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab", "419"];
const Mw = {
  name: "header",
  lookup: function(e, t, r) {
    var i;
    if (typeof e < "u") {
      var s = r.getHeaders(e);
      if (!s)
        return i;
      var a = [], o = r.lookupHeader ? s[r.lookupHeader] : s["accept-language"];
      if (o) {
        var c = /(([a-z]{2,3})-?([A-Z]{2})?)\s*;?\s*(q=([0-9.]+))?/gi;
        if (o.indexOf("-") > 0) {
          var l = Ow.find(function(A) {
            return o.toLowerCase().indexOf("-".concat(A)) > 0;
          });
          l && (c = /(([a-z]{2,3})-?([A-Z0-9]{2,4})?)\s*;?\s*(q=([0-9.]+))?/gi);
        }
        var u = [], f, m, y = r.lookupHeaderRegex || c;
        do
          if (m = y.exec(o), m) {
            var _ = m[1], v = m[5] || "1", C = Number(v);
            _ && !isNaN(C) && u.push({
              lng: _,
              q: C
            });
          }
        while (m);
        for (u.sort(function(A, R) {
          return R.q - A.q;
        }), f = 0; f < u.length; f++)
          a.push(u[f].lng);
        a.length && (i = a);
      }
    }
    return i;
  }
};
function sl(n) {
  "@babel/helpers - typeof";
  return sl = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, sl(n);
}
const Lw = {
  name: "session",
  lookup: function(e, t, r) {
    var i;
    return r.lookupSession !== void 0 && sl(e) && r.getSession(e) && (i = r.getSession(e)[r.lookupSession]), i;
  },
  cacheUserLanguage: function(e, t, r) {
    var i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    i.lookupSession && e && i.getSession(e) && (i.getSession(e)[i.lookupSession] = r);
  }
};
var Dw = function(e) {
  if (e.path)
    return e.path;
  if (e.raw && e.raw.path)
    return e.raw.path;
  if (e.url)
    return e.url;
}, Ng = function(e) {
  if (e.url && e.url.href)
    return e.url.href;
  if (e.url)
    return e.url;
  if (e.raw && e.raw.url)
    return e.raw.url;
}, Uw = function(e, t) {
  if (e.url) {
    e.url = t;
    return;
  }
}, Vw = function(e) {
  return e.originalUrl ? e.originalUrl : e.raw && e.raw.originalUrl ? e.raw.originalUrl : Ng(e);
}, Bw = function(e) {
  if (e.query && typeof e.query.entries == "function" && typeof Object.fromEntries == "function" && typeof e.query[Symbol.iterator] == "function")
    return Object.fromEntries(e.query);
  if (e.query)
    return e.query;
  if (e.searchParams)
    return e.searchParams;
  if (e.raw && e.raw.query)
    return e.raw.query;
  if (e.ctx && e.ctx.queryParams)
    return e.ctx.queryParams;
  if (e.url && e.url.searchParams)
    return e.url.searchParams;
  var t = e.url || e.raw && e.raw.url;
  return t && t.indexOf("?") < 0 ? {} : {};
}, Hw = function(e) {
  return e.params ? e.params : e.raw && e.raw.params ? e.raw.params : e.ctx && e.ctx.params ? e.ctx.params : {};
}, Ei = function(e) {
  if (e.headers)
    return e.headers;
}, Fw = function(e) {
  if (e.cookies)
    return e.cookies;
  if (Ei(e)) {
    var t = {}, r = Ei(e).cookie;
    return r && r.split(";").forEach(function(i) {
      var s = i.split("=");
      t[s.shift().trim()] = decodeURI(encodeURI(s.join("=")));
    }), t;
  }
}, jw = function(e) {
  return e.ctx && typeof e.ctx.body == "function" ? e.ctx.body.bind(e.ctx) : e.ctx && e.ctx.body ? e.ctx.body : e.json ? e.json : e.body ? e.body : e.payload ? e.payload : e.request && e.request.body ? e.request.body : {};
}, Ww = function(e, t) {
  if (e.getHeader)
    return e.getHeader(t);
  if (e.headers)
    return e.headers[t];
  if (Ei(e) && Ei(e)[t])
    return Ei(e)[t];
}, Rg = function(e, t, r) {
  if (!(e._headerSent || e.headersSent)) {
    if (typeof e.setHeader == "function")
      return e.setHeader(t, r);
    if (typeof e.header == "function")
      return e.header(t, r);
    if (e.responseHeaders && typeof e.responseHeaders.set == "function")
      return e.responseHeaders.set(t, r);
    if (e.headers && typeof e.headers.set == "function")
      return e.headers.set(t, r);
    if (typeof e.set == "function")
      return e.set(t, r);
  }
}, qw = function(e, t) {
  if (typeof e.contentType == "function")
    return e.contentType(t);
  if (typeof e.type == "function")
    return e.type(t);
  Rg(e, "Content-Type", t);
}, zw = function(e, t) {
  if (typeof e.status == "function")
    return e.status(t);
  if (e.status)
    return e.status = t;
}, Xw = function(e, t) {
  return typeof e.send == "function" ? e.send(t) : (e.request && e.response && e.app && (e.body = t), t);
}, Gw = function(e) {
  if (e.session)
    return e.session;
  if (e.raw && e.raw.session)
    return e.raw.session;
}, Zw = function() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  return e.getPath = e.getPath || Dw, e.getOriginalUrl = e.getOriginalUrl || Vw, e.getUrl = e.getUrl || Ng, e.setUrl = e.setUrl || Uw, e.getParams = e.getParams || Hw, e.getSession = e.getSession || Gw, e.getQuery = e.getQuery || Bw, e.getCookies = e.getCookies || Fw, e.getBody = e.getBody || jw, e.getHeaders = e.getHeaders || Ei, e.getHeader = e.getHeader || Ww, e.setHeader = e.setHeader || Rg, e.setContentType = e.setContentType || qw, e.setStatus = e.setStatus || zw, e.send = e.send || Xw, e;
};
function xs(n) {
  "@babel/helpers - typeof";
  return xs = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, xs(n);
}
function Jw(n, e) {
  if (!(n instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function tf(n, e) {
  for (var t = 0; t < e.length; t++) {
    var r = e[t];
    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(n, Yw(r.key), r);
  }
}
function Kw(n, e, t) {
  return e && tf(n.prototype, e), t && tf(n, t), Object.defineProperty(n, "prototype", { writable: !1 }), n;
}
function Yw(n) {
  var e = Qw(n, "string");
  return xs(e) === "symbol" ? e : String(e);
}
function Qw(n, e) {
  if (xs(n) !== "object" || n === null)
    return n;
  var t = n[Symbol.toPrimitive];
  if (t !== void 0) {
    var r = t.call(n, e || "default");
    if (xs(r) !== "object")
      return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(n);
}
function $w() {
  return Zw({
    order: ["querystring", "cookie", "header"],
    lookupQuerystring: "lng",
    lookupCookie: "i18next",
    lookupSession: "lng",
    lookupFromPathIndex: 0,
    caches: !1,
    cookieSameSite: "strict",
    ignoreCase: !0
  });
}
var Ig = function() {
  function n(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Jw(this, n), this.type = "languageDetector", this.detectors = {}, this.init(e, t, r);
  }
  return Kw(n, [{
    key: "init",
    value: function(t) {
      var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      this.services = t, this.options = kw(r, this.options || {}, $w()), this.allOptions = i, this.addDetector(Nw), this.addDetector(Rw), this.addDetector(Iw), this.addDetector(Mw), this.addDetector(Lw);
    }
  }, {
    key: "addDetector",
    value: function(t) {
      this.detectors[t.name] = t;
    }
  }, {
    key: "detect",
    value: function(t, r, i) {
      var s = this;
      if (!(arguments.length < 2)) {
        i || (i = this.options.order);
        var a;
        if (i.forEach(function(c) {
          if (!(a || !s.detectors[c])) {
            var l = s.detectors[c].lookup(t, r, s.options);
            l && (Array.isArray(l) || (l = [l]), l = l.filter(function(u) {
              return u != null;
            }), s.services.languageUtils.getBestMatchFromCodes ? (a = s.services.languageUtils.getBestMatchFromCodes(l), a && (s.options.ignoreCase ? l.map(function(u) {
              return u.toLowerCase();
            }).indexOf(a.toLowerCase()) < 0 && (a = void 0) : l.indexOf(a) < 0 && (a = void 0)), a && (t.i18nextLookupName = c)) : a = l.length > 0 ? l[0] : null);
          }
        }), !a) {
          var o = this.allOptions.fallbackLng;
          typeof o == "function" && (o = o()), typeof o == "string" && (o = [o]), o || (o = []), Object.prototype.toString.apply(o) === "[object Array]" ? a = o[0] : a = o[0] || o.default && o.default[0];
        }
        return a;
      }
    }
  }, {
    key: "cacheUserLanguage",
    value: function(t, r, i, s) {
      var a = this;
      arguments.length < 3 || (s || (s = this.options.caches), s && s.forEach(function(o) {
        a.detectors[o] && a.detectors[o].cacheUserLanguage && r.cachedUserLanguage !== i && (a.detectors[o].cacheUserLanguage(t, r, i, a.options), r.cachedUserLanguage = i);
      }));
    }
  }]), n;
}();
Ig.type = "languageDetector";
var e2 = Ig;
function Rn(n) {
  "@babel/helpers - typeof";
  return Rn = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Rn(n);
}
function t2(n, e) {
  if (Rn(n) != "object" || !n)
    return n;
  var t = n[Symbol.toPrimitive];
  if (t !== void 0) {
    var r = t.call(n, e || "default");
    if (Rn(r) != "object")
      return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(n);
}
function Og(n) {
  var e = t2(n, "string");
  return Rn(e) == "symbol" ? e : String(e);
}
function tr(n, e, t) {
  return e = Og(e), e in n ? Object.defineProperty(n, e, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : n[e] = t, n;
}
function xn(n, e) {
  if (!(n instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function nf(n, e) {
  for (var t = 0; t < e.length; t++) {
    var r = e[t];
    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(n, Og(r.key), r);
  }
}
function Sn(n, e, t) {
  return e && nf(n.prototype, e), t && nf(n, t), Object.defineProperty(n, "prototype", {
    writable: !1
  }), n;
}
var n2 = /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34|nbsp|#160|copy|#169|reg|#174|hellip|#8230|#x2F|#47);/g, r2 = {
  "&amp;": "&",
  "&#38;": "&",
  "&lt;": "<",
  "&#60;": "<",
  "&gt;": ">",
  "&#62;": ">",
  "&apos;": "'",
  "&#39;": "'",
  "&quot;": '"',
  "&#34;": '"',
  "&nbsp;": " ",
  "&#160;": " ",
  "&copy;": "",
  "&#169;": "",
  "&reg;": "",
  "&#174;": "",
  "&hellip;": "",
  "&#8230;": "",
  "&#x2F;": "/",
  "&#47;": "/"
}, i2 = function(e) {
  return r2[e];
}, s2 = function(e) {
  return e.replace(n2, i2);
};
function rf(n, e) {
  var t = Object.keys(n);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(n);
    e && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(n, i).enumerable;
    })), t.push.apply(t, r);
  }
  return t;
}
function sf(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? rf(Object(t), !0).forEach(function(r) {
      tr(n, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t)) : rf(Object(t)).forEach(function(r) {
      Object.defineProperty(n, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return n;
}
var al = {
  bindI18n: "languageChanged",
  bindI18nStore: "",
  transEmptyNodeValue: "",
  transSupportBasicHtmlNodes: !0,
  transWrapTextNodes: "",
  transKeepBasicHtmlNodesFor: ["br", "strong", "i", "p"],
  useSuspense: !0,
  unescape: s2
}, Mg, a2 = we.createContext();
function o2() {
  var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  al = sf(sf({}, al), n);
}
function c2() {
  return al;
}
var l2 = function() {
  function n() {
    xn(this, n), this.usedNamespaces = {};
  }
  return Sn(n, [{
    key: "addUsedNamespaces",
    value: function(t) {
      var r = this;
      t.forEach(function(i) {
        r.usedNamespaces[i] || (r.usedNamespaces[i] = !0);
      });
    }
  }, {
    key: "getUsedNamespaces",
    value: function() {
      return Object.keys(this.usedNamespaces);
    }
  }]), n;
}();
function u2(n) {
  Mg = n;
}
function d2() {
  return Mg;
}
var f2 = {
  type: "3rdParty",
  init: function(e) {
    o2(e.options.react), u2(e);
  }
};
function h2() {
  if (console && console.warn) {
    for (var n, e = arguments.length, t = new Array(e), r = 0; r < e; r++)
      t[r] = arguments[r];
    typeof t[0] == "string" && (t[0] = "react-i18next:: ".concat(t[0])), (n = console).warn.apply(n, t);
  }
}
var af = {};
function ol() {
  for (var n = arguments.length, e = new Array(n), t = 0; t < n; t++)
    e[t] = arguments[t];
  typeof e[0] == "string" && af[e[0]] || (typeof e[0] == "string" && (af[e[0]] = /* @__PURE__ */ new Date()), h2.apply(void 0, e));
}
function of(n, e, t) {
  n.loadNamespaces(e, function() {
    if (n.isInitialized)
      t();
    else {
      var r = function i() {
        setTimeout(function() {
          n.off("initialized", i);
        }, 0), t();
      };
      n.on("initialized", r);
    }
  });
}
function p2(n, e) {
  var t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, r = e.languages[0], i = e.options ? e.options.fallbackLng : !1, s = e.languages[e.languages.length - 1];
  if (r.toLowerCase() === "cimode")
    return !0;
  var a = function(c, l) {
    var u = e.services.backendConnector.state["".concat(c, "|").concat(l)];
    return u === -1 || u === 2;
  };
  return t.bindI18n && t.bindI18n.indexOf("languageChanging") > -1 && e.services.backendConnector.backend && e.isLanguageChangingTo && !a(e.isLanguageChangingTo, n) ? !1 : !!(e.hasResourceBundle(r, n) || !e.services.backendConnector.backend || e.options.resources && !e.options.partialBundledLanguages || a(r, n) && (!i || a(s, n)));
}
function m2(n, e) {
  var t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  if (!e.languages || !e.languages.length)
    return ol("i18n.languages were undefined or empty", e.languages), !0;
  var r = e.options.ignoreJSONStructure !== void 0;
  return r ? e.hasLoadedNamespace(n, {
    precheck: function(s, a) {
      if (t.bindI18n && t.bindI18n.indexOf("languageChanging") > -1 && s.services.backendConnector.backend && s.isLanguageChangingTo && !a(s.isLanguageChangingTo, n))
        return !1;
    }
  }) : p2(n, e, t);
}
function Lg(n) {
  if (Array.isArray(n))
    return n;
}
function g2(n, e) {
  var t = n == null ? null : typeof Symbol < "u" && n[Symbol.iterator] || n["@@iterator"];
  if (t != null) {
    var r, i, s, a, o = [], c = !0, l = !1;
    try {
      if (s = (t = t.call(n)).next, e === 0) {
        if (Object(t) !== t)
          return;
        c = !1;
      } else
        for (; !(c = (r = s.call(t)).done) && (o.push(r.value), o.length !== e); c = !0)
          ;
    } catch (u) {
      l = !0, i = u;
    } finally {
      try {
        if (!c && t.return != null && (a = t.return(), Object(a) !== a))
          return;
      } finally {
        if (l)
          throw i;
      }
    }
    return o;
  }
}
function cf(n, e) {
  (e == null || e > n.length) && (e = n.length);
  for (var t = 0, r = new Array(e); t < e; t++)
    r[t] = n[t];
  return r;
}
function Dg(n, e) {
  if (n) {
    if (typeof n == "string")
      return cf(n, e);
    var t = Object.prototype.toString.call(n).slice(8, -1);
    if (t === "Object" && n.constructor && (t = n.constructor.name), t === "Map" || t === "Set")
      return Array.from(n);
    if (t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t))
      return cf(n, e);
  }
}
function Ug() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function y2(n, e) {
  return Lg(n) || g2(n, e) || Dg(n, e) || Ug();
}
function lf(n, e) {
  var t = Object.keys(n);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(n);
    e && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(n, i).enumerable;
    })), t.push.apply(t, r);
  }
  return t;
}
function oc(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? lf(Object(t), !0).forEach(function(r) {
      tr(n, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t)) : lf(Object(t)).forEach(function(r) {
      Object.defineProperty(n, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return n;
}
var _2 = function(e, t) {
  var r = we.useRef();
  return we.useEffect(function() {
    r.current = t ? r.current : e;
  }, [e, t]), r.current;
};
function v2(n) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, t = e.i18n, r = we.useContext(a2) || {}, i = r.i18n, s = r.defaultNS, a = t || i || d2();
  if (a && !a.reportNamespaces && (a.reportNamespaces = new l2()), !a) {
    ol("You will need to pass in an i18next instance by using initReactI18next");
    var o = function(Y) {
      return Array.isArray(Y) ? Y[Y.length - 1] : Y;
    }, c = [o, {}, !1];
    return c.t = o, c.i18n = {}, c.ready = !1, c;
  }
  a.options.react && a.options.react.wait !== void 0 && ol("It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");
  var l = oc(oc(oc({}, c2()), a.options.react), e), u = l.useSuspense, f = l.keyPrefix, m = n || s || a.options && a.options.defaultNS;
  m = typeof m == "string" ? [m] : m || ["translation"], a.reportNamespaces.addUsedNamespaces && a.reportNamespaces.addUsedNamespaces(m);
  var y = (a.isInitialized || a.initializedStoreOnce) && m.every(function(U) {
    return m2(U, a, l);
  });
  function _() {
    return a.getFixedT(null, l.nsMode === "fallback" ? m : m[0], f);
  }
  var v = we.useState(_), C = y2(v, 2), A = C[0], R = C[1], I = m.join(), D = _2(I), L = we.useRef(!0);
  we.useEffect(function() {
    var U = l.bindI18n, Y = l.bindI18nStore;
    L.current = !0, !y && !u && of(a, m, function() {
      L.current && R(_);
    }), y && D && D !== I && L.current && R(_);
    function Q() {
      L.current && R(_);
    }
    return U && a && a.on(U, Q), Y && a && a.store.on(Y, Q), function() {
      L.current = !1, U && a && U.split(" ").forEach(function(O) {
        return a.off(O, Q);
      }), Y && a && Y.split(" ").forEach(function(O) {
        return a.store.off(O, Q);
      });
    };
  }, [a, I]);
  var V = we.useRef(!0);
  we.useEffect(function() {
    L.current && !V.current && R(_), V.current = !1;
  }, [a, f]);
  var F = [A, a, y];
  if (F.t = A, F.i18n = a, F.ready = y, y || !y && !u)
    return F;
  throw new Promise(function(U) {
    of(a, m, function() {
      U();
    });
  });
}
class Bs extends Error {
  constructor(e, t) {
    const r = (t == null ? void 0 : t.logger) || Kx(), i = (t == null ? void 0 : t.logLevel) || "error";
    e instanceof Error ? (super(e.message), this.translationKey = t == null ? void 0 : t.translationKey, this.context = {
      ...t == null ? void 0 : t.context,
      ...t != null && t.translationKey ? { translationMessage: Es.t(t.translationKey) } : {}
    }) : (super(Es.t(e)), this.translationKey = e, this.context = t == null ? void 0 : t.context), t != null && t.silent && this.logError(r, i);
  }
  logError(e, t) {
    const r = `
*************** ERROR ***************
`, i = `Error Type: ${this.name}
`, s = JSON.stringify({ error: this.message, context: this.context }), a = `${r}${i}${s}`;
    e[t](a);
  }
}
class cr extends Bs {
  constructor(e, t) {
    const r = (t == null ? void 0 : t.name) || "ProsopoError";
    t = { ...t, name: r }, super(e, t);
  }
}
class Kt extends Bs {
  constructor(e, t) {
    const r = (t == null ? void 0 : t.name) || "ProsopoEnvError";
    t = { ...t, name: r }, super(e, t);
  }
}
class dr extends Bs {
  constructor(e, t) {
    const r = (t == null ? void 0 : t.name) || "ProsopoContractError";
    t = { ...t, name: r }, super(e, t);
  }
}
class Li extends Bs {
  constructor(e, t) {
    const r = (t == null ? void 0 : t.name) || "ProsopoDatasetError";
    t = { ...t, name: r }, super(e, t);
  }
}
class cl extends Bs {
  constructor(e, t) {
    var s;
    const r = (t == null ? void 0 : t.name) || "ProsopoApiError", i = ((s = t == null ? void 0 : t.context) == null ? void 0 : s.code) || 500;
    t = { ...t, name: r, context: { ...t == null ? void 0 : t.context, errorCode: i } }, super(e, t), this.code = i;
  }
}
const b2 = {
  SELECT_ALL: "Select all images containing a",
  NEXT: "Next",
  SUBMIT: "Submit",
  CANCEL: "Cancel",
  SELECT_ACCOUNT: "Select account",
  NO_ACCOUNTS_FOUND: "No accounts found",
  ACCOUNT_NOT_FOUND: "Account not found",
  NO_EXTENSION_FOUND: "No extension found",
  EXTENSION_NOT_FOUND: "Extension not found",
  CANVAS: "Error with Captcha canvas"
}, w2 = {
  BAD_SURI: "Bad SURI",
  CANNOT_FIND_CONFIG_FILE: "prosopo.config.js / prosopo.config.ts cannot be found.",
  JSON_LOAD_FAILED: "Failed to load JSON file",
  CREATE_JSON_FILE_FAILED: "Failed to create JSON file",
  ASSERT_ERROR: "AssertionError",
  GENERATE_CPATCHAS_JSON_FAILED: "Something went wrong while creating captchas json file",
  CALCULATE_CAPTCHA_SOLUTION: "Something went wrong while calculating captcha solutions",
  MNEMONIC_UNDEFINED: "Mnemonic Undefined. Please set the mnemonic in environment variables",
  NO_MNEMONIC_OR_SEED: "No mnemonic or seed provided",
  ASYNC_FACTORY_CREATE: "Use `create` factory method",
  CANT_FIND_KEYRINGPAIR: "Can't find the keyringpair for {{address}}",
  ENVIRONMENT_NOT_READY: "Environment not ready",
  INVALID_SIGNATURE: "Invalid signature",
  PAIR_TYPE_UNDEFINED: "Pair type undefined",
  NOT_IMPLEMENTED: "Not implemented",
  NO_PAIR_TYPE_OR_SS58_FORMAT: "No pair type or ss58 format provided",
  SITE_KEY_MISSING: "SITE KEY missing",
  ACCOUNT_NOT_FOUND: "Account not found"
}, x2 = {
  INVALID_METHOD: "Invalid contract method",
  TX_ERROR: "Error making tx",
  QUERY_ERROR: "Error making query",
  INVALID_ADDRESS: "Failed to encode invalid address",
  INVALID_STORAGE_NAME: "Failed to find given storage name",
  CAPTCHA_SOLUTION_COMMITMENT_DOES_NOT_EXIST: "Captcha solution commitment does not exist",
  DAPP_NOT_ACTIVE: "Dapp is not active",
  CONTRACT_UNDEFINED: "Contract undefined",
  SIGNER_UNDEFINED: "Signer undefined",
  SIGNER_NOT_SUPPORTED: "Signer is not supported. Use connect instead, e.g. contract.connect(signer)",
  CANNOT_FIND_KEYPAIR: "Cannot find keypair",
  INVALID_TYPE: "Invalid type",
  INVALID_ABI: "Invalid ABI",
  NOT_HANDLED: "Not handled",
  INVALID_STORAGE_TYPE: "Invalid storage type",
  INTERRUPTED_EVENT: "Event interrupted",
  TOO_MANY_CALLS: "Too many calls",
  UNKNOWN_ERROR: "Unknown error",
  CHAIN_DECIMALS_UNDEFINED: "Chain decimals are not defined",
  INVALID_DATA_FORMAT: "Invalid data format"
}, S2 = {
  UNKNOWN_ENVIRONMENT: "Unknown environment requested",
  INVALID_CAPTCHA_NUMBER: "Please configure captchas configurations correctly",
  CONFIGURATIONS_LOAD_FAILED: "Prosopo configurations load failed",
  INVALID_LOG_LEVEL: "Invalid log level",
  INVALID_PACKAGE_DIR: "Invalid package directory"
}, E2 = {
  DATASET_PARSE_ERROR: "Error parsing dataset",
  SOLUTION_PARSE_ERROR: "Error parsing dataset",
  HASH_ERROR: "Error hashing dataset",
  INVALID_DATASET_ID: "Invalid dataset id",
  DATASET_ID_UNDEFINED: "Dataset id undefined",
  NOT_ENOUGH_LABELS: "Not enough labels",
  NOT_ENOUGH_IMAGES: "Not enough images",
  CAPTCHAS_COUNT_LESS_THAN_CONFIGURED: "Number of captchas in dataset is less than configured number of captchas",
  SOLUTIONS_COUNT_LESS_THAN_CONFIGURED: "Number of solutions in dataset is less than configured number of solutions",
  DUPLICATE_IMAGE: "duplicate image detected",
  MERKLE_ERROR: "Error creating merkle tree"
}, C2 = {
  CONNECT_ERROR: "Failed to connect",
  DATABASE_IMPORT_FAILED: "Failed to import database engine",
  DATABASE_UNDEFINED: "Database client is not connected",
  DATABASE_HOST_UNDEFINED: "Database host address is not defined",
  COLLECTION_UNDEFINED: "Database collection is not available",
  DATASET_LOAD_FAILED: "Data set load failed",
  DATASET_GET_FAILED: "Failed to get dataset",
  CAPTCHA_GET_FAILED: "Failed to get captcha",
  CAPTCHA_UPDATE_FAILED: "Failed to update captcha",
  IMAGE_GET_FAILED: "Failed to get image",
  NO_CAPTCHAS_FOUND: "No captcha matching datasetId",
  PENDING_RECORD_NOT_FOUND: "No pending record found",
  INVALID_HASH: "Invalid hash",
  SOLUTION_GET_FAILED: "Failed to get solution",
  DATASET_WITH_SOLUTIONS_GET_FAILED: "No datasets found with required number of solutions",
  SOLUTION_APPROVE_FAILED: "Failed to approve solution",
  SOLUTION_FLAG_FAILED: "Failed to flag solution as processed",
  COMMITMENT_FLAG_FAILED: "Failed to flag commitment as processed"
}, A2 = {
  PARSE_ERROR: "Error parsing captcha",
  INVALID_CAPTCHA_ID: "Invalid captcha id",
  SOLUTION_HASH_ERROR: "Error hashing solution",
  INVALID_ITEM_FORMAT: "Only image and text item types allowed",
  INVALID_SOLUTION_TYPE: "Invalid solution type",
  INVALID_ITEM_HASH: "Invalid item hash",
  DIFFERENT_DATASET_IDS: "Dataset ids do not match",
  INVALID_BLOCK_NO: "Invalid block number",
  ID_MISMATCH: "captcha id mismatch",
  MISSING_ITEM_HASH: "missing item hash",
  INVALID_LEAF_HASH: "Invalid leaf hash",
  INVALID_CAPTCHA_CHALLENGE: "Invalid captcha challenge",
  INVALID_DATASET_CONTENT_ID: "Invalid dataset content id",
  DAPP_USER_SOLUTION_NOT_FOUND: "Dapp user solution not found",
  INVALID_PROVIDER_URL: "Invalid provider url",
  NO_CAPTCHA: "No captcha found"
}, P2 = {
  BODY_UNDEFINED: "Body must be defined in API POST call",
  PARAMETER_UNDEFINED: "Parameters must be defined in API POST call",
  CAPTCHA_FAILED: "You answered one or more captchas incorrectly. Please try again",
  CAPTCHA_PENDING: "Captcha solutions submitted and awaiting approval",
  CAPTCHA_PASSED: "You correctly answered the captchas",
  BAD_REQUEST: "BadRequest",
  PAYMENT_INFO_NOT_FOUND: "Payment info not found for given block and transaction hashes",
  USER_VERIFIED: "User verified",
  USER_NOT_VERIFIED: "User not verified",
  UNKNOWN: "Unknown API error"
}, k2 = {
  PARAMETER_ERROR: "Invalid parameter"
}, T2 = {
  PROSOPO_SITE_KEY_MISSING: "PROSOPO_SITE_KEY is not set in .env file.",
  BALANCE_TOO_LOW: "{{mnemonic}} balance too low: {{balance}}",
  CAPTCHA_ID_MISSING: "Cannot find captcha data id",
  COMMITMENT_ID_MISSING: "Commitment id missing",
  PROVIDER_NOT_FOUND: "Provider not found",
  PROVIDER_NO_CAPTCHA: "No captchas returned from provider",
  CREATE_ACCOUNT_FAILED: "Could not create an account!",
  CREATE_ACCOUNT_FAILED_OUT_OF_FUNDS: "Could not create an account as there are no funds. Restart the substrate node.",
  NO_MOCK_ENV: "MockEnvironment not set up",
  ACCOUNT_TYPE_MISSING: "{{accountType}} not created by databasePopulator",
  FUNDING_FAILED: "Funding failed",
  MISSING_PROVIDER_PAIR: "Missing provider pair",
  NETWORK_NOT_FOUND: "Network not found",
  MISSING_ENV_VARIABLE: "Missing environment variable",
  GENERAL: "General Dev Error, see context",
  MISSING_SECRET_KEY: "Missing secret key",
  KEY_ERROR: "Key error",
  METHOD_NOT_IMPLEMENTED: "Method not implemented"
}, N2 = {
  DIRECTORY_NOT_FOUND: "Directory not found",
  FILE_NOT_FOUND: "File not found",
  FILE_ALREADY_EXISTS: "File already exists",
  DIRECTORY_ALREADY_EXISTS: "Directory already exists",
  SAME_FILE: "Same file",
  INVALID_DIR_FORMAT: "Invalid directory format"
}, R2 = {
  NO_STATE_PROVIDER: "useGlobalState must be used within a GlobalStateProvider",
  NO_POLKADOT_EXTENSION: "Polkadot extension not found"
}, Vg = {
  WIDGET: b2,
  GENERAL: w2,
  CONTRACT: x2,
  CONFIG: S2,
  DATASET: E2,
  DATABASE: C2,
  CAPTCHA: A2,
  API: P2,
  CLI: k2,
  DEVELOPER: T2,
  FS: N2,
  PROGUI: R2
};
function I2() {
  return !!(typeof window < "u" && window.document && window.document.createElement);
}
function Bg(n) {
  return typeof n == "string" ? [n] : Object.keys(n).reduce((e, t) => {
    const r = n[t];
    if (r === void 0)
      throw new cr("DEVELOPER.KEY_ERROR", { context: { error: `Undefined value for key ${t}` } });
    const i = Bg(r);
    return e.concat(i.map((s) => `${t}.${s}`));
  }, []);
}
Bg(Vg);
const uf = (n) => lg(n).replace(/\0/g, "");
function O2(n) {
  return n.replace(/([-_][a-z])/g, (e) => e.toUpperCase().replace("-", "").replace("_", ""));
}
function M2(n) {
  var e;
  return `0x${((e = n.match(/.{1,2}/g)) == null ? void 0 : e.reverse().join("")) || ""}`;
}
function ll(n) {
  "@babel/helpers - typeof";
  return ll = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, ll(n);
}
var Hg = [], L2 = Hg.forEach, D2 = Hg.slice;
function ul(n) {
  return L2.call(D2.call(arguments, 1), function(e) {
    if (e)
      for (var t in e)
        n[t] === void 0 && (n[t] = e[t]);
  }), n;
}
function Fg() {
  return typeof XMLHttpRequest == "function" || (typeof XMLHttpRequest > "u" ? "undefined" : ll(XMLHttpRequest)) === "object";
}
function U2(n) {
  return !!n && typeof n.then == "function";
}
function V2(n) {
  return U2(n) ? n : Promise.resolve(n);
}
var dl = { exports: {} }, Qs = { exports: {} }, df;
function B2() {
  return df || (df = 1, function(n, e) {
    var t = typeof self < "u" ? self : Ie, r = function() {
      function s() {
        this.fetch = !1, this.DOMException = t.DOMException;
      }
      return s.prototype = t, new s();
    }();
    (function(s) {
      (function(a) {
        var o = {
          searchParams: "URLSearchParams" in s,
          iterable: "Symbol" in s && "iterator" in Symbol,
          blob: "FileReader" in s && "Blob" in s && function() {
            try {
              return new Blob(), !0;
            } catch {
              return !1;
            }
          }(),
          formData: "FormData" in s,
          arrayBuffer: "ArrayBuffer" in s
        };
        function c(d) {
          return d && DataView.prototype.isPrototypeOf(d);
        }
        if (o.arrayBuffer)
          var l = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
          ], u = ArrayBuffer.isView || function(d) {
            return d && l.indexOf(Object.prototype.toString.call(d)) > -1;
          };
        function f(d) {
          if (typeof d != "string" && (d = String(d)), /[^a-z0-9\-#$%&'*+.^_`|~]/i.test(d))
            throw new TypeError("Invalid character in header field name");
          return d.toLowerCase();
        }
        function m(d) {
          return typeof d != "string" && (d = String(d)), d;
        }
        function y(d) {
          var h = {
            next: function() {
              var g = d.shift();
              return { done: g === void 0, value: g };
            }
          };
          return o.iterable && (h[Symbol.iterator] = function() {
            return h;
          }), h;
        }
        function _(d) {
          this.map = {}, d instanceof _ ? d.forEach(function(h, g) {
            this.append(g, h);
          }, this) : Array.isArray(d) ? d.forEach(function(h) {
            this.append(h[0], h[1]);
          }, this) : d && Object.getOwnPropertyNames(d).forEach(function(h) {
            this.append(h, d[h]);
          }, this);
        }
        _.prototype.append = function(d, h) {
          d = f(d), h = m(h);
          var g = this.map[d];
          this.map[d] = g ? g + ", " + h : h;
        }, _.prototype.delete = function(d) {
          delete this.map[f(d)];
        }, _.prototype.get = function(d) {
          return d = f(d), this.has(d) ? this.map[d] : null;
        }, _.prototype.has = function(d) {
          return this.map.hasOwnProperty(f(d));
        }, _.prototype.set = function(d, h) {
          this.map[f(d)] = m(h);
        }, _.prototype.forEach = function(d, h) {
          for (var g in this.map)
            this.map.hasOwnProperty(g) && d.call(h, this.map[g], g, this);
        }, _.prototype.keys = function() {
          var d = [];
          return this.forEach(function(h, g) {
            d.push(g);
          }), y(d);
        }, _.prototype.values = function() {
          var d = [];
          return this.forEach(function(h) {
            d.push(h);
          }), y(d);
        }, _.prototype.entries = function() {
          var d = [];
          return this.forEach(function(h, g) {
            d.push([g, h]);
          }), y(d);
        }, o.iterable && (_.prototype[Symbol.iterator] = _.prototype.entries);
        function v(d) {
          if (d.bodyUsed)
            return Promise.reject(new TypeError("Already read"));
          d.bodyUsed = !0;
        }
        function C(d) {
          return new Promise(function(h, g) {
            d.onload = function() {
              h(d.result);
            }, d.onerror = function() {
              g(d.error);
            };
          });
        }
        function A(d) {
          var h = new FileReader(), g = C(h);
          return h.readAsArrayBuffer(d), g;
        }
        function R(d) {
          var h = new FileReader(), g = C(h);
          return h.readAsText(d), g;
        }
        function I(d) {
          for (var h = new Uint8Array(d), g = new Array(h.length), E = 0; E < h.length; E++)
            g[E] = String.fromCharCode(h[E]);
          return g.join("");
        }
        function D(d) {
          if (d.slice)
            return d.slice(0);
          var h = new Uint8Array(d.byteLength);
          return h.set(new Uint8Array(d)), h.buffer;
        }
        function L() {
          return this.bodyUsed = !1, this._initBody = function(d) {
            this._bodyInit = d, d ? typeof d == "string" ? this._bodyText = d : o.blob && Blob.prototype.isPrototypeOf(d) ? this._bodyBlob = d : o.formData && FormData.prototype.isPrototypeOf(d) ? this._bodyFormData = d : o.searchParams && URLSearchParams.prototype.isPrototypeOf(d) ? this._bodyText = d.toString() : o.arrayBuffer && o.blob && c(d) ? (this._bodyArrayBuffer = D(d.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : o.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(d) || u(d)) ? this._bodyArrayBuffer = D(d) : this._bodyText = d = Object.prototype.toString.call(d) : this._bodyText = "", this.headers.get("content-type") || (typeof d == "string" ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : o.searchParams && URLSearchParams.prototype.isPrototypeOf(d) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"));
          }, o.blob && (this.blob = function() {
            var d = v(this);
            if (d)
              return d;
            if (this._bodyBlob)
              return Promise.resolve(this._bodyBlob);
            if (this._bodyArrayBuffer)
              return Promise.resolve(new Blob([this._bodyArrayBuffer]));
            if (this._bodyFormData)
              throw new Error("could not read FormData body as blob");
            return Promise.resolve(new Blob([this._bodyText]));
          }, this.arrayBuffer = function() {
            return this._bodyArrayBuffer ? v(this) || Promise.resolve(this._bodyArrayBuffer) : this.blob().then(A);
          }), this.text = function() {
            var d = v(this);
            if (d)
              return d;
            if (this._bodyBlob)
              return R(this._bodyBlob);
            if (this._bodyArrayBuffer)
              return Promise.resolve(I(this._bodyArrayBuffer));
            if (this._bodyFormData)
              throw new Error("could not read FormData body as text");
            return Promise.resolve(this._bodyText);
          }, o.formData && (this.formData = function() {
            return this.text().then(Y);
          }), this.json = function() {
            return this.text().then(JSON.parse);
          }, this;
        }
        var V = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
        function F(d) {
          var h = d.toUpperCase();
          return V.indexOf(h) > -1 ? h : d;
        }
        function U(d, h) {
          h = h || {};
          var g = h.body;
          if (d instanceof U) {
            if (d.bodyUsed)
              throw new TypeError("Already read");
            this.url = d.url, this.credentials = d.credentials, h.headers || (this.headers = new _(d.headers)), this.method = d.method, this.mode = d.mode, this.signal = d.signal, !g && d._bodyInit != null && (g = d._bodyInit, d.bodyUsed = !0);
          } else
            this.url = String(d);
          if (this.credentials = h.credentials || this.credentials || "same-origin", (h.headers || !this.headers) && (this.headers = new _(h.headers)), this.method = F(h.method || this.method || "GET"), this.mode = h.mode || this.mode || null, this.signal = h.signal || this.signal, this.referrer = null, (this.method === "GET" || this.method === "HEAD") && g)
            throw new TypeError("Body not allowed for GET or HEAD requests");
          this._initBody(g);
        }
        U.prototype.clone = function() {
          return new U(this, { body: this._bodyInit });
        };
        function Y(d) {
          var h = new FormData();
          return d.trim().split("&").forEach(function(g) {
            if (g) {
              var E = g.split("="), w = E.shift().replace(/\+/g, " "), x = E.join("=").replace(/\+/g, " ");
              h.append(decodeURIComponent(w), decodeURIComponent(x));
            }
          }), h;
        }
        function Q(d) {
          var h = new _(), g = d.replace(/\r?\n[\t ]+/g, " ");
          return g.split(/\r?\n/).forEach(function(E) {
            var w = E.split(":"), x = w.shift().trim();
            if (x) {
              var T = w.join(":").trim();
              h.append(x, T);
            }
          }), h;
        }
        L.call(U.prototype);
        function O(d, h) {
          h || (h = {}), this.type = "default", this.status = h.status === void 0 ? 200 : h.status, this.ok = this.status >= 200 && this.status < 300, this.statusText = "statusText" in h ? h.statusText : "OK", this.headers = new _(h.headers), this.url = h.url || "", this._initBody(d);
        }
        L.call(O.prototype), O.prototype.clone = function() {
          return new O(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new _(this.headers),
            url: this.url
          });
        }, O.error = function() {
          var d = new O(null, { status: 0, statusText: "" });
          return d.type = "error", d;
        };
        var B = [301, 302, 303, 307, 308];
        O.redirect = function(d, h) {
          if (B.indexOf(h) === -1)
            throw new RangeError("Invalid status code");
          return new O(null, { status: h, headers: { location: d } });
        }, a.DOMException = s.DOMException;
        try {
          new a.DOMException();
        } catch {
          a.DOMException = function(h, g) {
            this.message = h, this.name = g;
            var E = Error(h);
            this.stack = E.stack;
          }, a.DOMException.prototype = Object.create(Error.prototype), a.DOMException.prototype.constructor = a.DOMException;
        }
        function P(d, h) {
          return new Promise(function(g, E) {
            var w = new U(d, h);
            if (w.signal && w.signal.aborted)
              return E(new a.DOMException("Aborted", "AbortError"));
            var x = new XMLHttpRequest();
            function T() {
              x.abort();
            }
            x.onload = function() {
              var S = {
                status: x.status,
                statusText: x.statusText,
                headers: Q(x.getAllResponseHeaders() || "")
              };
              S.url = "responseURL" in x ? x.responseURL : S.headers.get("X-Request-URL");
              var p = "response" in x ? x.response : x.responseText;
              g(new O(p, S));
            }, x.onerror = function() {
              E(new TypeError("Network request failed"));
            }, x.ontimeout = function() {
              E(new TypeError("Network request failed"));
            }, x.onabort = function() {
              E(new a.DOMException("Aborted", "AbortError"));
            }, x.open(w.method, w.url, !0), w.credentials === "include" ? x.withCredentials = !0 : w.credentials === "omit" && (x.withCredentials = !1), "responseType" in x && o.blob && (x.responseType = "blob"), w.headers.forEach(function(S, p) {
              x.setRequestHeader(p, S);
            }), w.signal && (w.signal.addEventListener("abort", T), x.onreadystatechange = function() {
              x.readyState === 4 && w.signal.removeEventListener("abort", T);
            }), x.send(typeof w._bodyInit > "u" ? null : w._bodyInit);
          });
        }
        return P.polyfill = !0, s.fetch || (s.fetch = P, s.Headers = _, s.Request = U, s.Response = O), a.Headers = _, a.Request = U, a.Response = O, a.fetch = P, Object.defineProperty(a, "__esModule", { value: !0 }), a;
      })({});
    })(r), r.fetch.ponyfill = !0, delete r.fetch.polyfill;
    var i = r;
    e = i.fetch, e.default = i.fetch, e.fetch = i.fetch, e.Headers = i.Headers, e.Request = i.Request, e.Response = i.Response, n.exports = e;
  }(Qs, Qs.exports)), Qs.exports;
}
(function(n, e) {
  var t;
  if (typeof fetch == "function" && (typeof Ie < "u" && Ie.fetch ? t = Ie.fetch : typeof window < "u" && window.fetch ? t = window.fetch : t = fetch), typeof Hm < "u" && (typeof window > "u" || typeof window.document > "u")) {
    var r = t || B2();
    r.default && (r = r.default), e.default = r, n.exports = e.default;
  }
})(dl, dl.exports);
var jg = dl.exports;
const Wg = /* @__PURE__ */ nu(jg), ff = /* @__PURE__ */ Bv({
  __proto__: null,
  default: Wg
}, [jg]);
function Da(n) {
  "@babel/helpers - typeof";
  return Da = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Da(n);
}
var fr;
typeof fetch == "function" && (typeof global < "u" && global.fetch ? fr = global.fetch : typeof window < "u" && window.fetch ? fr = window.fetch : fr = fetch);
var Ss;
Fg() && (typeof global < "u" && global.XMLHttpRequest ? Ss = global.XMLHttpRequest : typeof window < "u" && window.XMLHttpRequest && (Ss = window.XMLHttpRequest));
var Ua;
typeof ActiveXObject == "function" && (typeof global < "u" && global.ActiveXObject ? Ua = global.ActiveXObject : typeof window < "u" && window.ActiveXObject && (Ua = window.ActiveXObject));
!fr && ff && !Ss && !Ua && (fr = Wg || ff);
typeof fr != "function" && (fr = void 0);
var fl = function(e, t) {
  if (t && Da(t) === "object") {
    var r = "";
    for (var i in t)
      r += "&" + encodeURIComponent(i) + "=" + encodeURIComponent(t[i]);
    if (!r)
      return e;
    e = e + (e.indexOf("?") !== -1 ? "&" : "?") + r.slice(1);
  }
  return e;
}, hf = function(e, t, r) {
  fr(e, t).then(function(i) {
    if (!i.ok)
      return r(i.statusText || "Error", {
        status: i.status
      });
    i.text().then(function(s) {
      r(null, {
        status: i.status,
        data: s
      });
    }).catch(r);
  }).catch(r);
}, pf = !1, H2 = function(e, t, r, i) {
  e.queryStringParams && (t = fl(t, e.queryStringParams));
  var s = ul({}, typeof e.customHeaders == "function" ? e.customHeaders() : e.customHeaders);
  r && (s["Content-Type"] = "application/json");
  var a = typeof e.requestOptions == "function" ? e.requestOptions(r) : e.requestOptions, o = ul({
    method: r ? "POST" : "GET",
    body: r ? e.stringify(r) : void 0,
    headers: s
  }, pf ? {} : a);
  try {
    hf(t, o, i);
  } catch (c) {
    if (!a || Object.keys(a).length === 0 || !c.message || c.message.indexOf("not implemented") < 0)
      return i(c);
    try {
      Object.keys(a).forEach(function(l) {
        delete o[l];
      }), hf(t, o, i), pf = !0;
    } catch (l) {
      i(l);
    }
  }
}, F2 = function(e, t, r, i) {
  r && Da(r) === "object" && (r = fl("", r).slice(1)), e.queryStringParams && (t = fl(t, e.queryStringParams));
  try {
    var s;
    Ss ? s = new Ss() : s = new Ua("MSXML2.XMLHTTP.3.0"), s.open(r ? "POST" : "GET", t, 1), e.crossDomain || s.setRequestHeader("X-Requested-With", "XMLHttpRequest"), s.withCredentials = !!e.withCredentials, r && s.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"), s.overrideMimeType && s.overrideMimeType("application/json");
    var a = e.customHeaders;
    if (a = typeof a == "function" ? a() : a, a)
      for (var o in a)
        s.setRequestHeader(o, a[o]);
    s.onreadystatechange = function() {
      s.readyState > 3 && i(s.status >= 400 ? s.statusText : null, {
        status: s.status,
        data: s.responseText
      });
    }, s.send(r);
  } catch (c) {
  }
}, j2 = function(e, t, r, i) {
  if (typeof r == "function" && (i = r, r = void 0), i = i || function() {
  }, fr)
    return H2(e, t, r, i);
  if (Fg() || typeof ActiveXObject == "function")
    return F2(e, t, r, i);
  i(new Error("No fetch and no xhr implementation found!"));
};
function W2(n, e) {
  if (!(n instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function mf(n, e) {
  for (var t = 0; t < e.length; t++) {
    var r = e[t];
    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(n, r.key, r);
  }
}
function q2(n, e, t) {
  return e && mf(n.prototype, e), t && mf(n, t), Object.defineProperty(n, "prototype", { writable: !1 }), n;
}
function z2(n, e, t) {
  return e in n ? Object.defineProperty(n, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : n[e] = t, n;
}
var X2 = function() {
  return {
    loadPath: "/locales/{{lng}}/{{ns}}.json",
    addPath: "/locales/add/{{lng}}/{{ns}}",
    allowMultiLoading: !1,
    parse: function(t) {
      return JSON.parse(t);
    },
    stringify: JSON.stringify,
    parsePayload: function(t, r, i) {
      return z2({}, r, i || "");
    },
    request: j2,
    reloadInterval: typeof window < "u" ? !1 : 60 * 60 * 1e3,
    customHeaders: {},
    queryStringParams: {},
    crossDomain: !1,
    withCredentials: !1,
    overrideMimeType: !1,
    requestOptions: {
      mode: "cors",
      credentials: "same-origin",
      cache: "default"
    }
  };
}, qg = function() {
  function n(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    W2(this, n), this.services = e, this.options = t, this.allOptions = r, this.type = "backend", this.init(e, t, r);
  }
  return q2(n, [{
    key: "init",
    value: function(t) {
      var r = this, i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      this.services = t, this.options = ul(i, this.options || {}, X2()), this.allOptions = s, this.services && this.options.reloadInterval && setInterval(function() {
        return r.reload();
      }, this.options.reloadInterval);
    }
  }, {
    key: "readMulti",
    value: function(t, r, i) {
      this._readAny(t, t, r, r, i);
    }
  }, {
    key: "read",
    value: function(t, r, i) {
      this._readAny([t], t, [r], r, i);
    }
  }, {
    key: "_readAny",
    value: function(t, r, i, s, a) {
      var o = this, c = this.options.loadPath;
      typeof this.options.loadPath == "function" && (c = this.options.loadPath(t, i)), c = V2(c), c.then(function(l) {
        if (!l)
          return a(null, {});
        var u = o.services.interpolator.interpolate(l, {
          lng: t.join("+"),
          ns: i.join("+")
        });
        o.loadUrl(u, a, r, s);
      });
    }
  }, {
    key: "loadUrl",
    value: function(t, r, i, s) {
      var a = this;
      this.options.request(this.options, t, void 0, function(o, c) {
        if (c && (c.status >= 500 && c.status < 600 || !c.status))
          return r("failed loading " + t + "; status code: " + c.status, !0);
        if (c && c.status >= 400 && c.status < 500)
          return r("failed loading " + t + "; status code: " + c.status, !1);
        if (!c && o && o.message && o.message.indexOf("Failed to fetch") > -1)
          return r("failed loading " + t + ": " + o.message, !0);
        if (o)
          return r(o, !1);
        var l, u;
        try {
          typeof c.data == "string" ? l = a.options.parse(c.data, i, s) : l = c.data;
        } catch {
          u = "failed parsing " + t + " to json";
        }
        if (u)
          return r(u, !1);
        r(null, l);
      });
    }
  }, {
    key: "create",
    value: function(t, r, i, s, a) {
      var o = this;
      if (this.options.addPath) {
        typeof t == "string" && (t = [t]);
        var c = this.options.parsePayload(r, i, s), l = 0, u = [], f = [];
        t.forEach(function(m) {
          var y = o.options.addPath;
          typeof o.options.addPath == "function" && (y = o.options.addPath(m, r));
          var _ = o.services.interpolator.interpolate(y, {
            lng: m,
            ns: r
          });
          o.options.request(o.options, _, c, function(v, C) {
            l += 1, u.push(v), f.push(C), l === t.length && a && a(u, f);
          });
        });
      }
    }
  }, {
    key: "reload",
    value: function() {
      var t = this, r = this.services, i = r.backendConnector, s = r.languageUtils, a = r.logger, o = i.language;
      if (!(o && o.toLowerCase() === "cimode")) {
        var c = [], l = function(f) {
          var m = s.toResolveHierarchy(f);
          m.forEach(function(y) {
            c.indexOf(y) < 0 && c.push(y);
          });
        };
        l(o), this.allOptions.preload && this.allOptions.preload.forEach(function(u) {
          return l(u);
        }), c.forEach(function(u) {
          t.allOptions.ns.forEach(function(f) {
            i.read(u, f, "read", null, null, function(m, y) {
              m && a.warn("loading namespace ".concat(f, " for language ").concat(u, " failed"), m), !m && y && a.log("loaded namespace ".concat(f, " for language ").concat(u), y), i.loaded("".concat(u, "|").concat(f), m, y);
            });
          });
        });
      }
    }
  }]), n;
}();
qg.type = "backend";
var zg = [], G2 = zg.forEach, Z2 = zg.slice;
function J2(n) {
  return G2.call(Z2.call(arguments, 1), function(e) {
    if (e)
      for (var t in e)
        n[t] === void 0 && (n[t] = e[t]);
  }), n;
}
var gf = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/, K2 = function(e, t, r) {
  var i = r || {};
  i.path = i.path || "/";
  var s = encodeURIComponent(t), a = "".concat(e, "=").concat(s);
  if (i.maxAge > 0) {
    var o = i.maxAge - 0;
    if (Number.isNaN(o))
      throw new Error("maxAge should be a Number");
    a += "; Max-Age=".concat(Math.floor(o));
  }
  if (i.domain) {
    if (!gf.test(i.domain))
      throw new TypeError("option domain is invalid");
    a += "; Domain=".concat(i.domain);
  }
  if (i.path) {
    if (!gf.test(i.path))
      throw new TypeError("option path is invalid");
    a += "; Path=".concat(i.path);
  }
  if (i.expires) {
    if (typeof i.expires.toUTCString != "function")
      throw new TypeError("option expires is invalid");
    a += "; Expires=".concat(i.expires.toUTCString());
  }
  if (i.httpOnly && (a += "; HttpOnly"), i.secure && (a += "; Secure"), i.sameSite) {
    var c = typeof i.sameSite == "string" ? i.sameSite.toLowerCase() : i.sameSite;
    switch (c) {
      case !0:
        a += "; SameSite=Strict";
        break;
      case "lax":
        a += "; SameSite=Lax";
        break;
      case "strict":
        a += "; SameSite=Strict";
        break;
      case "none":
        a += "; SameSite=None";
        break;
      default:
        throw new TypeError("option sameSite is invalid");
    }
  }
  return a;
}, yf = {
  create: function(e, t, r, i) {
    var s = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
      path: "/",
      sameSite: "strict"
    };
    r && (s.expires = /* @__PURE__ */ new Date(), s.expires.setTime(s.expires.getTime() + r * 60 * 1e3)), i && (s.domain = i), document.cookie = K2(e, encodeURIComponent(t), s);
  },
  read: function(e) {
    for (var t = "".concat(e, "="), r = document.cookie.split(";"), i = 0; i < r.length; i++) {
      for (var s = r[i]; s.charAt(0) === " "; )
        s = s.substring(1, s.length);
      if (s.indexOf(t) === 0)
        return s.substring(t.length, s.length);
    }
    return null;
  },
  remove: function(e) {
    this.create(e, "", -1);
  }
}, Y2 = {
  name: "cookie",
  lookup: function(e) {
    var t;
    if (e.lookupCookie && typeof document < "u") {
      var r = yf.read(e.lookupCookie);
      r && (t = r);
    }
    return t;
  },
  cacheUserLanguage: function(e, t) {
    t.lookupCookie && typeof document < "u" && yf.create(t.lookupCookie, e, t.cookieMinutes, t.cookieDomain, t.cookieOptions);
  }
}, Q2 = {
  name: "querystring",
  lookup: function(e) {
    var t;
    if (typeof window < "u") {
      var r = window.location.search;
      !window.location.search && window.location.hash && window.location.hash.indexOf("?") > -1 && (r = window.location.hash.substring(window.location.hash.indexOf("?")));
      for (var i = r.substring(1), s = i.split("&"), a = 0; a < s.length; a++) {
        var o = s[a].indexOf("=");
        if (o > 0) {
          var c = s[a].substring(0, o);
          c === e.lookupQuerystring && (t = s[a].substring(o + 1));
        }
      }
    }
    return t;
  }
}, Yi = null, _f = function() {
  if (Yi !== null)
    return Yi;
  try {
    Yi = window !== "undefined" && window.localStorage !== null;
    var e = "i18next.translate.boo";
    window.localStorage.setItem(e, "foo"), window.localStorage.removeItem(e);
  } catch {
    Yi = !1;
  }
  return Yi;
}, $2 = {
  name: "localStorage",
  lookup: function(e) {
    var t;
    if (e.lookupLocalStorage && _f()) {
      var r = window.localStorage.getItem(e.lookupLocalStorage);
      r && (t = r);
    }
    return t;
  },
  cacheUserLanguage: function(e, t) {
    t.lookupLocalStorage && _f() && window.localStorage.setItem(t.lookupLocalStorage, e);
  }
}, Qi = null, vf = function() {
  if (Qi !== null)
    return Qi;
  try {
    Qi = window !== "undefined" && window.sessionStorage !== null;
    var e = "i18next.translate.boo";
    window.sessionStorage.setItem(e, "foo"), window.sessionStorage.removeItem(e);
  } catch {
    Qi = !1;
  }
  return Qi;
}, ex = {
  name: "sessionStorage",
  lookup: function(e) {
    var t;
    if (e.lookupSessionStorage && vf()) {
      var r = window.sessionStorage.getItem(e.lookupSessionStorage);
      r && (t = r);
    }
    return t;
  },
  cacheUserLanguage: function(e, t) {
    t.lookupSessionStorage && vf() && window.sessionStorage.setItem(t.lookupSessionStorage, e);
  }
}, tx = {
  name: "navigator",
  lookup: function(e) {
    var t = [];
    if (typeof navigator < "u") {
      if (navigator.languages)
        for (var r = 0; r < navigator.languages.length; r++)
          t.push(navigator.languages[r]);
      navigator.userLanguage && t.push(navigator.userLanguage), navigator.language && t.push(navigator.language);
    }
    return t.length > 0 ? t : void 0;
  }
}, nx = {
  name: "htmlTag",
  lookup: function(e) {
    var t, r = e.htmlTag || (typeof document < "u" ? document.documentElement : null);
    return r && typeof r.getAttribute == "function" && (t = r.getAttribute("lang")), t;
  }
}, rx = {
  name: "path",
  lookup: function(e) {
    var t;
    if (typeof window < "u") {
      var r = window.location.pathname.match(/\/([a-zA-Z-]*)/g);
      if (r instanceof Array)
        if (typeof e.lookupFromPathIndex == "number") {
          if (typeof r[e.lookupFromPathIndex] != "string")
            return;
          t = r[e.lookupFromPathIndex].replace("/", "");
        } else
          t = r[0].replace("/", "");
    }
    return t;
  }
}, ix = {
  name: "subdomain",
  lookup: function(e) {
    var t = typeof e.lookupFromSubdomainIndex == "number" ? e.lookupFromSubdomainIndex + 1 : 1, r = typeof window < "u" && window.location && window.location.hostname && window.location.hostname.match(/^(\w{2,5})\.(([a-z0-9-]{1,63}\.[a-z]{2,6})|localhost)/i);
    if (r)
      return r[t];
  }
};
function sx() {
  return {
    order: ["querystring", "cookie", "localStorage", "sessionStorage", "navigator", "htmlTag"],
    lookupQuerystring: "lng",
    lookupCookie: "i18next",
    lookupLocalStorage: "i18nextLng",
    lookupSessionStorage: "i18nextLng",
    // cache user language
    caches: ["localStorage"],
    excludeCacheFor: ["cimode"],
    // cookieMinutes: 10,
    // cookieDomain: 'myDomain'
    convertDetectedLanguage: function(e) {
      return e;
    }
  };
}
var Xg = /* @__PURE__ */ function() {
  function n(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    xn(this, n), this.type = "languageDetector", this.detectors = {}, this.init(e, t);
  }
  return Sn(n, [{
    key: "init",
    value: function(t) {
      var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      this.services = t || {
        languageUtils: {}
      }, this.options = J2(r, this.options || {}, sx()), typeof this.options.convertDetectedLanguage == "string" && this.options.convertDetectedLanguage.indexOf("15897") > -1 && (this.options.convertDetectedLanguage = function(s) {
        return s.replace("-", "_");
      }), this.options.lookupFromUrlIndex && (this.options.lookupFromPathIndex = this.options.lookupFromUrlIndex), this.i18nOptions = i, this.addDetector(Y2), this.addDetector(Q2), this.addDetector($2), this.addDetector(ex), this.addDetector(tx), this.addDetector(nx), this.addDetector(rx), this.addDetector(ix);
    }
  }, {
    key: "addDetector",
    value: function(t) {
      this.detectors[t.name] = t;
    }
  }, {
    key: "detect",
    value: function(t) {
      var r = this;
      t || (t = this.options.order);
      var i = [];
      return t.forEach(function(s) {
        if (r.detectors[s]) {
          var a = r.detectors[s].lookup(r.options);
          a && typeof a == "string" && (a = [a]), a && (i = i.concat(a));
        }
      }), i = i.map(function(s) {
        return r.options.convertDetectedLanguage(s);
      }), this.services.languageUtils.getBestMatchFromCodes ? i : i.length > 0 ? i[0] : null;
    }
  }, {
    key: "cacheUserLanguage",
    value: function(t, r) {
      var i = this;
      r || (r = this.options.caches), r && (this.options.excludeCacheFor && this.options.excludeCacheFor.indexOf(t) > -1 || r.forEach(function(s) {
        i.detectors[s] && i.detectors[s].cacheUserLanguage(t, i.options);
      }));
    }
  }]), n;
}();
Xg.type = "languageDetector";
function Dr(n) {
  if (n === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return n;
}
function hl(n, e) {
  return hl = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, i) {
    return r.__proto__ = i, r;
  }, hl(n, e);
}
function mo(n, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function");
  n.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: n,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(n, "prototype", {
    writable: !1
  }), e && hl(n, e);
}
function Hs(n, e) {
  if (e && (Rn(e) === "object" || typeof e == "function"))
    return e;
  if (e !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return Dr(n);
}
function Qn(n) {
  return Qn = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, Qn(n);
}
function ax(n) {
  if (typeof Symbol < "u" && n[Symbol.iterator] != null || n["@@iterator"] != null)
    return Array.from(n);
}
function ox(n) {
  return Lg(n) || ax(n) || Dg(n) || Ug();
}
function bf(n, e) {
  var t = Object.keys(n);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(n);
    e && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(n, i).enumerable;
    })), t.push.apply(t, r);
  }
  return t;
}
function wf(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? bf(Object(t), !0).forEach(function(r) {
      tr(n, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t)) : bf(Object(t)).forEach(function(r) {
      Object.defineProperty(n, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return n;
}
var cx = {
  type: "logger",
  log: function(e) {
    this.output("log", e);
  },
  warn: function(e) {
    this.output("warn", e);
  },
  error: function(e) {
    this.output("error", e);
  },
  output: function(e, t) {
    console && console[e] && console[e].apply(console, t);
  }
}, lx = function() {
  function n(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    xn(this, n), this.init(e, t);
  }
  return Sn(n, [{
    key: "init",
    value: function(t) {
      var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      this.prefix = r.prefix || "i18next:", this.logger = t || cx, this.options = r, this.debug = r.debug;
    }
  }, {
    key: "setDebug",
    value: function(t) {
      this.debug = t;
    }
  }, {
    key: "log",
    value: function() {
      for (var t = arguments.length, r = new Array(t), i = 0; i < t; i++)
        r[i] = arguments[i];
      return this.forward(r, "log", "", !0);
    }
  }, {
    key: "warn",
    value: function() {
      for (var t = arguments.length, r = new Array(t), i = 0; i < t; i++)
        r[i] = arguments[i];
      return this.forward(r, "warn", "", !0);
    }
  }, {
    key: "error",
    value: function() {
      for (var t = arguments.length, r = new Array(t), i = 0; i < t; i++)
        r[i] = arguments[i];
      return this.forward(r, "error", "");
    }
  }, {
    key: "deprecate",
    value: function() {
      for (var t = arguments.length, r = new Array(t), i = 0; i < t; i++)
        r[i] = arguments[i];
      return this.forward(r, "warn", "WARNING DEPRECATED: ", !0);
    }
  }, {
    key: "forward",
    value: function(t, r, i, s) {
      return s && !this.debug ? null : (typeof t[0] == "string" && (t[0] = "".concat(i).concat(this.prefix, " ").concat(t[0])), this.logger[r](t));
    }
  }, {
    key: "create",
    value: function(t) {
      return new n(this.logger, wf(wf({}, {
        prefix: "".concat(this.prefix, ":").concat(t, ":")
      }), this.options));
    }
  }, {
    key: "clone",
    value: function(t) {
      return t = t || this.options, t.prefix = t.prefix || this.prefix, new n(this.logger, t);
    }
  }]), n;
}(), Gn = new lx(), Fr = function() {
  function n() {
    xn(this, n), this.observers = {};
  }
  return Sn(n, [{
    key: "on",
    value: function(t, r) {
      var i = this;
      return t.split(" ").forEach(function(s) {
        i.observers[s] = i.observers[s] || [], i.observers[s].push(r);
      }), this;
    }
  }, {
    key: "off",
    value: function(t, r) {
      if (this.observers[t]) {
        if (!r) {
          delete this.observers[t];
          return;
        }
        this.observers[t] = this.observers[t].filter(function(i) {
          return i !== r;
        });
      }
    }
  }, {
    key: "emit",
    value: function(t) {
      for (var r = arguments.length, i = new Array(r > 1 ? r - 1 : 0), s = 1; s < r; s++)
        i[s - 1] = arguments[s];
      if (this.observers[t]) {
        var a = [].concat(this.observers[t]);
        a.forEach(function(c) {
          c.apply(void 0, i);
        });
      }
      if (this.observers["*"]) {
        var o = [].concat(this.observers["*"]);
        o.forEach(function(c) {
          c.apply(c, [t].concat(i));
        });
      }
    }
  }]), n;
}();
function $i() {
  var n, e, t = new Promise(function(r, i) {
    n = r, e = i;
  });
  return t.resolve = n, t.reject = e, t;
}
function xf(n) {
  return n == null ? "" : "" + n;
}
function ux(n, e, t) {
  n.forEach(function(r) {
    e[r] && (t[r] = e[r]);
  });
}
function Nu(n, e, t) {
  function r(o) {
    return o && o.indexOf("###") > -1 ? o.replace(/###/g, ".") : o;
  }
  function i() {
    return !n || typeof n == "string";
  }
  for (var s = typeof e != "string" ? [].concat(e) : e.split("."); s.length > 1; ) {
    if (i())
      return {};
    var a = r(s.shift());
    !n[a] && t && (n[a] = new t()), Object.prototype.hasOwnProperty.call(n, a) ? n = n[a] : n = {};
  }
  return i() ? {} : {
    obj: n,
    k: r(s.shift())
  };
}
function Sf(n, e, t) {
  var r = Nu(n, e, Object), i = r.obj, s = r.k;
  i[s] = t;
}
function dx(n, e, t, r) {
  var i = Nu(n, e, Object), s = i.obj, a = i.k;
  s[a] = s[a] || [], r && (s[a] = s[a].concat(t)), r || s[a].push(t);
}
function Va(n, e) {
  var t = Nu(n, e), r = t.obj, i = t.k;
  if (r)
    return r[i];
}
function Ef(n, e, t) {
  var r = Va(n, t);
  return r !== void 0 ? r : Va(e, t);
}
function Gg(n, e, t) {
  for (var r in e)
    r !== "__proto__" && r !== "constructor" && (r in n ? typeof n[r] == "string" || n[r] instanceof String || typeof e[r] == "string" || e[r] instanceof String ? t && (n[r] = e[r]) : Gg(n[r], e[r], t) : n[r] = e[r]);
  return n;
}
function ui(n) {
  return n.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}
var fx = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
function hx(n) {
  return typeof n == "string" ? n.replace(/[&<>"'\/]/g, function(e) {
    return fx[e];
  }) : n;
}
var go = typeof window < "u" && window.navigator && typeof window.navigator.userAgentData > "u" && window.navigator.userAgent && window.navigator.userAgent.indexOf("MSIE") > -1, px = [" ", ",", "?", "!", ";"];
function mx(n, e, t) {
  e = e || "", t = t || "";
  var r = px.filter(function(o) {
    return e.indexOf(o) < 0 && t.indexOf(o) < 0;
  });
  if (r.length === 0)
    return !0;
  var i = new RegExp("(".concat(r.map(function(o) {
    return o === "?" ? "\\?" : o;
  }).join("|"), ")")), s = !i.test(n);
  if (!s) {
    var a = n.indexOf(t);
    a > 0 && !i.test(n.substring(0, a)) && (s = !0);
  }
  return s;
}
function Cf(n, e) {
  var t = Object.keys(n);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(n);
    e && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(n, i).enumerable;
    })), t.push.apply(t, r);
  }
  return t;
}
function $s(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Cf(Object(t), !0).forEach(function(r) {
      tr(n, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t)) : Cf(Object(t)).forEach(function(r) {
      Object.defineProperty(n, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return n;
}
function gx(n) {
  var e = yx();
  return function() {
    var r = Qn(n), i;
    if (e) {
      var s = Qn(this).constructor;
      i = Reflect.construct(r, arguments, s);
    } else
      i = r.apply(this, arguments);
    return Hs(this, i);
  };
}
function yx() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function Zg(n, e) {
  var t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ".";
  if (n) {
    if (n[e])
      return n[e];
    for (var r = e.split(t), i = n, s = 0; s < r.length; ++s) {
      if (!i || typeof i[r[s]] == "string" && s + 1 < r.length)
        return;
      if (i[r[s]] === void 0) {
        for (var a = 2, o = r.slice(s, s + a).join(t), c = i[o]; c === void 0 && r.length > s + a; )
          a++, o = r.slice(s, s + a).join(t), c = i[o];
        if (c === void 0)
          return;
        if (c === null)
          return null;
        if (e.endsWith(o)) {
          if (typeof c == "string")
            return c;
          if (o && typeof c[o] == "string")
            return c[o];
        }
        var l = r.slice(s + a).join(t);
        return l ? Zg(c, l, t) : void 0;
      }
      i = i[r[s]];
    }
    return i;
  }
}
var _x = function(n) {
  mo(t, n);
  var e = gx(t);
  function t(r) {
    var i, s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      ns: ["translation"],
      defaultNS: "translation"
    };
    return xn(this, t), i = e.call(this), go && Fr.call(Dr(i)), i.data = r || {}, i.options = s, i.options.keySeparator === void 0 && (i.options.keySeparator = "."), i.options.ignoreJSONStructure === void 0 && (i.options.ignoreJSONStructure = !0), i;
  }
  return Sn(t, [{
    key: "addNamespaces",
    value: function(i) {
      this.options.ns.indexOf(i) < 0 && this.options.ns.push(i);
    }
  }, {
    key: "removeNamespaces",
    value: function(i) {
      var s = this.options.ns.indexOf(i);
      s > -1 && this.options.ns.splice(s, 1);
    }
  }, {
    key: "getResource",
    value: function(i, s, a) {
      var o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, c = o.keySeparator !== void 0 ? o.keySeparator : this.options.keySeparator, l = o.ignoreJSONStructure !== void 0 ? o.ignoreJSONStructure : this.options.ignoreJSONStructure, u = [i, s];
      a && typeof a != "string" && (u = u.concat(a)), a && typeof a == "string" && (u = u.concat(c ? a.split(c) : a)), i.indexOf(".") > -1 && (u = i.split("."));
      var f = Va(this.data, u);
      return f || !l || typeof a != "string" ? f : Zg(this.data && this.data[i] && this.data[i][s], a, c);
    }
  }, {
    key: "addResource",
    value: function(i, s, a, o) {
      var c = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
        silent: !1
      }, l = this.options.keySeparator;
      l === void 0 && (l = ".");
      var u = [i, s];
      a && (u = u.concat(l ? a.split(l) : a)), i.indexOf(".") > -1 && (u = i.split("."), o = s, s = u[1]), this.addNamespaces(s), Sf(this.data, u, o), c.silent || this.emit("added", i, s, a, o);
    }
  }, {
    key: "addResources",
    value: function(i, s, a) {
      var o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
        silent: !1
      };
      for (var c in a)
        (typeof a[c] == "string" || Object.prototype.toString.apply(a[c]) === "[object Array]") && this.addResource(i, s, c, a[c], {
          silent: !0
        });
      o.silent || this.emit("added", i, s, a);
    }
  }, {
    key: "addResourceBundle",
    value: function(i, s, a, o, c) {
      var l = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
        silent: !1
      }, u = [i, s];
      i.indexOf(".") > -1 && (u = i.split("."), o = a, a = s, s = u[1]), this.addNamespaces(s);
      var f = Va(this.data, u) || {};
      o ? Gg(f, a, c) : f = $s($s({}, f), a), Sf(this.data, u, f), l.silent || this.emit("added", i, s, a);
    }
  }, {
    key: "removeResourceBundle",
    value: function(i, s) {
      this.hasResourceBundle(i, s) && delete this.data[i][s], this.removeNamespaces(s), this.emit("removed", i, s);
    }
  }, {
    key: "hasResourceBundle",
    value: function(i, s) {
      return this.getResource(i, s) !== void 0;
    }
  }, {
    key: "getResourceBundle",
    value: function(i, s) {
      return s || (s = this.options.defaultNS), this.options.compatibilityAPI === "v1" ? $s($s({}, {}), this.getResource(i, s)) : this.getResource(i, s);
    }
  }, {
    key: "getDataByLanguage",
    value: function(i) {
      return this.data[i];
    }
  }, {
    key: "hasLanguageSomeTranslations",
    value: function(i) {
      var s = this.getDataByLanguage(i), a = s && Object.keys(s) || [];
      return !!a.find(function(o) {
        return s[o] && Object.keys(s[o]).length > 0;
      });
    }
  }, {
    key: "toJSON",
    value: function() {
      return this.data;
    }
  }]), t;
}(Fr), Jg = {
  processors: {},
  addPostProcessor: function(e) {
    this.processors[e.name] = e;
  },
  handle: function(e, t, r, i, s) {
    var a = this;
    return e.forEach(function(o) {
      a.processors[o] && (t = a.processors[o].process(t, r, i, s));
    }), t;
  }
};
function Af(n, e) {
  var t = Object.keys(n);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(n);
    e && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(n, i).enumerable;
    })), t.push.apply(t, r);
  }
  return t;
}
function zt(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Af(Object(t), !0).forEach(function(r) {
      tr(n, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t)) : Af(Object(t)).forEach(function(r) {
      Object.defineProperty(n, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return n;
}
function vx(n) {
  var e = bx();
  return function() {
    var r = Qn(n), i;
    if (e) {
      var s = Qn(this).constructor;
      i = Reflect.construct(r, arguments, s);
    } else
      i = r.apply(this, arguments);
    return Hs(this, i);
  };
}
function bx() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
var Pf = {}, kf = function(n) {
  mo(t, n);
  var e = vx(t);
  function t(r) {
    var i, s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return xn(this, t), i = e.call(this), go && Fr.call(Dr(i)), ux(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], r, Dr(i)), i.options = s, i.options.keySeparator === void 0 && (i.options.keySeparator = "."), i.logger = Gn.create("translator"), i;
  }
  return Sn(t, [{
    key: "changeLanguage",
    value: function(i) {
      i && (this.language = i);
    }
  }, {
    key: "exists",
    value: function(i) {
      var s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        interpolation: {}
      };
      if (i == null)
        return !1;
      var a = this.resolve(i, s);
      return a && a.res !== void 0;
    }
  }, {
    key: "extractFromKey",
    value: function(i, s) {
      var a = s.nsSeparator !== void 0 ? s.nsSeparator : this.options.nsSeparator;
      a === void 0 && (a = ":");
      var o = s.keySeparator !== void 0 ? s.keySeparator : this.options.keySeparator, c = s.ns || this.options.defaultNS || [], l = a && i.indexOf(a) > -1, u = !this.options.userDefinedKeySeparator && !s.keySeparator && !this.options.userDefinedNsSeparator && !s.nsSeparator && !mx(i, a, o);
      if (l && !u) {
        var f = i.match(this.interpolator.nestingRegexp);
        if (f && f.length > 0)
          return {
            key: i,
            namespaces: c
          };
        var m = i.split(a);
        (a !== o || a === o && this.options.ns.indexOf(m[0]) > -1) && (c = m.shift()), i = m.join(o);
      }
      return typeof c == "string" && (c = [c]), {
        key: i,
        namespaces: c
      };
    }
  }, {
    key: "translate",
    value: function(i, s, a) {
      var o = this;
      if (Rn(s) !== "object" && this.options.overloadTranslationOptionHandler && (s = this.options.overloadTranslationOptionHandler(arguments)), s || (s = {}), i == null)
        return "";
      Array.isArray(i) || (i = [String(i)]);
      var c = s.returnDetails !== void 0 ? s.returnDetails : this.options.returnDetails, l = s.keySeparator !== void 0 ? s.keySeparator : this.options.keySeparator, u = this.extractFromKey(i[i.length - 1], s), f = u.key, m = u.namespaces, y = m[m.length - 1], _ = s.lng || this.language, v = s.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
      if (_ && _.toLowerCase() === "cimode") {
        if (v) {
          var C = s.nsSeparator || this.options.nsSeparator;
          return c ? (A.res = "".concat(y).concat(C).concat(f), A) : "".concat(y).concat(C).concat(f);
        }
        return c ? (A.res = f, A) : f;
      }
      var A = this.resolve(i, s), R = A && A.res, I = A && A.usedKey || f, D = A && A.exactUsedKey || f, L = Object.prototype.toString.apply(R), V = ["[object Number]", "[object Function]", "[object RegExp]"], F = s.joinArrays !== void 0 ? s.joinArrays : this.options.joinArrays, U = !this.i18nFormat || this.i18nFormat.handleAsObject, Y = typeof R != "string" && typeof R != "boolean" && typeof R != "number";
      if (U && R && Y && V.indexOf(L) < 0 && !(typeof F == "string" && L === "[object Array]")) {
        if (!s.returnObjects && !this.options.returnObjects) {
          this.options.returnedObjectHandler || this.logger.warn("accessing an object - but returnObjects options is not enabled!");
          var Q = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(I, R, zt(zt({}, s), {}, {
            ns: m
          })) : "key '".concat(f, " (").concat(this.language, ")' returned an object instead of string.");
          return c ? (A.res = Q, A) : Q;
        }
        if (l) {
          var O = L === "[object Array]", B = O ? [] : {}, P = O ? D : I;
          for (var d in R)
            if (Object.prototype.hasOwnProperty.call(R, d)) {
              var h = "".concat(P).concat(l).concat(d);
              B[d] = this.translate(h, zt(zt({}, s), {
                joinArrays: !1,
                ns: m
              })), B[d] === h && (B[d] = R[d]);
            }
          R = B;
        }
      } else if (U && typeof F == "string" && L === "[object Array]")
        R = R.join(F), R && (R = this.extendTranslation(R, i, s, a));
      else {
        var g = !1, E = !1, w = s.count !== void 0 && typeof s.count != "string", x = t.hasDefaultValue(s), T = w ? this.pluralResolver.getSuffix(_, s.count, s) : "", S = s["defaultValue".concat(T)] || s.defaultValue;
        !this.isValidLookup(R) && x && (g = !0, R = S), this.isValidLookup(R) || (E = !0, R = f);
        var p = s.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey, k = p && E ? void 0 : R, q = x && S !== R && this.options.updateMissing;
        if (E || g || q) {
          if (this.logger.log(q ? "updateKey" : "missingKey", _, y, f, q ? S : R), l) {
            var X = this.resolve(f, zt(zt({}, s), {}, {
              keySeparator: !1
            }));
            X && X.res && this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
          }
          var W = [], se = this.languageUtils.getFallbackCodes(this.options.fallbackLng, s.lng || this.language);
          if (this.options.saveMissingTo === "fallback" && se && se[0])
            for (var ce = 0; ce < se.length; ce++)
              W.push(se[ce]);
          else
            this.options.saveMissingTo === "all" ? W = this.languageUtils.toResolveHierarchy(s.lng || this.language) : W.push(s.lng || this.language);
          var le = function(de, me, Re) {
            var be = x && Re !== R ? Re : k;
            o.options.missingKeyHandler ? o.options.missingKeyHandler(de, y, me, be, q, s) : o.backendConnector && o.backendConnector.saveMissing && o.backendConnector.saveMissing(de, y, me, be, q, s), o.emit("missingKey", de, y, me, R);
          };
          this.options.saveMissing && (this.options.saveMissingPlurals && w ? W.forEach(function(De) {
            o.pluralResolver.getSuffixes(De, s).forEach(function(de) {
              le([De], f + de, s["defaultValue".concat(de)] || S);
            });
          }) : le(W, f, S));
        }
        R = this.extendTranslation(R, i, s, A, a), E && R === f && this.options.appendNamespaceToMissingKey && (R = "".concat(y, ":").concat(f)), (E || g) && this.options.parseMissingKeyHandler && (this.options.compatibilityAPI !== "v1" ? R = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? "".concat(y, ":").concat(f) : f, g ? R : void 0) : R = this.options.parseMissingKeyHandler(R));
      }
      return c ? (A.res = R, A) : R;
    }
  }, {
    key: "extendTranslation",
    value: function(i, s, a, o, c) {
      var l = this;
      if (this.i18nFormat && this.i18nFormat.parse)
        i = this.i18nFormat.parse(i, zt(zt({}, this.options.interpolation.defaultVariables), a), o.usedLng, o.usedNS, o.usedKey, {
          resolved: o
        });
      else if (!a.skipInterpolation) {
        a.interpolation && this.interpolator.init(zt(zt({}, a), {
          interpolation: zt(zt({}, this.options.interpolation), a.interpolation)
        }));
        var u = typeof i == "string" && (a && a.interpolation && a.interpolation.skipOnVariables !== void 0 ? a.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables), f;
        if (u) {
          var m = i.match(this.interpolator.nestingRegexp);
          f = m && m.length;
        }
        var y = a.replace && typeof a.replace != "string" ? a.replace : a;
        if (this.options.interpolation.defaultVariables && (y = zt(zt({}, this.options.interpolation.defaultVariables), y)), i = this.interpolator.interpolate(i, y, a.lng || this.language, a), u) {
          var _ = i.match(this.interpolator.nestingRegexp), v = _ && _.length;
          f < v && (a.nest = !1);
        }
        a.nest !== !1 && (i = this.interpolator.nest(i, function() {
          for (var R = arguments.length, I = new Array(R), D = 0; D < R; D++)
            I[D] = arguments[D];
          return c && c[0] === I[0] && !a.context ? (l.logger.warn("It seems you are nesting recursively key: ".concat(I[0], " in key: ").concat(s[0])), null) : l.translate.apply(l, I.concat([s]));
        }, a)), a.interpolation && this.interpolator.reset();
      }
      var C = a.postProcess || this.options.postProcess, A = typeof C == "string" ? [C] : C;
      return i != null && A && A.length && a.applyPostProcessor !== !1 && (i = Jg.handle(A, i, s, this.options && this.options.postProcessPassResolved ? zt({
        i18nResolved: o
      }, a) : a, this)), i;
    }
  }, {
    key: "resolve",
    value: function(i) {
      var s = this, a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, o, c, l, u, f;
      return typeof i == "string" && (i = [i]), i.forEach(function(m) {
        if (!s.isValidLookup(o)) {
          var y = s.extractFromKey(m, a), _ = y.key;
          c = _;
          var v = y.namespaces;
          s.options.fallbackNS && (v = v.concat(s.options.fallbackNS));
          var C = a.count !== void 0 && typeof a.count != "string", A = C && !a.ordinal && a.count === 0 && s.pluralResolver.shouldUseIntlApi(), R = a.context !== void 0 && (typeof a.context == "string" || typeof a.context == "number") && a.context !== "", I = a.lngs ? a.lngs : s.languageUtils.toResolveHierarchy(a.lng || s.language, a.fallbackLng);
          v.forEach(function(D) {
            s.isValidLookup(o) || (f = D, !Pf["".concat(I[0], "-").concat(D)] && s.utils && s.utils.hasLoadedNamespace && !s.utils.hasLoadedNamespace(f) && (Pf["".concat(I[0], "-").concat(D)] = !0, s.logger.warn('key "'.concat(c, '" for languages "').concat(I.join(", "), `" won't get resolved as namespace "`).concat(f, '" was not yet loaded'), "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!")), I.forEach(function(L) {
              if (!s.isValidLookup(o)) {
                u = L;
                var V = [_];
                if (s.i18nFormat && s.i18nFormat.addLookupKeys)
                  s.i18nFormat.addLookupKeys(V, _, L, D, a);
                else {
                  var F;
                  C && (F = s.pluralResolver.getSuffix(L, a.count, a));
                  var U = "".concat(s.options.pluralSeparator, "zero");
                  if (C && (V.push(_ + F), A && V.push(_ + U)), R) {
                    var Y = "".concat(_).concat(s.options.contextSeparator).concat(a.context);
                    V.push(Y), C && (V.push(Y + F), A && V.push(Y + U));
                  }
                }
                for (var Q; Q = V.pop(); )
                  s.isValidLookup(o) || (l = Q, o = s.getResource(L, D, Q, a));
              }
            }));
          });
        }
      }), {
        res: o,
        usedKey: c,
        exactUsedKey: l,
        usedLng: u,
        usedNS: f
      };
    }
  }, {
    key: "isValidLookup",
    value: function(i) {
      return i !== void 0 && !(!this.options.returnNull && i === null) && !(!this.options.returnEmptyString && i === "");
    }
  }, {
    key: "getResource",
    value: function(i, s, a) {
      var o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      return this.i18nFormat && this.i18nFormat.getResource ? this.i18nFormat.getResource(i, s, a, o) : this.resourceStore.getResource(i, s, a, o);
    }
  }], [{
    key: "hasDefaultValue",
    value: function(i) {
      var s = "defaultValue";
      for (var a in i)
        if (Object.prototype.hasOwnProperty.call(i, a) && s === a.substring(0, s.length) && i[a] !== void 0)
          return !0;
      return !1;
    }
  }]), t;
}(Fr);
function cc(n) {
  return n.charAt(0).toUpperCase() + n.slice(1);
}
var wx = function() {
  function n(e) {
    xn(this, n), this.options = e, this.supportedLngs = this.options.supportedLngs || !1, this.logger = Gn.create("languageUtils");
  }
  return Sn(n, [{
    key: "getScriptPartFromCode",
    value: function(t) {
      if (!t || t.indexOf("-") < 0)
        return null;
      var r = t.split("-");
      return r.length === 2 || (r.pop(), r[r.length - 1].toLowerCase() === "x") ? null : this.formatLanguageCode(r.join("-"));
    }
  }, {
    key: "getLanguagePartFromCode",
    value: function(t) {
      if (!t || t.indexOf("-") < 0)
        return t;
      var r = t.split("-");
      return this.formatLanguageCode(r[0]);
    }
  }, {
    key: "formatLanguageCode",
    value: function(t) {
      if (typeof t == "string" && t.indexOf("-") > -1) {
        var r = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"], i = t.split("-");
        return this.options.lowerCaseLng ? i = i.map(function(s) {
          return s.toLowerCase();
        }) : i.length === 2 ? (i[0] = i[0].toLowerCase(), i[1] = i[1].toUpperCase(), r.indexOf(i[1].toLowerCase()) > -1 && (i[1] = cc(i[1].toLowerCase()))) : i.length === 3 && (i[0] = i[0].toLowerCase(), i[1].length === 2 && (i[1] = i[1].toUpperCase()), i[0] !== "sgn" && i[2].length === 2 && (i[2] = i[2].toUpperCase()), r.indexOf(i[1].toLowerCase()) > -1 && (i[1] = cc(i[1].toLowerCase())), r.indexOf(i[2].toLowerCase()) > -1 && (i[2] = cc(i[2].toLowerCase()))), i.join("-");
      }
      return this.options.cleanCode || this.options.lowerCaseLng ? t.toLowerCase() : t;
    }
  }, {
    key: "isSupportedCode",
    value: function(t) {
      return (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) && (t = this.getLanguagePartFromCode(t)), !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(t) > -1;
    }
  }, {
    key: "getBestMatchFromCodes",
    value: function(t) {
      var r = this;
      if (!t)
        return null;
      var i;
      return t.forEach(function(s) {
        if (!i) {
          var a = r.formatLanguageCode(s);
          (!r.options.supportedLngs || r.isSupportedCode(a)) && (i = a);
        }
      }), !i && this.options.supportedLngs && t.forEach(function(s) {
        if (!i) {
          var a = r.getLanguagePartFromCode(s);
          if (r.isSupportedCode(a))
            return i = a;
          i = r.options.supportedLngs.find(function(o) {
            if (o.indexOf(a) === 0)
              return o;
          });
        }
      }), i || (i = this.getFallbackCodes(this.options.fallbackLng)[0]), i;
    }
  }, {
    key: "getFallbackCodes",
    value: function(t, r) {
      if (!t)
        return [];
      if (typeof t == "function" && (t = t(r)), typeof t == "string" && (t = [t]), Object.prototype.toString.apply(t) === "[object Array]")
        return t;
      if (!r)
        return t.default || [];
      var i = t[r];
      return i || (i = t[this.getScriptPartFromCode(r)]), i || (i = t[this.formatLanguageCode(r)]), i || (i = t[this.getLanguagePartFromCode(r)]), i || (i = t.default), i || [];
    }
  }, {
    key: "toResolveHierarchy",
    value: function(t, r) {
      var i = this, s = this.getFallbackCodes(r || this.options.fallbackLng || [], t), a = [], o = function(l) {
        l && (i.isSupportedCode(l) ? a.push(l) : i.logger.warn("rejecting language code not found in supportedLngs: ".concat(l)));
      };
      return typeof t == "string" && t.indexOf("-") > -1 ? (this.options.load !== "languageOnly" && o(this.formatLanguageCode(t)), this.options.load !== "languageOnly" && this.options.load !== "currentOnly" && o(this.getScriptPartFromCode(t)), this.options.load !== "currentOnly" && o(this.getLanguagePartFromCode(t))) : typeof t == "string" && o(this.formatLanguageCode(t)), s.forEach(function(c) {
        a.indexOf(c) < 0 && o(i.formatLanguageCode(c));
      }), a;
    }
  }]), n;
}(), xx = [{
  lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "tl", "ti", "tr", "uz", "wa"],
  nr: [1, 2],
  fc: 1
}, {
  lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kk", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
  nr: [1, 2],
  fc: 2
}, {
  lngs: ["ay", "bo", "cgg", "fa", "ht", "id", "ja", "jbo", "ka", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
  nr: [1],
  fc: 3
}, {
  lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
  nr: [1, 2, 5],
  fc: 4
}, {
  lngs: ["ar"],
  nr: [0, 1, 2, 3, 11, 100],
  fc: 5
}, {
  lngs: ["cs", "sk"],
  nr: [1, 2, 5],
  fc: 6
}, {
  lngs: ["csb", "pl"],
  nr: [1, 2, 5],
  fc: 7
}, {
  lngs: ["cy"],
  nr: [1, 2, 3, 8],
  fc: 8
}, {
  lngs: ["fr"],
  nr: [1, 2],
  fc: 9
}, {
  lngs: ["ga"],
  nr: [1, 2, 3, 7, 11],
  fc: 10
}, {
  lngs: ["gd"],
  nr: [1, 2, 3, 20],
  fc: 11
}, {
  lngs: ["is"],
  nr: [1, 2],
  fc: 12
}, {
  lngs: ["jv"],
  nr: [0, 1],
  fc: 13
}, {
  lngs: ["kw"],
  nr: [1, 2, 3, 4],
  fc: 14
}, {
  lngs: ["lt"],
  nr: [1, 2, 10],
  fc: 15
}, {
  lngs: ["lv"],
  nr: [1, 2, 0],
  fc: 16
}, {
  lngs: ["mk"],
  nr: [1, 2],
  fc: 17
}, {
  lngs: ["mnk"],
  nr: [0, 1, 2],
  fc: 18
}, {
  lngs: ["mt"],
  nr: [1, 2, 11, 20],
  fc: 19
}, {
  lngs: ["or"],
  nr: [2, 1],
  fc: 2
}, {
  lngs: ["ro"],
  nr: [1, 2, 20],
  fc: 20
}, {
  lngs: ["sl"],
  nr: [5, 1, 2, 3],
  fc: 21
}, {
  lngs: ["he", "iw"],
  nr: [1, 2, 20, 21],
  fc: 22
}], Sx = {
  1: function(e) {
    return +(e > 1);
  },
  2: function(e) {
    return +(e != 1);
  },
  3: function(e) {
    return 0;
  },
  4: function(e) {
    return e % 10 == 1 && e % 100 != 11 ? 0 : e % 10 >= 2 && e % 10 <= 4 && (e % 100 < 10 || e % 100 >= 20) ? 1 : 2;
  },
  5: function(e) {
    return e == 0 ? 0 : e == 1 ? 1 : e == 2 ? 2 : e % 100 >= 3 && e % 100 <= 10 ? 3 : e % 100 >= 11 ? 4 : 5;
  },
  6: function(e) {
    return e == 1 ? 0 : e >= 2 && e <= 4 ? 1 : 2;
  },
  7: function(e) {
    return e == 1 ? 0 : e % 10 >= 2 && e % 10 <= 4 && (e % 100 < 10 || e % 100 >= 20) ? 1 : 2;
  },
  8: function(e) {
    return e == 1 ? 0 : e == 2 ? 1 : e != 8 && e != 11 ? 2 : 3;
  },
  9: function(e) {
    return +(e >= 2);
  },
  10: function(e) {
    return e == 1 ? 0 : e == 2 ? 1 : e < 7 ? 2 : e < 11 ? 3 : 4;
  },
  11: function(e) {
    return e == 1 || e == 11 ? 0 : e == 2 || e == 12 ? 1 : e > 2 && e < 20 ? 2 : 3;
  },
  12: function(e) {
    return +(e % 10 != 1 || e % 100 == 11);
  },
  13: function(e) {
    return +(e !== 0);
  },
  14: function(e) {
    return e == 1 ? 0 : e == 2 ? 1 : e == 3 ? 2 : 3;
  },
  15: function(e) {
    return e % 10 == 1 && e % 100 != 11 ? 0 : e % 10 >= 2 && (e % 100 < 10 || e % 100 >= 20) ? 1 : 2;
  },
  16: function(e) {
    return e % 10 == 1 && e % 100 != 11 ? 0 : e !== 0 ? 1 : 2;
  },
  17: function(e) {
    return e == 1 || e % 10 == 1 && e % 100 != 11 ? 0 : 1;
  },
  18: function(e) {
    return e == 0 ? 0 : e == 1 ? 1 : 2;
  },
  19: function(e) {
    return e == 1 ? 0 : e == 0 || e % 100 > 1 && e % 100 < 11 ? 1 : e % 100 > 10 && e % 100 < 20 ? 2 : 3;
  },
  20: function(e) {
    return e == 1 ? 0 : e == 0 || e % 100 > 0 && e % 100 < 20 ? 1 : 2;
  },
  21: function(e) {
    return e % 100 == 1 ? 1 : e % 100 == 2 ? 2 : e % 100 == 3 || e % 100 == 4 ? 3 : 0;
  },
  22: function(e) {
    return e == 1 ? 0 : e == 2 ? 1 : (e < 0 || e > 10) && e % 10 == 0 ? 2 : 3;
  }
}, Ex = ["v1", "v2", "v3"], Tf = {
  zero: 0,
  one: 1,
  two: 2,
  few: 3,
  many: 4,
  other: 5
};
function Cx() {
  var n = {};
  return xx.forEach(function(e) {
    e.lngs.forEach(function(t) {
      n[t] = {
        numbers: e.nr,
        plurals: Sx[e.fc]
      };
    });
  }), n;
}
var Ax = function() {
  function n(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    xn(this, n), this.languageUtils = e, this.options = t, this.logger = Gn.create("pluralResolver"), (!this.options.compatibilityJSON || this.options.compatibilityJSON === "v4") && (typeof Intl > "u" || !Intl.PluralRules) && (this.options.compatibilityJSON = "v3", this.logger.error("Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.")), this.rules = Cx();
  }
  return Sn(n, [{
    key: "addRule",
    value: function(t, r) {
      this.rules[t] = r;
    }
  }, {
    key: "getRule",
    value: function(t) {
      var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (this.shouldUseIntlApi())
        try {
          return new Intl.PluralRules(t, {
            type: r.ordinal ? "ordinal" : "cardinal"
          });
        } catch {
          return;
        }
      return this.rules[t] || this.rules[this.languageUtils.getLanguagePartFromCode(t)];
    }
  }, {
    key: "needsPlural",
    value: function(t) {
      var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, i = this.getRule(t, r);
      return this.shouldUseIntlApi() ? i && i.resolvedOptions().pluralCategories.length > 1 : i && i.numbers.length > 1;
    }
  }, {
    key: "getPluralFormsOfKey",
    value: function(t, r) {
      var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      return this.getSuffixes(t, i).map(function(s) {
        return "".concat(r).concat(s);
      });
    }
  }, {
    key: "getSuffixes",
    value: function(t) {
      var r = this, i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, s = this.getRule(t, i);
      return s ? this.shouldUseIntlApi() ? s.resolvedOptions().pluralCategories.sort(function(a, o) {
        return Tf[a] - Tf[o];
      }).map(function(a) {
        return "".concat(r.options.prepend).concat(a);
      }) : s.numbers.map(function(a) {
        return r.getSuffix(t, a, i);
      }) : [];
    }
  }, {
    key: "getSuffix",
    value: function(t, r) {
      var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, s = this.getRule(t, i);
      return s ? this.shouldUseIntlApi() ? "".concat(this.options.prepend).concat(s.select(r)) : this.getSuffixRetroCompatible(s, r) : (this.logger.warn("no plural rule found for: ".concat(t)), "");
    }
  }, {
    key: "getSuffixRetroCompatible",
    value: function(t, r) {
      var i = this, s = t.noAbs ? t.plurals(r) : t.plurals(Math.abs(r)), a = t.numbers[s];
      this.options.simplifyPluralSuffix && t.numbers.length === 2 && t.numbers[0] === 1 && (a === 2 ? a = "plural" : a === 1 && (a = ""));
      var o = function() {
        return i.options.prepend && a.toString() ? i.options.prepend + a.toString() : a.toString();
      };
      return this.options.compatibilityJSON === "v1" ? a === 1 ? "" : typeof a == "number" ? "_plural_".concat(a.toString()) : o() : this.options.compatibilityJSON === "v2" || this.options.simplifyPluralSuffix && t.numbers.length === 2 && t.numbers[0] === 1 ? o() : this.options.prepend && s.toString() ? this.options.prepend + s.toString() : s.toString();
    }
  }, {
    key: "shouldUseIntlApi",
    value: function() {
      return !Ex.includes(this.options.compatibilityJSON);
    }
  }]), n;
}();
function Nf(n, e) {
  var t = Object.keys(n);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(n);
    e && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(n, i).enumerable;
    })), t.push.apply(t, r);
  }
  return t;
}
function En(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Nf(Object(t), !0).forEach(function(r) {
      tr(n, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t)) : Nf(Object(t)).forEach(function(r) {
      Object.defineProperty(n, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return n;
}
var Px = function() {
  function n() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    xn(this, n), this.logger = Gn.create("interpolator"), this.options = e, this.format = e.interpolation && e.interpolation.format || function(t) {
      return t;
    }, this.init(e);
  }
  return Sn(n, [{
    key: "init",
    value: function() {
      var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      t.interpolation || (t.interpolation = {
        escapeValue: !0
      });
      var r = t.interpolation;
      this.escape = r.escape !== void 0 ? r.escape : hx, this.escapeValue = r.escapeValue !== void 0 ? r.escapeValue : !0, this.useRawValueToEscape = r.useRawValueToEscape !== void 0 ? r.useRawValueToEscape : !1, this.prefix = r.prefix ? ui(r.prefix) : r.prefixEscaped || "{{", this.suffix = r.suffix ? ui(r.suffix) : r.suffixEscaped || "}}", this.formatSeparator = r.formatSeparator ? r.formatSeparator : r.formatSeparator || ",", this.unescapePrefix = r.unescapeSuffix ? "" : r.unescapePrefix || "-", this.unescapeSuffix = this.unescapePrefix ? "" : r.unescapeSuffix || "", this.nestingPrefix = r.nestingPrefix ? ui(r.nestingPrefix) : r.nestingPrefixEscaped || ui("$t("), this.nestingSuffix = r.nestingSuffix ? ui(r.nestingSuffix) : r.nestingSuffixEscaped || ui(")"), this.nestingOptionsSeparator = r.nestingOptionsSeparator ? r.nestingOptionsSeparator : r.nestingOptionsSeparator || ",", this.maxReplaces = r.maxReplaces ? r.maxReplaces : 1e3, this.alwaysFormat = r.alwaysFormat !== void 0 ? r.alwaysFormat : !1, this.resetRegExp();
    }
  }, {
    key: "reset",
    value: function() {
      this.options && this.init(this.options);
    }
  }, {
    key: "resetRegExp",
    value: function() {
      var t = "".concat(this.prefix, "(.+?)").concat(this.suffix);
      this.regexp = new RegExp(t, "g");
      var r = "".concat(this.prefix).concat(this.unescapePrefix, "(.+?)").concat(this.unescapeSuffix).concat(this.suffix);
      this.regexpUnescape = new RegExp(r, "g");
      var i = "".concat(this.nestingPrefix, "(.+?)").concat(this.nestingSuffix);
      this.nestingRegexp = new RegExp(i, "g");
    }
  }, {
    key: "interpolate",
    value: function(t, r, i, s) {
      var a = this, o, c, l, u = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
      function f(C) {
        return C.replace(/\$/g, "$$$$");
      }
      var m = function(A) {
        if (A.indexOf(a.formatSeparator) < 0) {
          var R = Ef(r, u, A);
          return a.alwaysFormat ? a.format(R, void 0, i, En(En(En({}, s), r), {}, {
            interpolationkey: A
          })) : R;
        }
        var I = A.split(a.formatSeparator), D = I.shift().trim(), L = I.join(a.formatSeparator).trim();
        return a.format(Ef(r, u, D), L, i, En(En(En({}, s), r), {}, {
          interpolationkey: D
        }));
      };
      this.resetRegExp();
      var y = s && s.missingInterpolationHandler || this.options.missingInterpolationHandler, _ = s && s.interpolation && s.interpolation.skipOnVariables !== void 0 ? s.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables, v = [{
        regex: this.regexpUnescape,
        safeValue: function(A) {
          return f(A);
        }
      }, {
        regex: this.regexp,
        safeValue: function(A) {
          return a.escapeValue ? f(a.escape(A)) : f(A);
        }
      }];
      return v.forEach(function(C) {
        for (l = 0; o = C.regex.exec(t); ) {
          var A = o[1].trim();
          if (c = m(A), c === void 0)
            if (typeof y == "function") {
              var R = y(t, o, s);
              c = typeof R == "string" ? R : "";
            } else if (s && s.hasOwnProperty(A))
              c = "";
            else if (_) {
              c = o[0];
              continue;
            } else
              a.logger.warn("missed to pass in variable ".concat(A, " for interpolating ").concat(t)), c = "";
          else
            typeof c != "string" && !a.useRawValueToEscape && (c = xf(c));
          var I = C.safeValue(c);
          if (t = t.replace(o[0], I), _ ? (C.regex.lastIndex += c.length, C.regex.lastIndex -= o[0].length) : C.regex.lastIndex = 0, l++, l >= a.maxReplaces)
            break;
        }
      }), t;
    }
  }, {
    key: "nest",
    value: function(t, r) {
      var i = this, s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, a, o, c = En({}, s);
      c.applyPostProcessor = !1, delete c.defaultValue;
      function l(y, _) {
        var v = this.nestingOptionsSeparator;
        if (y.indexOf(v) < 0)
          return y;
        var C = y.split(new RegExp("".concat(v, "[ ]*{"))), A = "{".concat(C[1]);
        y = C[0], A = this.interpolate(A, c);
        var R = A.match(/'/g), I = A.match(/"/g);
        (R && R.length % 2 === 0 && !I || I.length % 2 !== 0) && (A = A.replace(/'/g, '"'));
        try {
          c = JSON.parse(A), _ && (c = En(En({}, _), c));
        } catch (D) {
          return this.logger.warn("failed parsing options string in nesting for key ".concat(y), D), "".concat(y).concat(v).concat(A);
        }
        return delete c.defaultValue, y;
      }
      for (; a = this.nestingRegexp.exec(t); ) {
        var u = [], f = !1;
        if (a[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(a[1])) {
          var m = a[1].split(this.formatSeparator).map(function(y) {
            return y.trim();
          });
          a[1] = m.shift(), u = m, f = !0;
        }
        if (o = r(l.call(this, a[1].trim(), c), c), o && a[0] === t && typeof o != "string")
          return o;
        typeof o != "string" && (o = xf(o)), o || (this.logger.warn("missed to resolve ".concat(a[1], " for nesting ").concat(t)), o = ""), f && (o = u.reduce(function(y, _) {
          return i.format(y, _, s.lng, En(En({}, s), {}, {
            interpolationkey: a[1].trim()
          }));
        }, o.trim())), t = t.replace(a[0], o), this.regexp.lastIndex = 0;
      }
      return t;
    }
  }]), n;
}();
function Rf(n, e) {
  var t = Object.keys(n);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(n);
    e && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(n, i).enumerable;
    })), t.push.apply(t, r);
  }
  return t;
}
function Sr(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Rf(Object(t), !0).forEach(function(r) {
      tr(n, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t)) : Rf(Object(t)).forEach(function(r) {
      Object.defineProperty(n, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return n;
}
function kx(n) {
  var e = n.toLowerCase().trim(), t = {};
  if (n.indexOf("(") > -1) {
    var r = n.split("(");
    e = r[0].toLowerCase().trim();
    var i = r[1].substring(0, r[1].length - 1);
    if (e === "currency" && i.indexOf(":") < 0)
      t.currency || (t.currency = i.trim());
    else if (e === "relativetime" && i.indexOf(":") < 0)
      t.range || (t.range = i.trim());
    else {
      var s = i.split(";");
      s.forEach(function(a) {
        if (a) {
          var o = a.split(":"), c = ox(o), l = c[0], u = c.slice(1), f = u.join(":").trim().replace(/^'+|'+$/g, "");
          t[l.trim()] || (t[l.trim()] = f), f === "false" && (t[l.trim()] = !1), f === "true" && (t[l.trim()] = !0), isNaN(f) || (t[l.trim()] = parseInt(f, 10));
        }
      });
    }
  }
  return {
    formatName: e,
    formatOptions: t
  };
}
function di(n) {
  var e = {};
  return function(r, i, s) {
    var a = i + JSON.stringify(s), o = e[a];
    return o || (o = n(i, s), e[a] = o), o(r);
  };
}
var Tx = function() {
  function n() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    xn(this, n), this.logger = Gn.create("formatter"), this.options = e, this.formats = {
      number: di(function(t, r) {
        var i = new Intl.NumberFormat(t, r);
        return function(s) {
          return i.format(s);
        };
      }),
      currency: di(function(t, r) {
        var i = new Intl.NumberFormat(t, Sr(Sr({}, r), {}, {
          style: "currency"
        }));
        return function(s) {
          return i.format(s);
        };
      }),
      datetime: di(function(t, r) {
        var i = new Intl.DateTimeFormat(t, Sr({}, r));
        return function(s) {
          return i.format(s);
        };
      }),
      relativetime: di(function(t, r) {
        var i = new Intl.RelativeTimeFormat(t, Sr({}, r));
        return function(s) {
          return i.format(s, r.range || "day");
        };
      }),
      list: di(function(t, r) {
        var i = new Intl.ListFormat(t, Sr({}, r));
        return function(s) {
          return i.format(s);
        };
      })
    }, this.init(e);
  }
  return Sn(n, [{
    key: "init",
    value: function(t) {
      var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        interpolation: {}
      }, i = r.interpolation;
      this.formatSeparator = i.formatSeparator ? i.formatSeparator : i.formatSeparator || ",";
    }
  }, {
    key: "add",
    value: function(t, r) {
      this.formats[t.toLowerCase().trim()] = r;
    }
  }, {
    key: "addCached",
    value: function(t, r) {
      this.formats[t.toLowerCase().trim()] = di(r);
    }
  }, {
    key: "format",
    value: function(t, r, i, s) {
      var a = this, o = r.split(this.formatSeparator), c = o.reduce(function(l, u) {
        var f = kx(u), m = f.formatName, y = f.formatOptions;
        if (a.formats[m]) {
          var _ = l;
          try {
            var v = s && s.formatParams && s.formatParams[s.interpolationkey] || {}, C = v.locale || v.lng || s.locale || s.lng || i;
            _ = a.formats[m](l, C, Sr(Sr(Sr({}, y), s), v));
          } catch (A) {
            a.logger.warn(A);
          }
          return _;
        } else
          a.logger.warn("there was no format function for ".concat(m));
        return l;
      }, t);
      return c;
    }
  }]), n;
}();
function If(n, e) {
  var t = Object.keys(n);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(n);
    e && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(n, i).enumerable;
    })), t.push.apply(t, r);
  }
  return t;
}
function Of(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? If(Object(t), !0).forEach(function(r) {
      tr(n, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t)) : If(Object(t)).forEach(function(r) {
      Object.defineProperty(n, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return n;
}
function Nx(n) {
  var e = Rx();
  return function() {
    var r = Qn(n), i;
    if (e) {
      var s = Qn(this).constructor;
      i = Reflect.construct(r, arguments, s);
    } else
      i = r.apply(this, arguments);
    return Hs(this, i);
  };
}
function Rx() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function Ix(n, e) {
  n.pending[e] !== void 0 && (delete n.pending[e], n.pendingCount--);
}
var Ox = function(n) {
  mo(t, n);
  var e = Nx(t);
  function t(r, i, s) {
    var a, o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    return xn(this, t), a = e.call(this), go && Fr.call(Dr(a)), a.backend = r, a.store = i, a.services = s, a.languageUtils = s.languageUtils, a.options = o, a.logger = Gn.create("backendConnector"), a.waitingReads = [], a.maxParallelReads = o.maxParallelReads || 10, a.readingCalls = 0, a.maxRetries = o.maxRetries >= 0 ? o.maxRetries : 5, a.retryTimeout = o.retryTimeout >= 1 ? o.retryTimeout : 350, a.state = {}, a.queue = [], a.backend && a.backend.init && a.backend.init(s, o.backend, o), a;
  }
  return Sn(t, [{
    key: "queueLoad",
    value: function(i, s, a, o) {
      var c = this, l = {}, u = {}, f = {}, m = {};
      return i.forEach(function(y) {
        var _ = !0;
        s.forEach(function(v) {
          var C = "".concat(y, "|").concat(v);
          !a.reload && c.store.hasResourceBundle(y, v) ? c.state[C] = 2 : c.state[C] < 0 || (c.state[C] === 1 ? u[C] === void 0 && (u[C] = !0) : (c.state[C] = 1, _ = !1, u[C] === void 0 && (u[C] = !0), l[C] === void 0 && (l[C] = !0), m[v] === void 0 && (m[v] = !0)));
        }), _ || (f[y] = !0);
      }), (Object.keys(l).length || Object.keys(u).length) && this.queue.push({
        pending: u,
        pendingCount: Object.keys(u).length,
        loaded: {},
        errors: [],
        callback: o
      }), {
        toLoad: Object.keys(l),
        pending: Object.keys(u),
        toLoadLanguages: Object.keys(f),
        toLoadNamespaces: Object.keys(m)
      };
    }
  }, {
    key: "loaded",
    value: function(i, s, a) {
      var o = i.split("|"), c = o[0], l = o[1];
      s && this.emit("failedLoading", c, l, s), a && this.store.addResourceBundle(c, l, a), this.state[i] = s ? -1 : 2;
      var u = {};
      this.queue.forEach(function(f) {
        dx(f.loaded, [c], l), Ix(f, i), s && f.errors.push(s), f.pendingCount === 0 && !f.done && (Object.keys(f.loaded).forEach(function(m) {
          u[m] || (u[m] = {});
          var y = f.loaded[m];
          y.length && y.forEach(function(_) {
            u[m][_] === void 0 && (u[m][_] = !0);
          });
        }), f.done = !0, f.errors.length ? f.callback(f.errors) : f.callback());
      }), this.emit("loaded", u), this.queue = this.queue.filter(function(f) {
        return !f.done;
      });
    }
  }, {
    key: "read",
    value: function(i, s, a) {
      var o = this, c = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, l = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : this.retryTimeout, u = arguments.length > 5 ? arguments[5] : void 0;
      if (!i.length)
        return u(null, {});
      if (this.readingCalls >= this.maxParallelReads) {
        this.waitingReads.push({
          lng: i,
          ns: s,
          fcName: a,
          tried: c,
          wait: l,
          callback: u
        });
        return;
      }
      return this.readingCalls++, this.backend[a](i, s, function(f, m) {
        if (o.readingCalls--, o.waitingReads.length > 0) {
          var y = o.waitingReads.shift();
          o.read(y.lng, y.ns, y.fcName, y.tried, y.wait, y.callback);
        }
        if (f && m && c < o.maxRetries) {
          setTimeout(function() {
            o.read.call(o, i, s, a, c + 1, l * 2, u);
          }, l);
          return;
        }
        u(f, m);
      });
    }
  }, {
    key: "prepareLoading",
    value: function(i, s) {
      var a = this, o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, c = arguments.length > 3 ? arguments[3] : void 0;
      if (!this.backend)
        return this.logger.warn("No backend was added via i18next.use. Will not load resources."), c && c();
      typeof i == "string" && (i = this.languageUtils.toResolveHierarchy(i)), typeof s == "string" && (s = [s]);
      var l = this.queueLoad(i, s, o, c);
      if (!l.toLoad.length)
        return l.pending.length || c(), null;
      l.toLoad.forEach(function(u) {
        a.loadOne(u);
      });
    }
  }, {
    key: "load",
    value: function(i, s, a) {
      this.prepareLoading(i, s, {}, a);
    }
  }, {
    key: "reload",
    value: function(i, s, a) {
      this.prepareLoading(i, s, {
        reload: !0
      }, a);
    }
  }, {
    key: "loadOne",
    value: function(i) {
      var s = this, a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "", o = i.split("|"), c = o[0], l = o[1];
      this.read(c, l, "read", void 0, void 0, function(u, f) {
        u && s.logger.warn("".concat(a, "loading namespace ").concat(l, " for language ").concat(c, " failed"), u), !u && f && s.logger.log("".concat(a, "loaded namespace ").concat(l, " for language ").concat(c), f), s.loaded(i, u, f);
      });
    }
  }, {
    key: "saveMissing",
    value: function(i, s, a, o, c) {
      var l = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
      if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(s)) {
        this.logger.warn('did not save key "'.concat(a, '" as the namespace "').concat(s, '" was not yet loaded'), "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
        return;
      }
      a == null || a === "" || (this.backend && this.backend.create && this.backend.create(i, s, a, o, null, Of(Of({}, l), {}, {
        isUpdate: c
      })), !(!i || !i[0]) && this.store.addResource(i[0], s, a, o));
    }
  }]), t;
}(Fr);
function Mx() {
  return {
    debug: !1,
    initImmediate: !0,
    ns: ["translation"],
    defaultNS: ["translation"],
    fallbackLng: ["dev"],
    fallbackNS: !1,
    supportedLngs: !1,
    nonExplicitSupportedLngs: !1,
    load: "all",
    preload: !1,
    simplifyPluralSuffix: !0,
    keySeparator: ".",
    nsSeparator: ":",
    pluralSeparator: "_",
    contextSeparator: "_",
    partialBundledLanguages: !1,
    saveMissing: !1,
    updateMissing: !1,
    saveMissingTo: "fallback",
    saveMissingPlurals: !0,
    missingKeyHandler: !1,
    missingInterpolationHandler: !1,
    postProcess: !1,
    postProcessPassResolved: !1,
    returnNull: !0,
    returnEmptyString: !0,
    returnObjects: !1,
    joinArrays: !1,
    returnedObjectHandler: !1,
    parseMissingKeyHandler: !1,
    appendNamespaceToMissingKey: !1,
    appendNamespaceToCIMode: !1,
    overloadTranslationOptionHandler: function(e) {
      var t = {};
      if (Rn(e[1]) === "object" && (t = e[1]), typeof e[1] == "string" && (t.defaultValue = e[1]), typeof e[2] == "string" && (t.tDescription = e[2]), Rn(e[2]) === "object" || Rn(e[3]) === "object") {
        var r = e[3] || e[2];
        Object.keys(r).forEach(function(i) {
          t[i] = r[i];
        });
      }
      return t;
    },
    interpolation: {
      escapeValue: !0,
      format: function(e, t, r, i) {
        return e;
      },
      prefix: "{{",
      suffix: "}}",
      formatSeparator: ",",
      unescapePrefix: "-",
      nestingPrefix: "$t(",
      nestingSuffix: ")",
      nestingOptionsSeparator: ",",
      maxReplaces: 1e3,
      skipOnVariables: !0
    }
  };
}
function Mf(n) {
  return typeof n.ns == "string" && (n.ns = [n.ns]), typeof n.fallbackLng == "string" && (n.fallbackLng = [n.fallbackLng]), typeof n.fallbackNS == "string" && (n.fallbackNS = [n.fallbackNS]), n.supportedLngs && n.supportedLngs.indexOf("cimode") < 0 && (n.supportedLngs = n.supportedLngs.concat(["cimode"])), n;
}
function Lf(n, e) {
  var t = Object.keys(n);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(n);
    e && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(n, i).enumerable;
    })), t.push.apply(t, r);
  }
  return t;
}
function Bn(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Lf(Object(t), !0).forEach(function(r) {
      tr(n, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t)) : Lf(Object(t)).forEach(function(r) {
      Object.defineProperty(n, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return n;
}
function Lx(n) {
  var e = Dx();
  return function() {
    var r = Qn(n), i;
    if (e) {
      var s = Qn(this).constructor;
      i = Reflect.construct(r, arguments, s);
    } else
      i = r.apply(this, arguments);
    return Hs(this, i);
  };
}
function Dx() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function ea() {
}
function Ux(n) {
  var e = Object.getOwnPropertyNames(Object.getPrototypeOf(n));
  e.forEach(function(t) {
    typeof n[t] == "function" && (n[t] = n[t].bind(n));
  });
}
var Ba = function(n) {
  mo(t, n);
  var e = Lx(t);
  function t() {
    var r, i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, s = arguments.length > 1 ? arguments[1] : void 0;
    if (xn(this, t), r = e.call(this), go && Fr.call(Dr(r)), r.options = Mf(i), r.services = {}, r.logger = Gn, r.modules = {
      external: []
    }, Ux(Dr(r)), s && !r.isInitialized && !i.isClone) {
      if (!r.options.initImmediate)
        return r.init(i, s), Hs(r, Dr(r));
      setTimeout(function() {
        r.init(i, s);
      }, 0);
    }
    return r;
  }
  return Sn(t, [{
    key: "init",
    value: function() {
      var i = this, s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, a = arguments.length > 1 ? arguments[1] : void 0;
      typeof s == "function" && (a = s, s = {}), !s.defaultNS && s.defaultNS !== !1 && s.ns && (typeof s.ns == "string" ? s.defaultNS = s.ns : s.ns.indexOf("translation") < 0 && (s.defaultNS = s.ns[0]));
      var o = Mx();
      this.options = Bn(Bn(Bn({}, o), this.options), Mf(s)), this.options.compatibilityAPI !== "v1" && (this.options.interpolation = Bn(Bn({}, o.interpolation), this.options.interpolation)), s.keySeparator !== void 0 && (this.options.userDefinedKeySeparator = s.keySeparator), s.nsSeparator !== void 0 && (this.options.userDefinedNsSeparator = s.nsSeparator);
      function c(A) {
        return A ? typeof A == "function" ? new A() : A : null;
      }
      if (!this.options.isClone) {
        this.modules.logger ? Gn.init(c(this.modules.logger), this.options) : Gn.init(null, this.options);
        var l;
        this.modules.formatter ? l = this.modules.formatter : typeof Intl < "u" && (l = Tx);
        var u = new wx(this.options);
        this.store = new _x(this.options.resources, this.options);
        var f = this.services;
        f.logger = Gn, f.resourceStore = this.store, f.languageUtils = u, f.pluralResolver = new Ax(u, {
          prepend: this.options.pluralSeparator,
          compatibilityJSON: this.options.compatibilityJSON,
          simplifyPluralSuffix: this.options.simplifyPluralSuffix
        }), l && (!this.options.interpolation.format || this.options.interpolation.format === o.interpolation.format) && (f.formatter = c(l), f.formatter.init(f, this.options), this.options.interpolation.format = f.formatter.format.bind(f.formatter)), f.interpolator = new Px(this.options), f.utils = {
          hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
        }, f.backendConnector = new Ox(c(this.modules.backend), f.resourceStore, f, this.options), f.backendConnector.on("*", function(A) {
          for (var R = arguments.length, I = new Array(R > 1 ? R - 1 : 0), D = 1; D < R; D++)
            I[D - 1] = arguments[D];
          i.emit.apply(i, [A].concat(I));
        }), this.modules.languageDetector && (f.languageDetector = c(this.modules.languageDetector), f.languageDetector.init(f, this.options.detection, this.options)), this.modules.i18nFormat && (f.i18nFormat = c(this.modules.i18nFormat), f.i18nFormat.init && f.i18nFormat.init(this)), this.translator = new kf(this.services, this.options), this.translator.on("*", function(A) {
          for (var R = arguments.length, I = new Array(R > 1 ? R - 1 : 0), D = 1; D < R; D++)
            I[D - 1] = arguments[D];
          i.emit.apply(i, [A].concat(I));
        }), this.modules.external.forEach(function(A) {
          A.init && A.init(i);
        });
      }
      if (this.format = this.options.interpolation.format, a || (a = ea), this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
        var m = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
        m.length > 0 && m[0] !== "dev" && (this.options.lng = m[0]);
      }
      !this.services.languageDetector && !this.options.lng && this.logger.warn("init: no languageDetector is used and no lng is defined");
      var y = ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"];
      y.forEach(function(A) {
        i[A] = function() {
          var R;
          return (R = i.store)[A].apply(R, arguments);
        };
      });
      var _ = ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"];
      _.forEach(function(A) {
        i[A] = function() {
          var R;
          return (R = i.store)[A].apply(R, arguments), i;
        };
      });
      var v = $i(), C = function() {
        var R = function(D, L) {
          i.isInitialized && !i.initializedStoreOnce && i.logger.warn("init: i18next is already initialized. You should call init just once!"), i.isInitialized = !0, i.options.isClone || i.logger.log("initialized", i.options), i.emit("initialized", i.options), v.resolve(L), a(D, L);
        };
        if (i.languages && i.options.compatibilityAPI !== "v1" && !i.isInitialized)
          return R(null, i.t.bind(i));
        i.changeLanguage(i.options.lng, R);
      };
      return this.options.resources || !this.options.initImmediate ? C() : setTimeout(C, 0), v;
    }
  }, {
    key: "loadResources",
    value: function(i) {
      var s = this, a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ea, o = a, c = typeof i == "string" ? i : this.language;
      if (typeof i == "function" && (o = i), !this.options.resources || this.options.partialBundledLanguages) {
        if (c && c.toLowerCase() === "cimode")
          return o();
        var l = [], u = function(y) {
          if (y) {
            var _ = s.services.languageUtils.toResolveHierarchy(y);
            _.forEach(function(v) {
              l.indexOf(v) < 0 && l.push(v);
            });
          }
        };
        if (c)
          u(c);
        else {
          var f = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
          f.forEach(function(m) {
            return u(m);
          });
        }
        this.options.preload && this.options.preload.forEach(function(m) {
          return u(m);
        }), this.services.backendConnector.load(l, this.options.ns, function(m) {
          !m && !s.resolvedLanguage && s.language && s.setResolvedLanguage(s.language), o(m);
        });
      } else
        o(null);
    }
  }, {
    key: "reloadResources",
    value: function(i, s, a) {
      var o = $i();
      return i || (i = this.languages), s || (s = this.options.ns), a || (a = ea), this.services.backendConnector.reload(i, s, function(c) {
        o.resolve(), a(c);
      }), o;
    }
  }, {
    key: "use",
    value: function(i) {
      if (!i)
        throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
      if (!i.type)
        throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
      return i.type === "backend" && (this.modules.backend = i), (i.type === "logger" || i.log && i.warn && i.error) && (this.modules.logger = i), i.type === "languageDetector" && (this.modules.languageDetector = i), i.type === "i18nFormat" && (this.modules.i18nFormat = i), i.type === "postProcessor" && Jg.addPostProcessor(i), i.type === "formatter" && (this.modules.formatter = i), i.type === "3rdParty" && this.modules.external.push(i), this;
    }
  }, {
    key: "setResolvedLanguage",
    value: function(i) {
      if (!(!i || !this.languages) && !(["cimode", "dev"].indexOf(i) > -1))
        for (var s = 0; s < this.languages.length; s++) {
          var a = this.languages[s];
          if (!(["cimode", "dev"].indexOf(a) > -1) && this.store.hasLanguageSomeTranslations(a)) {
            this.resolvedLanguage = a;
            break;
          }
        }
    }
  }, {
    key: "changeLanguage",
    value: function(i, s) {
      var a = this;
      this.isLanguageChangingTo = i;
      var o = $i();
      this.emit("languageChanging", i);
      var c = function(m) {
        a.language = m, a.languages = a.services.languageUtils.toResolveHierarchy(m), a.resolvedLanguage = void 0, a.setResolvedLanguage(m);
      }, l = function(m, y) {
        y ? (c(y), a.translator.changeLanguage(y), a.isLanguageChangingTo = void 0, a.emit("languageChanged", y), a.logger.log("languageChanged", y)) : a.isLanguageChangingTo = void 0, o.resolve(function() {
          return a.t.apply(a, arguments);
        }), s && s(m, function() {
          return a.t.apply(a, arguments);
        });
      }, u = function(m) {
        !i && !m && a.services.languageDetector && (m = []);
        var y = typeof m == "string" ? m : a.services.languageUtils.getBestMatchFromCodes(m);
        y && (a.language || c(y), a.translator.language || a.translator.changeLanguage(y), a.services.languageDetector && a.services.languageDetector.cacheUserLanguage(y)), a.loadResources(y, function(_) {
          l(_, y);
        });
      };
      return !i && this.services.languageDetector && !this.services.languageDetector.async ? u(this.services.languageDetector.detect()) : !i && this.services.languageDetector && this.services.languageDetector.async ? this.services.languageDetector.detect(u) : u(i), o;
    }
  }, {
    key: "getFixedT",
    value: function(i, s, a) {
      var o = this, c = function l(u, f) {
        var m;
        if (Rn(f) !== "object") {
          for (var y = arguments.length, _ = new Array(y > 2 ? y - 2 : 0), v = 2; v < y; v++)
            _[v - 2] = arguments[v];
          m = o.options.overloadTranslationOptionHandler([u, f].concat(_));
        } else
          m = Bn({}, f);
        m.lng = m.lng || l.lng, m.lngs = m.lngs || l.lngs, m.ns = m.ns || l.ns, m.keyPrefix = m.keyPrefix || a || l.keyPrefix;
        var C = o.options.keySeparator || ".", A = m.keyPrefix ? "".concat(m.keyPrefix).concat(C).concat(u) : u;
        return o.t(A, m);
      };
      return typeof i == "string" ? c.lng = i : c.lngs = i, c.ns = s, c.keyPrefix = a, c;
    }
  }, {
    key: "t",
    value: function() {
      var i;
      return this.translator && (i = this.translator).translate.apply(i, arguments);
    }
  }, {
    key: "exists",
    value: function() {
      var i;
      return this.translator && (i = this.translator).exists.apply(i, arguments);
    }
  }, {
    key: "setDefaultNamespace",
    value: function(i) {
      this.options.defaultNS = i;
    }
  }, {
    key: "hasLoadedNamespace",
    value: function(i) {
      var s = this, a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (!this.isInitialized)
        return this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages), !1;
      if (!this.languages || !this.languages.length)
        return this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages), !1;
      var o = this.resolvedLanguage || this.languages[0], c = this.options ? this.options.fallbackLng : !1, l = this.languages[this.languages.length - 1];
      if (o.toLowerCase() === "cimode")
        return !0;
      var u = function(y, _) {
        var v = s.services.backendConnector.state["".concat(y, "|").concat(_)];
        return v === -1 || v === 2;
      };
      if (a.precheck) {
        var f = a.precheck(this, u);
        if (f !== void 0)
          return f;
      }
      return !!(this.hasResourceBundle(o, i) || !this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages || u(o, i) && (!c || u(l, i)));
    }
  }, {
    key: "loadNamespaces",
    value: function(i, s) {
      var a = this, o = $i();
      return this.options.ns ? (typeof i == "string" && (i = [i]), i.forEach(function(c) {
        a.options.ns.indexOf(c) < 0 && a.options.ns.push(c);
      }), this.loadResources(function(c) {
        o.resolve(), s && s(c);
      }), o) : (s && s(), Promise.resolve());
    }
  }, {
    key: "loadLanguages",
    value: function(i, s) {
      var a = $i();
      typeof i == "string" && (i = [i]);
      var o = this.options.preload || [], c = i.filter(function(l) {
        return o.indexOf(l) < 0;
      });
      return c.length ? (this.options.preload = o.concat(c), this.loadResources(function(l) {
        a.resolve(), s && s(l);
      }), a) : (s && s(), Promise.resolve());
    }
  }, {
    key: "dir",
    value: function(i) {
      if (i || (i = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language)), !i)
        return "rtl";
      var s = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"];
      return s.indexOf(this.services.languageUtils.getLanguagePartFromCode(i)) > -1 || i.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr";
    }
  }, {
    key: "cloneInstance",
    value: function() {
      var i = this, s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ea, o = Bn(Bn(Bn({}, this.options), s), {
        isClone: !0
      }), c = new t(o);
      (s.debug !== void 0 || s.prefix !== void 0) && (c.logger = c.logger.clone(s));
      var l = ["store", "services", "language"];
      return l.forEach(function(u) {
        c[u] = i[u];
      }), c.services = Bn({}, this.services), c.services.utils = {
        hasLoadedNamespace: c.hasLoadedNamespace.bind(c)
      }, c.translator = new kf(c.services, c.options), c.translator.on("*", function(u) {
        for (var f = arguments.length, m = new Array(f > 1 ? f - 1 : 0), y = 1; y < f; y++)
          m[y - 1] = arguments[y];
        c.emit.apply(c, [u].concat(m));
      }), c.init(o, a), c.translator.options = c.options, c.translator.backendConnector.services.utils = {
        hasLoadedNamespace: c.hasLoadedNamespace.bind(c)
      }, c;
    }
  }, {
    key: "toJSON",
    value: function() {
      return {
        options: this.options,
        store: this.store,
        language: this.language,
        languages: this.languages,
        resolvedLanguage: this.resolvedLanguage
      };
    }
  }]), t;
}(Fr);
tr(Ba, "createInstance", function() {
  var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, e = arguments.length > 1 ? arguments[1] : void 0;
  return new Ba(n, e);
});
var $t = Ba.createInstance();
$t.createInstance = Ba.createInstance;
$t.createInstance;
$t.init;
$t.loadResources;
$t.reloadResources;
$t.use;
$t.changeLanguage;
$t.getFixedT;
$t.t;
$t.exists;
$t.setDefaultNamespace;
$t.hasLoadedNamespace;
$t.loadNamespaces;
$t.loadLanguages;
const Es = $t, Df = {
  debug: !1,
  fallbackLng: "en",
  resources: {
    en: {
      translation: Vg
    }
  }
}, Vx = {
  react: {
    useSuspense: !1
  }
}, Bx = {};
I2() ? Es.use(Xg).use(f2).init({ ...Df, ...Vx }) : Es.use(new qg(void 0, { reloadInterval: !1 })).use(e2).init({ ...Df, ...Bx });
function Hx(n) {
  return v2("translation", { i18n: Es, ...n });
}
var pl = function(n, e) {
  return pl = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, r) {
    t.__proto__ = r;
  } || function(t, r) {
    for (var i in r)
      Object.prototype.hasOwnProperty.call(r, i) && (t[i] = r[i]);
  }, pl(n, e);
};
function pn(n, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
  pl(n, e);
  function t() {
    this.constructor = n;
  }
  n.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
}
var ml = function() {
  return ml = Object.assign || function(e) {
    for (var t, r = 1, i = arguments.length; r < i; r++) {
      t = arguments[r];
      for (var s in t)
        Object.prototype.hasOwnProperty.call(t, s) && (e[s] = t[s]);
    }
    return e;
  }, ml.apply(this, arguments);
};
function nr(n, e, t, r) {
  function i(s) {
    return s instanceof t ? s : new t(function(a) {
      a(s);
    });
  }
  return new (t || (t = Promise))(function(s, a) {
    function o(u) {
      try {
        l(r.next(u));
      } catch (f) {
        a(f);
      }
    }
    function c(u) {
      try {
        l(r.throw(u));
      } catch (f) {
        a(f);
      }
    }
    function l(u) {
      u.done ? s(u.value) : i(u.value).then(o, c);
    }
    l((r = r.apply(n, e || [])).next());
  });
}
function Dn(n, e) {
  var t = { label: 0, sent: function() {
    if (s[0] & 1)
      throw s[1];
    return s[1];
  }, trys: [], ops: [] }, r, i, s, a;
  return a = { next: o(0), throw: o(1), return: o(2) }, typeof Symbol == "function" && (a[Symbol.iterator] = function() {
    return this;
  }), a;
  function o(l) {
    return function(u) {
      return c([l, u]);
    };
  }
  function c(l) {
    if (r)
      throw new TypeError("Generator is already executing.");
    for (; a && (a = 0, l[0] && (t = 0)), t; )
      try {
        if (r = 1, i && (s = l[0] & 2 ? i.return : l[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, l[1])).done)
          return s;
        switch (i = 0, s && (l = [l[0] & 2, s.value]), l[0]) {
          case 0:
          case 1:
            s = l;
            break;
          case 4:
            return t.label++, { value: l[1], done: !1 };
          case 5:
            t.label++, i = l[1], l = [0];
            continue;
          case 7:
            l = t.ops.pop(), t.trys.pop();
            continue;
          default:
            if (s = t.trys, !(s = s.length > 0 && s[s.length - 1]) && (l[0] === 6 || l[0] === 2)) {
              t = 0;
              continue;
            }
            if (l[0] === 3 && (!s || l[1] > s[0] && l[1] < s[3])) {
              t.label = l[1];
              break;
            }
            if (l[0] === 6 && t.label < s[1]) {
              t.label = s[1], s = l;
              break;
            }
            if (s && t.label < s[2]) {
              t.label = s[2], t.ops.push(l);
              break;
            }
            s[2] && t.ops.pop(), t.trys.pop();
            continue;
        }
        l = e.call(n, t);
      } catch (u) {
        l = [6, u], i = 0;
      } finally {
        r = s = 0;
      }
    if (l[0] & 5)
      throw l[1];
    return { value: l[0] ? l[1] : void 0, done: !0 };
  }
}
function Di(n) {
  var e = typeof Symbol == "function" && Symbol.iterator, t = e && n[e], r = 0;
  if (t)
    return t.call(n);
  if (n && typeof n.length == "number")
    return {
      next: function() {
        return n && r >= n.length && (n = void 0), { value: n && n[r++], done: !n };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function jr(n, e) {
  var t = typeof Symbol == "function" && n[Symbol.iterator];
  if (!t)
    return n;
  var r = t.call(n), i, s = [], a;
  try {
    for (; (e === void 0 || e-- > 0) && !(i = r.next()).done; )
      s.push(i.value);
  } catch (o) {
    a = { error: o };
  } finally {
    try {
      i && !i.done && (t = r.return) && t.call(r);
    } finally {
      if (a)
        throw a.error;
    }
  }
  return s;
}
function $n(n, e, t) {
  if (t || arguments.length === 2)
    for (var r = 0, i = e.length, s; r < i; r++)
      (s || !(r in e)) && (s || (s = Array.prototype.slice.call(e, 0, r)), s[r] = e[r]);
  return n.concat(s || Array.prototype.slice.call(e));
}
function Ci(n) {
  return this instanceof Ci ? (this.v = n, this) : new Ci(n);
}
function Fx(n, e, t) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var r = t.apply(n, e || []), i, s = [];
  return i = {}, a("next"), a("throw"), a("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function a(m) {
    r[m] && (i[m] = function(y) {
      return new Promise(function(_, v) {
        s.push([m, y, _, v]) > 1 || o(m, y);
      });
    });
  }
  function o(m, y) {
    try {
      c(r[m](y));
    } catch (_) {
      f(s[0][3], _);
    }
  }
  function c(m) {
    m.value instanceof Ci ? Promise.resolve(m.value.v).then(l, u) : f(s[0][2], m);
  }
  function l(m) {
    o("next", m);
  }
  function u(m) {
    o("throw", m);
  }
  function f(m, y) {
    m(y), s.shift(), s.length && o(s[0][0], s[0][1]);
  }
}
function jx(n) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var e = n[Symbol.asyncIterator], t;
  return e ? e.call(n) : (n = typeof Di == "function" ? Di(n) : n[Symbol.iterator](), t = {}, r("next"), r("throw"), r("return"), t[Symbol.asyncIterator] = function() {
    return this;
  }, t);
  function r(s) {
    t[s] = n[s] && function(a) {
      return new Promise(function(o, c) {
        a = n[s](a), i(o, c, a.done, a.value);
      });
    };
  }
  function i(s, a, o, c) {
    Promise.resolve(c).then(function(l) {
      s({ value: l, done: o });
    }, a);
  }
}
const Et = {
  silent: Number.NEGATIVE_INFINITY,
  fatal: 0,
  error: 0,
  warn: 1,
  log: 2,
  info: 3,
  success: 3,
  fail: 3,
  ready: 3,
  start: 3,
  box: 3,
  debug: 4,
  trace: 5,
  verbose: Number.POSITIVE_INFINITY
}, Uf = {
  // Silent
  silent: {
    level: -1
  },
  // Level 0
  fatal: {
    level: Et.fatal
  },
  error: {
    level: Et.error
  },
  // Level 1
  warn: {
    level: Et.warn
  },
  // Level 2
  log: {
    level: Et.log
  },
  // Level 3
  info: {
    level: Et.info
  },
  success: {
    level: Et.success
  },
  fail: {
    level: Et.fail
  },
  ready: {
    level: Et.info
  },
  start: {
    level: Et.info
  },
  box: {
    level: Et.info
  },
  // Level 4
  debug: {
    level: Et.debug
  },
  // Level 5
  trace: {
    level: Et.trace
  },
  // Verbose
  verbose: {
    level: Et.verbose
  }
};
function lc(n) {
  return n !== null && typeof n == "object";
}
function gl(n, e, t = ".", r) {
  if (!lc(e))
    return gl(n, {}, t, r);
  const i = Object.assign({}, e);
  for (const s in n) {
    if (s === "__proto__" || s === "constructor")
      continue;
    const a = n[s];
    a != null && (r && r(i, s, a, t) || (Array.isArray(a) && Array.isArray(i[s]) ? i[s] = [...a, ...i[s]] : lc(a) && lc(i[s]) ? i[s] = gl(
      a,
      i[s],
      (t ? `${t}.` : "") + s.toString(),
      r
    ) : i[s] = a));
  }
  return i;
}
function Wx(n) {
  return (...e) => (
    // eslint-disable-next-line unicorn/no-array-reduce
    e.reduce((t, r) => gl(t, r, "", n), {})
  );
}
const qx = Wx();
function zx(n) {
  return Object.prototype.toString.call(n) === "[object Object]";
}
function Xx(n) {
  return !(!zx(n) || !n.message && !n.args || n.stack);
}
let uc = !1;
const Vf = [];
class Vt {
  constructor(e = {}) {
    const t = e.types || Uf;
    this.options = qx(
      {
        ...e,
        defaults: { ...e.defaults },
        level: dc(e.level, t),
        reporters: [...e.reporters || []]
      },
      {
        types: Uf,
        throttle: 1e3,
        throttleMin: 5,
        formatOptions: {
          date: !0,
          colors: !1,
          compact: !0
        }
      }
    );
    for (const r in t) {
      const i = {
        type: r,
        ...this.options.defaults,
        ...t[r]
      };
      this[r] = this._wrapLogFn(i), this[r].raw = this._wrapLogFn(
        i,
        !0
      );
    }
    this.options.mockFn && this.mockTypes(), this._lastLog = {};
  }
  get level() {
    return this.options.level;
  }
  set level(e) {
    this.options.level = dc(
      e,
      this.options.types,
      this.options.level
    );
  }
  prompt(e, t) {
    if (!this.options.prompt)
      throw new Error("prompt is not supported!");
    return this.options.prompt(e, t);
  }
  create(e) {
    const t = new Vt({
      ...this.options,
      ...e
    });
    return this._mockFn && t.mockTypes(this._mockFn), t;
  }
  withDefaults(e) {
    return this.create({
      ...this.options,
      defaults: {
        ...this.options.defaults,
        ...e
      }
    });
  }
  withTag(e) {
    return this.withDefaults({
      tag: this.options.defaults.tag ? this.options.defaults.tag + ":" + e : e
    });
  }
  addReporter(e) {
    return this.options.reporters.push(e), this;
  }
  removeReporter(e) {
    if (e) {
      const t = this.options.reporters.indexOf(e);
      if (t >= 0)
        return this.options.reporters.splice(t, 1);
    } else
      this.options.reporters.splice(0);
    return this;
  }
  setReporters(e) {
    return this.options.reporters = Array.isArray(e) ? e : [e], this;
  }
  wrapAll() {
    this.wrapConsole(), this.wrapStd();
  }
  restoreAll() {
    this.restoreConsole(), this.restoreStd();
  }
  wrapConsole() {
    for (const e in this.options.types)
      console["__" + e] || (console["__" + e] = console[e]), console[e] = this[e].raw;
  }
  restoreConsole() {
    for (const e in this.options.types)
      console["__" + e] && (console[e] = console["__" + e], delete console["__" + e]);
  }
  wrapStd() {
    this._wrapStream(this.options.stdout, "log"), this._wrapStream(this.options.stderr, "log");
  }
  _wrapStream(e, t) {
    e && (e.__write || (e.__write = e.write), e.write = (r) => {
      this[t].raw(String(r).trim());
    });
  }
  restoreStd() {
    this._restoreStream(this.options.stdout), this._restoreStream(this.options.stderr);
  }
  _restoreStream(e) {
    e && e.__write && (e.write = e.__write, delete e.__write);
  }
  pauseLogs() {
    uc = !0;
  }
  resumeLogs() {
    uc = !1;
    const e = Vf.splice(0);
    for (const t of e)
      t[0]._logFn(t[1], t[2]);
  }
  mockTypes(e) {
    const t = e || this.options.mockFn;
    if (this._mockFn = t, typeof t == "function")
      for (const r in this.options.types)
        this[r] = t(r, this.options.types[r]) || this[r], this[r].raw = this[r];
  }
  _wrapLogFn(e, t) {
    return (...r) => {
      if (uc) {
        Vf.push([this, e, r, t]);
        return;
      }
      return this._logFn(e, r, t);
    };
  }
  _logFn(e, t, r) {
    if ((e.level || 0) > this.level)
      return !1;
    const i = {
      date: /* @__PURE__ */ new Date(),
      args: [],
      ...e,
      level: dc(e.level, this.options.types)
    };
    !r && t.length === 1 && Xx(t[0]) ? Object.assign(i, t[0]) : i.args = [...t], i.message && (i.args.unshift(i.message), delete i.message), i.additional && (Array.isArray(i.additional) || (i.additional = i.additional.split(`
`)), i.args.push(`
` + i.additional.join(`
`)), delete i.additional), i.type = typeof i.type == "string" ? i.type.toLowerCase() : "log", i.tag = typeof i.tag == "string" ? i.tag : "";
    const s = (o = !1) => {
      const c = (this._lastLog.count || 0) - this.options.throttleMin;
      if (this._lastLog.object && c > 0) {
        const l = [...this._lastLog.object.args];
        c > 1 && l.push(`(repeated ${c} times)`), this._log({ ...this._lastLog.object, args: l }), this._lastLog.count = 1;
      }
      o && (this._lastLog.object = i, this._log(i));
    };
    clearTimeout(this._lastLog.timeout);
    const a = this._lastLog.time && i.date ? i.date.getTime() - this._lastLog.time.getTime() : 0;
    if (this._lastLog.time = i.date, a < this.options.throttle)
      try {
        const o = JSON.stringify([
          i.type,
          i.tag,
          i.args
        ]), c = this._lastLog.serialized === o;
        if (this._lastLog.serialized = o, c && (this._lastLog.count = (this._lastLog.count || 0) + 1, this._lastLog.count > this.options.throttleMin)) {
          this._lastLog.timeout = setTimeout(
            s,
            this.options.throttle
          );
          return;
        }
      } catch {
      }
    s(!0);
  }
  _log(e) {
    for (const t of this.options.reporters)
      t.log(e, {
        options: this.options
      });
  }
}
function dc(n, e = {}, t = 3) {
  return n === void 0 ? t : typeof n == "number" ? n : e[n] && e[n].level !== void 0 ? e[n].level : t;
}
Vt.prototype.add = Vt.prototype.addReporter;
Vt.prototype.remove = Vt.prototype.removeReporter;
Vt.prototype.clear = Vt.prototype.removeReporter;
Vt.prototype.withScope = Vt.prototype.withTag;
Vt.prototype.mock = Vt.prototype.mockTypes;
Vt.prototype.pause = Vt.prototype.pauseLogs;
Vt.prototype.resume = Vt.prototype.resumeLogs;
function Gx(n = {}) {
  return new Vt(n);
}
class Zx {
  constructor(e) {
    this.options = { ...e }, this.defaultColor = "#7f8c8d", this.levelColorMap = {
      0: "#c0392b",
      // Red
      1: "#f39c12",
      // Yellow
      3: "#00BCD4"
      // Cyan
    }, this.typeColorMap = {
      success: "#2ecc71"
      // Green
    };
  }
  _getLogFn(e) {
    return e < 1 ? console.__error || console.error : e === 1 ? console.__warn || console.warn : console.__log || console.log;
  }
  log(e) {
    const t = this._getLogFn(e.level), r = e.type === "log" ? "" : e.type, i = e.tag || "", a = `
      background: ${this.typeColorMap[e.type] || this.levelColorMap[e.level] || this.defaultColor};
      border-radius: 0.5em;
      color: white;
      font-weight: bold;
      padding: 2px 0.5em;
    `, o = `%c${[i, r].filter(Boolean).join(":")}`;
    typeof e.args[0] == "string" ? t(
      `${o}%c ${e.args[0]}`,
      a,
      // Empty string as style resets to default console style
      "",
      ...e.args.slice(1)
    ) : t(o, a, ...e.args);
  }
}
function Kg(n = {}) {
  return Gx({
    reporters: n.reporters || [new Zx({})],
    prompt(t, r = {}) {
      return r.type === "confirm" ? Promise.resolve(confirm(t)) : Promise.resolve(prompt(t));
    },
    ...n
  });
}
Kg();
const Wn = Ov(["trace", "debug", "info", "warn", "error", "fatal", "log"]);
function Jx(n, e) {
  return Yg(Qg(n), e);
}
function Kx() {
  return Yx;
}
const Yg = (n, e) => {
  const t = Kg({}).withTag(e);
  let r = n;
  const i = {
    log: t.log,
    info: t.info,
    debug: t.debug,
    trace: t.trace,
    warn: t.warn,
    error: t.error,
    fatal: t.fatal,
    setLogLevel: (s) => {
      let a = NaN;
      switch (s = Qg(s), s) {
        case Wn.enum.trace:
          a = Et.trace;
          break;
        case Wn.enum.debug:
          a = Et.debug;
          break;
        case Wn.enum.info:
          a = Et.info;
          break;
        case Wn.enum.warn:
          a = Et.warn;
          break;
        case Wn.enum.error:
          a = Et.error;
          break;
        case Wn.enum.fatal:
          a = Et.fatal;
          break;
        case Wn.enum.log:
          a = Et.log;
          break;
        default:
          throw new Error(`Invalid log level translation to consola's log level: ${s}`);
      }
      t.level = a, r = s;
    },
    getLogLevel: () => r
  };
  return i.setLogLevel(n), i;
};
function Qg(n) {
  n = n || process.env.PROSOPO_LOG_LEVEL || "Info", n = n.toString().toLowerCase();
  try {
    return Wn.parse(n);
  } catch {
    throw new Kt("CONFIG.INVALID_LOG_LEVEL", { context: { logLevel: n } });
  }
}
const Yx = Yg(Wn.enum.info, "global"), Qx = "";
function $x(n, e) {
  return n.join(e || Qx);
}
function Ft(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error(`Wrong positive integer: ${n}`);
}
function eS(n) {
  return n instanceof Uint8Array || n != null && typeof n == "object" && n.constructor.name === "Uint8Array";
}
function Ru(n, ...e) {
  if (!eS(n))
    throw new Error("Expected Uint8Array");
  if (e.length > 0 && !e.includes(n.length))
    throw new Error(`Expected Uint8Array of length ${e}, not of length=${n.length}`);
}
function $g(n) {
  if (typeof n != "function" || typeof n.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  Ft(n.outputLen), Ft(n.blockLen);
}
function Wr(n, e = !0) {
  if (n.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (e && n.finished)
    throw new Error("Hash#digest() has already been called");
}
function Iu(n, e) {
  Ru(n);
  const t = e.outputLen;
  if (n.length < t)
    throw new Error(`digestInto() expects output buffer of length at least ${t}`);
}
const fc = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
const Ur = (n) => new Uint32Array(n.buffer, n.byteOffset, Math.floor(n.byteLength / 4));
function ey(n) {
  return n instanceof Uint8Array || n != null && typeof n == "object" && n.constructor.name === "Uint8Array";
}
const _a = (n) => new DataView(n.buffer, n.byteOffset, n.byteLength), Hn = (n, e) => n << 32 - e | n >>> e, tS = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!tS)
  throw new Error("Non little-endian hardware is not supported");
function ty(n) {
  if (typeof n != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof n}`);
  return new Uint8Array(new TextEncoder().encode(n));
}
function In(n) {
  if (typeof n == "string" && (n = ty(n)), !ey(n))
    throw new Error(`expected Uint8Array, got ${typeof n}`);
  return n;
}
function ny(...n) {
  let e = 0;
  for (let r = 0; r < n.length; r++) {
    const i = n[r];
    if (!ey(i))
      throw new Error("Uint8Array expected");
    e += i.length;
  }
  const t = new Uint8Array(e);
  for (let r = 0, i = 0; r < n.length; r++) {
    const s = n[r];
    t.set(s, i), i += s.length;
  }
  return t;
}
class yo {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
}
const nS = {}.toString;
function ry(n, e) {
  if (e !== void 0 && nS.call(e) !== "[object Object]")
    throw new Error("Options should be object or undefined");
  return Object.assign(n, e);
}
function Ou(n) {
  const e = (r) => n().update(In(r)).digest(), t = n();
  return e.outputLen = t.outputLen, e.blockLen = t.blockLen, e.create = () => n(), e;
}
function rS(n) {
  const e = (r, i) => n(i).update(In(r)).digest(), t = n({});
  return e.outputLen = t.outputLen, e.blockLen = t.blockLen, e.create = (r) => n(r), e;
}
function iy(n = 32) {
  if (fc && typeof fc.getRandomValues == "function")
    return fc.getRandomValues(new Uint8Array(n));
  throw new Error("crypto.getRandomValues must be defined");
}
const iS = /* @__PURE__ */ new Uint8Array([
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  14,
  10,
  4,
  8,
  9,
  15,
  13,
  6,
  1,
  12,
  0,
  2,
  11,
  7,
  5,
  3,
  11,
  8,
  12,
  0,
  5,
  2,
  15,
  13,
  10,
  14,
  3,
  6,
  7,
  1,
  9,
  4,
  7,
  9,
  3,
  1,
  13,
  12,
  11,
  14,
  2,
  6,
  5,
  10,
  4,
  0,
  15,
  8,
  9,
  0,
  5,
  7,
  2,
  4,
  10,
  15,
  14,
  1,
  11,
  12,
  6,
  8,
  3,
  13,
  2,
  12,
  6,
  10,
  0,
  11,
  8,
  3,
  4,
  13,
  7,
  5,
  15,
  14,
  1,
  9,
  12,
  5,
  1,
  15,
  14,
  13,
  4,
  10,
  0,
  7,
  6,
  3,
  9,
  2,
  8,
  11,
  13,
  11,
  7,
  14,
  12,
  1,
  3,
  9,
  5,
  0,
  15,
  4,
  8,
  6,
  2,
  10,
  6,
  15,
  14,
  9,
  11,
  3,
  0,
  8,
  12,
  2,
  13,
  7,
  1,
  4,
  10,
  5,
  10,
  2,
  8,
  4,
  7,
  6,
  1,
  5,
  15,
  11,
  9,
  14,
  3,
  12,
  13,
  0,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  14,
  10,
  4,
  8,
  9,
  15,
  13,
  6,
  1,
  12,
  0,
  2,
  11,
  7,
  5,
  3
]);
class sS extends yo {
  constructor(e, t, r = {}, i, s, a) {
    if (super(), this.blockLen = e, this.outputLen = t, this.length = 0, this.pos = 0, this.finished = !1, this.destroyed = !1, Ft(e), Ft(t), Ft(i), t < 0 || t > i)
      throw new Error("outputLen bigger than keyLen");
    if (r.key !== void 0 && (r.key.length < 1 || r.key.length > i))
      throw new Error(`key must be up 1..${i} byte long or undefined`);
    if (r.salt !== void 0 && r.salt.length !== s)
      throw new Error(`salt must be ${s} byte long or undefined`);
    if (r.personalization !== void 0 && r.personalization.length !== a)
      throw new Error(`personalization must be ${a} byte long or undefined`);
    this.buffer32 = Ur(this.buffer = new Uint8Array(e));
  }
  update(e) {
    Wr(this);
    const { blockLen: t, buffer: r, buffer32: i } = this;
    e = In(e);
    const s = e.length, a = e.byteOffset, o = e.buffer;
    for (let c = 0; c < s; ) {
      this.pos === t && (this.compress(i, 0, !1), this.pos = 0);
      const l = Math.min(t - this.pos, s - c), u = a + c;
      if (l === t && !(u % 4) && c + l < s) {
        const f = new Uint32Array(o, u, Math.floor((s - c) / 4));
        for (let m = 0; c + t < s; m += i.length, c += t)
          this.length += t, this.compress(f, m, !1);
        continue;
      }
      r.set(e.subarray(c, c + l), this.pos), this.pos += l, this.length += l, c += l;
    }
    return this;
  }
  digestInto(e) {
    Wr(this), Iu(e, this);
    const { pos: t, buffer32: r } = this;
    this.finished = !0, this.buffer.subarray(t).fill(0), this.compress(r, 0, !0);
    const i = Ur(e);
    this.get().forEach((s, a) => i[a] = s);
  }
  digest() {
    const { buffer: e, outputLen: t } = this;
    this.digestInto(e);
    const r = e.slice(0, t);
    return this.destroy(), r;
  }
  _cloneInto(e) {
    const { buffer: t, length: r, finished: i, destroyed: s, outputLen: a, pos: o } = this;
    return e || (e = new this.constructor({ dkLen: a })), e.set(...this.get()), e.length = r, e.finished = i, e.destroyed = s, e.outputLen = a, e.buffer.set(t), e.pos = o, e;
  }
}
const ta = /* @__PURE__ */ BigInt(2 ** 32 - 1), yl = /* @__PURE__ */ BigInt(32);
function sy(n, e = !1) {
  return e ? { h: Number(n & ta), l: Number(n >> yl & ta) } : { h: Number(n >> yl & ta) | 0, l: Number(n & ta) | 0 };
}
function ay(n, e = !1) {
  let t = new Uint32Array(n.length), r = new Uint32Array(n.length);
  for (let i = 0; i < n.length; i++) {
    const { h: s, l: a } = sy(n[i], e);
    [t[i], r[i]] = [s, a];
  }
  return [t, r];
}
const aS = (n, e) => BigInt(n >>> 0) << yl | BigInt(e >>> 0), oS = (n, e, t) => n >>> t, cS = (n, e, t) => n << 32 - t | e >>> t, lS = (n, e, t) => n >>> t | e << 32 - t, uS = (n, e, t) => n << 32 - t | e >>> t, dS = (n, e, t) => n << 64 - t | e >>> t - 32, fS = (n, e, t) => n >>> t - 32 | e << 64 - t, hS = (n, e) => e, pS = (n, e) => n, oy = (n, e, t) => n << t | e >>> 32 - t, cy = (n, e, t) => e << t | n >>> 32 - t, ly = (n, e, t) => e << t - 32 | n >>> 64 - t, uy = (n, e, t) => n << t - 32 | e >>> 64 - t;
function mS(n, e, t, r) {
  const i = (e >>> 0) + (r >>> 0);
  return { h: n + t + (i / 2 ** 32 | 0) | 0, l: i | 0 };
}
const gS = (n, e, t) => (n >>> 0) + (e >>> 0) + (t >>> 0), yS = (n, e, t, r) => e + t + r + (n / 2 ** 32 | 0) | 0, _S = (n, e, t, r) => (n >>> 0) + (e >>> 0) + (t >>> 0) + (r >>> 0), vS = (n, e, t, r, i) => e + t + r + i + (n / 2 ** 32 | 0) | 0, bS = (n, e, t, r, i) => (n >>> 0) + (e >>> 0) + (t >>> 0) + (r >>> 0) + (i >>> 0), wS = (n, e, t, r, i, s) => e + t + r + i + s + (n / 2 ** 32 | 0) | 0, xS = {
  fromBig: sy,
  split: ay,
  toBig: aS,
  shrSH: oS,
  shrSL: cS,
  rotrSH: lS,
  rotrSL: uS,
  rotrBH: dS,
  rotrBL: fS,
  rotr32H: hS,
  rotr32L: pS,
  rotlSH: oy,
  rotlSL: cy,
  rotlBH: ly,
  rotlBL: uy,
  add: mS,
  add3L: gS,
  add3H: yS,
  add4L: _S,
  add4H: vS,
  add5H: wS,
  add5L: bS
}, ae = xS, Ct = /* @__PURE__ */ new Uint32Array([
  4089235720,
  1779033703,
  2227873595,
  3144134277,
  4271175723,
  1013904242,
  1595750129,
  2773480762,
  2917565137,
  1359893119,
  725511199,
  2600822924,
  4215389547,
  528734635,
  327033209,
  1541459225
]), K = /* @__PURE__ */ new Uint32Array(32);
function Er(n, e, t, r, i, s) {
  const a = i[s], o = i[s + 1];
  let c = K[2 * n], l = K[2 * n + 1], u = K[2 * e], f = K[2 * e + 1], m = K[2 * t], y = K[2 * t + 1], _ = K[2 * r], v = K[2 * r + 1], C = ae.add3L(c, u, a);
  l = ae.add3H(C, l, f, o), c = C | 0, { Dh: v, Dl: _ } = { Dh: v ^ l, Dl: _ ^ c }, { Dh: v, Dl: _ } = { Dh: ae.rotr32H(v, _), Dl: ae.rotr32L(v, _) }, { h: y, l: m } = ae.add(y, m, v, _), { Bh: f, Bl: u } = { Bh: f ^ y, Bl: u ^ m }, { Bh: f, Bl: u } = { Bh: ae.rotrSH(f, u, 24), Bl: ae.rotrSL(f, u, 24) }, K[2 * n] = c, K[2 * n + 1] = l, K[2 * e] = u, K[2 * e + 1] = f, K[2 * t] = m, K[2 * t + 1] = y, K[2 * r] = _, K[2 * r + 1] = v;
}
function Cr(n, e, t, r, i, s) {
  const a = i[s], o = i[s + 1];
  let c = K[2 * n], l = K[2 * n + 1], u = K[2 * e], f = K[2 * e + 1], m = K[2 * t], y = K[2 * t + 1], _ = K[2 * r], v = K[2 * r + 1], C = ae.add3L(c, u, a);
  l = ae.add3H(C, l, f, o), c = C | 0, { Dh: v, Dl: _ } = { Dh: v ^ l, Dl: _ ^ c }, { Dh: v, Dl: _ } = { Dh: ae.rotrSH(v, _, 16), Dl: ae.rotrSL(v, _, 16) }, { h: y, l: m } = ae.add(y, m, v, _), { Bh: f, Bl: u } = { Bh: f ^ y, Bl: u ^ m }, { Bh: f, Bl: u } = { Bh: ae.rotrBH(f, u, 63), Bl: ae.rotrBL(f, u, 63) }, K[2 * n] = c, K[2 * n + 1] = l, K[2 * e] = u, K[2 * e + 1] = f, K[2 * t] = m, K[2 * t + 1] = y, K[2 * r] = _, K[2 * r + 1] = v;
}
class SS extends sS {
  constructor(e = {}) {
    super(128, e.dkLen === void 0 ? 64 : e.dkLen, e, 64, 16, 16), this.v0l = Ct[0] | 0, this.v0h = Ct[1] | 0, this.v1l = Ct[2] | 0, this.v1h = Ct[3] | 0, this.v2l = Ct[4] | 0, this.v2h = Ct[5] | 0, this.v3l = Ct[6] | 0, this.v3h = Ct[7] | 0, this.v4l = Ct[8] | 0, this.v4h = Ct[9] | 0, this.v5l = Ct[10] | 0, this.v5h = Ct[11] | 0, this.v6l = Ct[12] | 0, this.v6h = Ct[13] | 0, this.v7l = Ct[14] | 0, this.v7h = Ct[15] | 0;
    const t = e.key ? e.key.length : 0;
    if (this.v0l ^= this.outputLen | t << 8 | 65536 | 1 << 24, e.salt) {
      const r = Ur(In(e.salt));
      this.v4l ^= r[0], this.v4h ^= r[1], this.v5l ^= r[2], this.v5h ^= r[3];
    }
    if (e.personalization) {
      const r = Ur(In(e.personalization));
      this.v6l ^= r[0], this.v6h ^= r[1], this.v7l ^= r[2], this.v7h ^= r[3];
    }
    if (e.key) {
      const r = new Uint8Array(this.blockLen);
      r.set(In(e.key)), this.update(r);
    }
  }
  // prettier-ignore
  get() {
    let { v0l: e, v0h: t, v1l: r, v1h: i, v2l: s, v2h: a, v3l: o, v3h: c, v4l: l, v4h: u, v5l: f, v5h: m, v6l: y, v6h: _, v7l: v, v7h: C } = this;
    return [e, t, r, i, s, a, o, c, l, u, f, m, y, _, v, C];
  }
  // prettier-ignore
  set(e, t, r, i, s, a, o, c, l, u, f, m, y, _, v, C) {
    this.v0l = e | 0, this.v0h = t | 0, this.v1l = r | 0, this.v1h = i | 0, this.v2l = s | 0, this.v2h = a | 0, this.v3l = o | 0, this.v3h = c | 0, this.v4l = l | 0, this.v4h = u | 0, this.v5l = f | 0, this.v5h = m | 0, this.v6l = y | 0, this.v6h = _ | 0, this.v7l = v | 0, this.v7h = C | 0;
  }
  compress(e, t, r) {
    this.get().forEach((c, l) => K[l] = c), K.set(Ct, 16);
    let { h: i, l: s } = ae.fromBig(BigInt(this.length));
    K[24] = Ct[8] ^ s, K[25] = Ct[9] ^ i, r && (K[28] = ~K[28], K[29] = ~K[29]);
    let a = 0;
    const o = iS;
    for (let c = 0; c < 12; c++)
      Er(0, 4, 8, 12, e, t + 2 * o[a++]), Cr(0, 4, 8, 12, e, t + 2 * o[a++]), Er(1, 5, 9, 13, e, t + 2 * o[a++]), Cr(1, 5, 9, 13, e, t + 2 * o[a++]), Er(2, 6, 10, 14, e, t + 2 * o[a++]), Cr(2, 6, 10, 14, e, t + 2 * o[a++]), Er(3, 7, 11, 15, e, t + 2 * o[a++]), Cr(3, 7, 11, 15, e, t + 2 * o[a++]), Er(0, 5, 10, 15, e, t + 2 * o[a++]), Cr(0, 5, 10, 15, e, t + 2 * o[a++]), Er(1, 6, 11, 12, e, t + 2 * o[a++]), Cr(1, 6, 11, 12, e, t + 2 * o[a++]), Er(2, 7, 8, 13, e, t + 2 * o[a++]), Cr(2, 7, 8, 13, e, t + 2 * o[a++]), Er(3, 4, 9, 14, e, t + 2 * o[a++]), Cr(3, 4, 9, 14, e, t + 2 * o[a++]);
    this.v0l ^= K[0] ^ K[16], this.v0h ^= K[1] ^ K[17], this.v1l ^= K[2] ^ K[18], this.v1h ^= K[3] ^ K[19], this.v2l ^= K[4] ^ K[20], this.v2h ^= K[5] ^ K[21], this.v3l ^= K[6] ^ K[22], this.v3h ^= K[7] ^ K[23], this.v4l ^= K[8] ^ K[24], this.v4h ^= K[9] ^ K[25], this.v5l ^= K[10] ^ K[26], this.v5h ^= K[11] ^ K[27], this.v6l ^= K[12] ^ K[28], this.v6h ^= K[13] ^ K[29], this.v7l ^= K[14] ^ K[30], this.v7h ^= K[15] ^ K[31], K.fill(0);
  }
  destroy() {
    this.destroyed = !0, this.buffer32.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
}
const Bf = /* @__PURE__ */ rS((n) => new SS(n));
function ES(n) {
  return n("return this");
}
const CS = typeof globalThis < "u" ? globalThis : typeof global < "u" ? global : typeof self < "u" ? self : typeof window < "u" ? window : ES(Function), AS = CS.crypto;
function dy(n) {
  return AS.getRandomValues(n);
}
const va = { getRandomValues: dy }, PS = { crypto: va };
class kS {
  constructor(e) {
    b(this, "__internal__bridge");
    /** @internal */
    b(this, "abort", () => {
      throw new Error("abort");
    });
    /** @internal */
    b(this, "__wbindgen_is_undefined", (e) => this.__internal__bridge.getObject(e) === void 0);
    /** @internal */
    b(this, "__wbindgen_throw", (e, t) => {
      throw new Error(this.__internal__bridge.getString(e, t));
    });
    /** @internal */
    b(this, "__wbg_self_1b7a39e3a92c949c", () => this.__internal__bridge.addObject(PS));
    /** @internal */
    b(this, "__wbg_require_604837428532a733", (e, t) => {
      throw new Error(`Unable to require ${this.__internal__bridge.getString(e, t)}`);
    });
    /** @internal */
    b(this, "__wbg_crypto_968f1772287e2df0", (e) => this.__internal__bridge.addObject(va));
    /** @internal */
    b(this, "__wbg_getRandomValues_a3d34b4fee3c2869", (e) => this.__internal__bridge.addObject(va.getRandomValues));
    /** @internal */
    b(this, "__wbg_getRandomValues_f5e14ab7ac8e995d", (e, t, r) => {
      va.getRandomValues(this.__internal__bridge.getU8a(t, r));
    });
    /** @internal */
    b(this, "__wbg_randomFillSync_d5bd2d655fdf256a", (e, t, r) => {
      throw new Error("randomFillsync is not available");
    });
    /** @internal */
    b(this, "__wbindgen_object_drop_ref", (e) => {
      this.__internal__bridge.takeObject(e);
    });
    this.__internal__bridge = e;
  }
}
class TS {
  constructor(e) {
    b(this, "__internal__createWasm");
    b(this, "__internal__heap");
    b(this, "__internal__wbg");
    b(this, "__internal__cachegetInt32");
    b(this, "__internal__cachegetUint8");
    b(this, "__internal__heapNext");
    b(this, "__internal__wasm");
    b(this, "__internal__wasmError");
    b(this, "__internal__wasmPromise");
    b(this, "__internal__type");
    this.__internal__createWasm = e, this.__internal__cachegetInt32 = null, this.__internal__cachegetUint8 = null, this.__internal__heap = new Array(32).fill(void 0).concat(void 0, null, !0, !1), this.__internal__heapNext = this.__internal__heap.length, this.__internal__type = "none", this.__internal__wasm = null, this.__internal__wasmError = null, this.__internal__wasmPromise = null, this.__internal__wbg = { ...new kS(this) };
  }
  /** @description Returns the init error */
  get error() {
    return this.__internal__wasmError;
  }
  /** @description Returns the init type */
  get type() {
    return this.__internal__type;
  }
  /** @description Returns the created wasm interface */
  get wasm() {
    return this.__internal__wasm;
  }
  /** @description Performs the wasm initialization */
  async init(e) {
    (!this.__internal__wasmPromise || e) && (this.__internal__wasmPromise = (e || this.__internal__createWasm)(this.__internal__wbg));
    const { error: t, type: r, wasm: i } = await this.__internal__wasmPromise;
    return this.__internal__type = r, this.__internal__wasm = i, this.__internal__wasmError = t, this.__internal__wasm;
  }
  /**
   * @internal
   * @description Gets an object from the heap
   */
  getObject(e) {
    return this.__internal__heap[e];
  }
  /**
   * @internal
   * @description Removes an object from the heap
   */
  dropObject(e) {
    e < 36 || (this.__internal__heap[e] = this.__internal__heapNext, this.__internal__heapNext = e);
  }
  /**
   * @internal
   * @description Retrieves and removes an object to the heap
   */
  takeObject(e) {
    const t = this.getObject(e);
    return this.dropObject(e), t;
  }
  /**
   * @internal
   * @description Adds an object to the heap
   */
  addObject(e) {
    this.__internal__heapNext === this.__internal__heap.length && this.__internal__heap.push(this.__internal__heap.length + 1);
    const t = this.__internal__heapNext;
    return this.__internal__heapNext = this.__internal__heap[t], this.__internal__heap[t] = e, t;
  }
  /**
   * @internal
   * @description Retrieve an Int32 in the WASM interface
   */
  getInt32() {
    return (this.__internal__cachegetInt32 === null || this.__internal__cachegetInt32.buffer !== this.__internal__wasm.memory.buffer) && (this.__internal__cachegetInt32 = new Int32Array(this.__internal__wasm.memory.buffer)), this.__internal__cachegetInt32;
  }
  /**
   * @internal
   * @description Retrieve an Uint8Array in the WASM interface
   */
  getUint8() {
    return (this.__internal__cachegetUint8 === null || this.__internal__cachegetUint8.buffer !== this.__internal__wasm.memory.buffer) && (this.__internal__cachegetUint8 = new Uint8Array(this.__internal__wasm.memory.buffer)), this.__internal__cachegetUint8;
  }
  /**
   * @internal
   * @description Retrieves an Uint8Array in the WASM interface
   */
  getU8a(e, t) {
    return this.getUint8().subarray(e / 1, e / 1 + t);
  }
  /**
   * @internal
   * @description Retrieves a string in the WASM interface
   */
  getString(e, t) {
    return Nn(this.getU8a(e, t));
  }
  /**
   * @internal
   * @description Allocates an Uint8Array in the WASM interface
   */
  allocU8a(e) {
    const t = this.__internal__wasm.__wbindgen_malloc(e.length * 1);
    return this.getUint8().set(e, t / 1), [t, e.length];
  }
  /**
   * @internal
   * @description Allocates a string in the WASM interface
   */
  allocString(e) {
    return this.allocU8a(Ze(e));
  }
  /**
   * @internal
   * @description Retrieves an Uint8Array from the WASM interface
   */
  resultU8a() {
    const e = this.getInt32()[2], t = this.getInt32()[8 / 4 + 1], r = this.getU8a(e, t).slice();
    return this.__internal__wasm.__wbindgen_free(e, t * 1), r;
  }
  /**
   * @internal
   * @description Retrieve a string from the WASM interface
   */
  resultString() {
    return Nn(this.resultU8a());
  }
}
function NS(n, e, t) {
  return async (r) => {
    const i = {
      error: null,
      type: "none",
      wasm: null
    };
    try {
      if (e != null && e.length) {
        if (typeof WebAssembly != "object" || typeof WebAssembly.instantiate != "function")
          throw new Error("WebAssembly is not available in your environment");
      } else
        throw new Error("No WebAssembly provided for initialization");
      const s = await WebAssembly.instantiate(e, { wbg: r });
      i.wasm = s.instance.exports, i.type = "wasm";
    } catch (s) {
      typeof t == "function" ? (i.wasm = t(r), i.type = "asm") : (i.error = `FATAL: Unable to initialize @polkadot/wasm-${n}:: ${s.message}`, console.error(i.error));
    }
    return i;
  };
}
const Hf = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", fy = new Array(256);
for (let n = 0, e = Hf.length; n < e; n++)
  fy[Hf.charCodeAt(n)] = n;
function RS(n, e) {
  let t = 0, r = 0, i = -1;
  for (let s = 0, a = e.length - 1; i !== a; s++)
    t = t << 6 | fy[n.charCodeAt(s)], (r += 6) >= 8 && (e[++i] = t >>> (r -= 8) & 255);
  return e;
}
const Zn = Uint8Array, Or = Uint16Array, _l = Uint32Array, IS = new Zn([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), hy = new Zn([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]), py = new Zn([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]), my = (n, e) => {
  const t = new Or(31);
  for (let i = 0; i < 31; ++i)
    t[i] = e += 1 << n[i - 1];
  const r = new _l(t[30]);
  for (let i = 1; i < 30; ++i)
    for (let s = t[i]; s < t[i + 1]; ++s)
      r[s] = s - t[i] << 5 | i;
  return [t, r];
}, [gy, OS] = my(hy, 2);
gy[28] = 258, OS[258] = 28;
const [MS] = my(py, 0), vl = new Or(32768);
for (let n = 0; n < 32768; ++n) {
  let e = (n & 43690) >>> 1 | (n & 21845) << 1;
  e = (e & 52428) >>> 2 | (e & 13107) << 2, e = (e & 61680) >>> 4 | (e & 3855) << 4, vl[n] = ((e & 65280) >>> 8 | (e & 255) << 8) >>> 1;
}
const gs = (n, e, t) => {
  const r = n.length;
  let i = 0;
  const s = new Or(e);
  for (; i < r; ++i)
    n[i] && ++s[n[i] - 1];
  const a = new Or(e);
  for (i = 1; i < e; ++i)
    a[i] = a[i - 1] + s[i - 1] << 1;
  let o;
  if (t) {
    o = new Or(1 << e);
    const c = 15 - e;
    for (i = 0; i < r; ++i)
      if (n[i]) {
        const l = i << 4 | n[i], u = e - n[i];
        let f = a[n[i] - 1]++ << u;
        for (const m = f | (1 << u) - 1; f <= m; ++f)
          o[vl[f] >> c] = l;
      }
  } else
    for (o = new Or(r), i = 0; i < r; ++i)
      n[i] && (o[i] = vl[a[n[i] - 1]++] >> 15 - n[i]);
  return o;
}, Fs = new Zn(288);
for (let n = 0; n < 144; ++n)
  Fs[n] = 8;
for (let n = 144; n < 256; ++n)
  Fs[n] = 9;
for (let n = 256; n < 280; ++n)
  Fs[n] = 7;
for (let n = 280; n < 288; ++n)
  Fs[n] = 8;
const yy = new Zn(32);
for (let n = 0; n < 32; ++n)
  yy[n] = 5;
const LS = gs(Fs, 9, 1), DS = gs(yy, 5, 1), Cn = (n, e, t) => {
  const r = e >>> 3;
  return (n[r] | n[r + 1] << 8) >>> (e & 7) & t;
}, hc = (n, e) => {
  const t = e >>> 3;
  return (n[t] | n[t + 1] << 8 | n[t + 2] << 16) >>> (e & 7);
}, US = (n) => (n >>> 3) + (n & 7 && 1), VS = (n, e, t) => {
  (e == null || e < 0) && (e = 0), (t == null || t > n.length) && (t = n.length);
  const r = new (n instanceof Or ? Or : n instanceof _l ? _l : Zn)(t - e);
  return r.set(n.subarray(e, t)), r;
}, pc = (n) => {
  let e = n[0];
  for (let t = 1, r = n.length; t < r; ++t)
    n[t] > e && (e = n[t]);
  return e;
}, BS = (n, e, t) => {
  const r = !t || t.i;
  t || (t = {});
  const i = n.length, s = !e || !r;
  e || (e = new Zn(i * 3));
  const a = (v) => {
    let C = e.length;
    if (v > C) {
      const A = new Zn(Math.max(C << 1, v));
      A.set(e), e = A;
    }
  };
  let o = t.f || 0, c = t.p || 0, l = t.b || 0, u = t.l, f = t.d, m = t.m, y = t.n;
  if (o && !u)
    return e;
  const _ = i << 3;
  do {
    if (!u) {
      t.f = o = Cn(n, c, 1);
      const R = Cn(n, c + 1, 3);
      if (c += 3, R)
        if (R == 1)
          u = LS, f = DS, m = 9, y = 5;
        else if (R == 2) {
          const I = Cn(n, c, 31) + 257, D = Cn(n, c + 10, 15) + 4, L = I + Cn(n, c + 5, 31) + 1;
          c += 14;
          const V = new Zn(L), F = new Zn(19);
          for (let P = 0; P < D; ++P)
            F[IS[P]] = Cn(n, c + P * 3, 7);
          c += D * 3;
          const U = pc(F), Y = (1 << U) - 1;
          if (!r && c + L * (U + 7) > _)
            break;
          const Q = gs(F, U, 1);
          for (let P = 0; P < L; ) {
            const d = Q[Cn(n, c, Y)];
            c += d & 15;
            const h = d >>> 4;
            if (h < 16)
              V[P++] = h;
            else {
              let g = 0, E = 0;
              for (h == 16 ? (E = 3 + Cn(n, c, 3), c += 2, g = V[P - 1]) : h == 17 ? (E = 3 + Cn(n, c, 7), c += 3) : h == 18 && (E = 11 + Cn(n, c, 127), c += 7); E--; )
                V[P++] = g;
            }
          }
          const O = V.subarray(0, I), B = V.subarray(I);
          m = pc(O), y = pc(B), u = gs(O, m, 1), f = gs(B, y, 1);
        } else
          throw "invalid block type";
      else {
        const I = US(c) + 4, D = n[I - 4] | n[I - 3] << 8, L = I + D;
        if (L > i) {
          if (r)
            throw "unexpected EOF";
          break;
        }
        s && a(l + D), e.set(n.subarray(I, L), l), t.b = l += D, t.p = c = L << 3;
        continue;
      }
      if (c > _)
        throw "unexpected EOF";
    }
    s && a(l + 131072);
    const v = (1 << m) - 1, C = (1 << y) - 1, A = m + y + 18;
    for (; r || c + A < _; ) {
      const R = u[hc(n, c) & v], I = R >>> 4;
      if (c += R & 15, c > _)
        throw "unexpected EOF";
      if (!R)
        throw "invalid length/literal";
      if (I < 256)
        e[l++] = I;
      else if (I == 256) {
        u = void 0;
        break;
      } else {
        let D = I - 254;
        if (I > 264) {
          const Y = I - 257, Q = hy[Y];
          D = Cn(n, c, (1 << Q) - 1) + gy[Y], c += Q;
        }
        const L = f[hc(n, c) & C], V = L >>> 4;
        if (!L)
          throw "invalid distance";
        c += L & 15;
        let F = MS[V];
        if (V > 3) {
          const Y = py[V];
          F += hc(n, c) & (1 << Y) - 1, c += Y;
        }
        if (c > _)
          throw "unexpected EOF";
        s && a(l + 131072);
        const U = l + D;
        for (; l < U; l += 4)
          e[l] = e[l - F], e[l + 1] = e[l + 1 - F], e[l + 2] = e[l + 2 - F], e[l + 3] = e[l + 3 - F];
        l = U;
      }
    }
    t.l = u, t.p = c, t.b = l, u && (o = 1, t.m = m, t.d = f, t.n = y);
  } while (!o);
  return l == e.length ? e : VS(e, 0, l);
}, HS = (n) => {
  if ((n[0] & 15) != 8 || n[0] >>> 4 > 7 || (n[0] << 8 | n[1]) % 31)
    throw "invalid zlib data";
  if (n[1] & 32)
    throw "invalid zlib data: preset dictionaries not supported";
};
function FS(n, e) {
  return BS((HS(n), n.subarray(2, -4)), e);
}
const jS = 70042, WS = 107426, qS = "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", zS = /* @__PURE__ */ FS(RS(qS, new Uint8Array(jS)), new Uint8Array(WS)), XS = /* @__PURE__ */ NS("crypto", zS, null), z = new TS(XS);
async function GS(n) {
  return z.init(n);
}
function ke(n) {
  return (...e) => {
    if (!z.wasm)
      throw new Error("The WASM interface has not been initialized. Ensure that you wait for the initialization Promise with waitReady() from @polkadot/wasm-crypto (or cryptoWaitReady() from @polkadot/util-crypto) before attempting to use WASM-only interfaces.");
    return n(z.wasm, ...e);
  };
}
const ZS = /* @__PURE__ */ ke((n, e) => (n.ext_bip39_to_entropy(8, ...z.allocString(e)), z.resultU8a())), JS = /* @__PURE__ */ ke((n, e, t) => (n.ext_bip39_to_mini_secret(8, ...z.allocString(e), ...z.allocString(t)), z.resultU8a())), KS = /* @__PURE__ */ ke((n, e, t) => (n.ext_bip39_to_seed(8, ...z.allocString(e), ...z.allocString(t)), z.resultU8a())), YS = /* @__PURE__ */ ke((n, e) => n.ext_bip39_validate(...z.allocString(e)) !== 0), QS = /* @__PURE__ */ ke((n, e) => (n.ext_ed_from_seed(8, ...z.allocU8a(e)), z.resultU8a())), $S = /* @__PURE__ */ ke((n, e, t, r) => (n.ext_ed_sign(8, ...z.allocU8a(e), ...z.allocU8a(t), ...z.allocU8a(r)), z.resultU8a())), eE = /* @__PURE__ */ ke((n, e, t, r) => n.ext_ed_verify(...z.allocU8a(e), ...z.allocU8a(t), ...z.allocU8a(r)) !== 0), tE = /* @__PURE__ */ ke((n, e) => (n.ext_secp_from_seed(8, ...z.allocU8a(e)), z.resultU8a())), nE = /* @__PURE__ */ ke((n, e) => (n.ext_secp_pub_compress(8, ...z.allocU8a(e)), z.resultU8a())), rE = /* @__PURE__ */ ke((n, e) => (n.ext_secp_pub_expand(8, ...z.allocU8a(e)), z.resultU8a())), iE = /* @__PURE__ */ ke((n, e, t, r) => (n.ext_secp_recover(8, ...z.allocU8a(e), ...z.allocU8a(t), r), z.resultU8a())), sE = /* @__PURE__ */ ke((n, e, t) => (n.ext_secp_sign(8, ...z.allocU8a(e), ...z.allocU8a(t)), z.resultU8a())), aE = /* @__PURE__ */ ke((n, e, t) => (n.ext_sr_derive_keypair_hard(8, ...z.allocU8a(e), ...z.allocU8a(t)), z.resultU8a())), oE = /* @__PURE__ */ ke((n, e, t) => (n.ext_sr_derive_keypair_soft(8, ...z.allocU8a(e), ...z.allocU8a(t)), z.resultU8a())), cE = /* @__PURE__ */ ke((n, e) => (n.ext_sr_from_seed(8, ...z.allocU8a(e)), z.resultU8a())), lE = /* @__PURE__ */ ke((n, e, t, r) => (n.ext_sr_sign(8, ...z.allocU8a(e), ...z.allocU8a(t), ...z.allocU8a(r)), z.resultU8a())), uE = /* @__PURE__ */ ke((n, e, t, r) => n.ext_sr_verify(...z.allocU8a(e), ...z.allocU8a(t), ...z.allocU8a(r)) !== 0), dE = /* @__PURE__ */ ke((n, e, t, r, i) => (n.ext_vrf_sign(8, ...z.allocU8a(e), ...z.allocU8a(t), ...z.allocU8a(r), ...z.allocU8a(i)), z.resultU8a())), fE = /* @__PURE__ */ ke((n, e, t, r, i, s) => n.ext_vrf_verify(...z.allocU8a(e), ...z.allocU8a(t), ...z.allocU8a(r), ...z.allocU8a(i), ...z.allocU8a(s)) !== 0), hE = /* @__PURE__ */ ke((n, e, t, r) => (n.ext_blake2b(8, ...z.allocU8a(e), ...z.allocU8a(t), r), z.resultU8a())), pE = /* @__PURE__ */ ke((n, e, t) => (n.ext_hmac_sha256(8, ...z.allocU8a(e), ...z.allocU8a(t)), z.resultU8a())), mE = /* @__PURE__ */ ke((n, e, t) => (n.ext_hmac_sha512(8, ...z.allocU8a(e), ...z.allocU8a(t)), z.resultU8a())), gE = /* @__PURE__ */ ke((n, e) => (n.ext_keccak256(8, ...z.allocU8a(e)), z.resultU8a())), yE = /* @__PURE__ */ ke((n, e) => (n.ext_keccak512(8, ...z.allocU8a(e)), z.resultU8a())), _E = /* @__PURE__ */ ke((n, e, t, r) => (n.ext_pbkdf2(8, ...z.allocU8a(e), ...z.allocU8a(t), r), z.resultU8a())), vE = /* @__PURE__ */ ke((n, e, t, r, i, s) => (n.ext_scrypt(8, ...z.allocU8a(e), ...z.allocU8a(t), r, i, s), z.resultU8a())), bE = /* @__PURE__ */ ke((n, e) => (n.ext_sha256(8, ...z.allocU8a(e)), z.resultU8a())), wE = /* @__PURE__ */ ke((n, e) => (n.ext_sha512(8, ...z.allocU8a(e)), z.resultU8a())), xE = /* @__PURE__ */ ke((n, e, t) => (n.ext_twox(8, ...z.allocU8a(e), t), z.resultU8a()));
function It() {
  return !!z.wasm;
}
async function SE() {
  try {
    return !!await GS();
  } catch {
    return !1;
  }
}
function _y(n) {
  return (...e) => pe(n(...e));
}
function EE(n, e) {
  return (t, r) => e(t, n, r);
}
function vy(n, e) {
  return (t, r = 256, i) => {
    const s = j(t);
    return !Rt || !i && It() ? n[r](s) : e[r](s);
  };
}
function hn(n, e = 256, t, r) {
  const i = Math.ceil(e / 8), s = j(n);
  return !Rt || !r && It() ? hE(s, j(t), i) : t ? Bf(s, { dkLen: i, key: t }) : Bf(s, { dkLen: i });
}
const ba = /* @__PURE__ */ _y(hn);
function Ha(n, e) {
  return ba(n, e);
}
function Cs(n) {
  return Ha($x(n));
}
const CE = (n) => {
  if (!n.hash)
    throw new Li("CAPTCHA.MISSING_ITEM_HASH", { context: { item: n } });
  return n.hash;
}, AE = ({ challenge: n, solution: e, onClick: t, themeColor: r }) => {
  const i = n.captcha.items, s = we.useMemo(() => r === "light" ? Ls : Ds, [r]), a = "ontouchstart" in window;
  return ge("div", { style: {
    paddingRight: 0.5,
    paddingBottom: 0.5,
    width: "100%",
    height: "100%",
    display: "flex",
    flexDirection: "row",
    flexWrap: "wrap"
  }, children: i.map((o, c) => {
    const l = CE(o);
    return ge("div", { style: {
      paddingTop: "4px",
      paddingLeft: "4px",
      flexGrow: 1,
      flexBasis: "33.3333%",
      boxSizing: "border-box"
    }, children: dn("div", { style: { cursor: "pointer", height: "100%", width: "100%" }, onClick: a ? void 0 : () => t(l), onTouchStart: a ? () => t(l) : void 0, children: [ge("div", { style: { border: 1, borderColor: s.palette.grey[300] }, children: ge("img", { style: {
      width: "100%",
      backgroundColor: s.palette.grey[300],
      opacity: e.includes(l) && a ? "50%" : "100%",
      display: "block",
      objectFit: "contain",
      aspectRatio: "1/1",
      height: "auto"
    }, src: o.data, alt: `Captcha image ${c + 1}` }) }), ge("div", { style: {
      position: "relative",
      width: "100%",
      height: "100%",
      top: "-100%",
      visibility: e.includes(l) ? "visible" : "hidden",
      transition: "opacity 225ms cubic-bezier(0.4, 0, 0.2, 1) 0ms",
      opacity: 1
    }, children: ge("div", { style: {
      position: "absolute",
      top: 0,
      left: 0,
      bottom: 0,
      right: 0,
      height: "100%",
      width: "100%",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      backgroundColor: "rgba(0,0,0,0.5)"
    }, children: ge("svg", { style: {
      backgroundColor: "transparent",
      display: "block",
      width: "35%",
      height: "35%",
      transition: "fill 200ms cubic-bezier(0.4, 0, 0.2, 1) 0ms",
      userSelect: "none",
      fill: "currentcolor"
    }, focusable: "false", color: "#fff", "aria-hidden": "true", viewBox: "0 0 24 24", "data-testid": "CheckIcon", children: ge("path", { d: "M9 16.17 4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z" }) }) }) })] }) }, c);
  }) });
};
function PE(n = {}) {
  return Object.keys(n).reduce((e, t) => ({ ...e, [`data-${t}`]: n[t] }), {});
}
function bl({ general: n, dev: e }) {
  return {
    ...PE(n)
  };
}
const kE = {
  display: "inline-flex",
  alignItems: "center",
  justifyContent: "center",
  position: "relative",
  boxSizing: "border-box",
  outline: "0px",
  border: "0px",
  margin: "0px",
  cursor: "pointer",
  userSelect: "none",
  verticalAlign: "middle",
  appearance: void 0,
  textDecoration: "none",
  fontWeight: "500",
  fontSize: "0.875rem",
  lineHeight: "1.75",
  letterSpacing: "0.02857em",
  textTransform: "uppercase",
  minWidth: "64px",
  padding: "6px 16px",
  borderRadius: "4px",
  transition: "background-color 250ms cubic-bezier(0.4, 0, 0.2, 1) 0ms, box-shadow 250ms cubic-bezier(0.4, 0, 0.2, 1) 0ms, border-color 250ms cubic-bezier(0.4, 0, 0.2, 1) 0ms, color 250ms cubic-bezier(0.4, 0, 0.2, 1) 0ms",
  color: "rgb(0, 0, 0)",
  backgroundColor: "#ffffff",
  boxShadow: "rgba(0, 0, 0, 0.2) 0px 3px 1px -2px, rgba(0, 0, 0, 0.14) 0px 2px 2px 0px, rgba(0, 0, 0, 0.12) 0px 1px 5px 0px"
}, TE = ({ themeColor: n, buttonType: e, text: t, onClick: r }) => {
  const i = we.useMemo(() => n === "light" ? Ls : Ds, [n]), [s, a] = we.useState(!1), o = we.useMemo(() => {
    const c = {
      ...kE,
      color: s ? i.palette.primary.contrastText : i.palette.background.contrastText
    };
    return e === "cancel" ? {
      ...c,
      backgroundColor: s ? i.palette.grey[600] : "transparent"
    } : {
      ...c,
      backgroundColor: s ? i.palette.primary.main : i.palette.background.default
    };
  }, [e, s, i]);
  return ge("button", { ...bl({ dev: { cy: `button-${e}` } }), onMouseEnter: () => a(!0), onMouseLeave: () => a(!1), style: o, onClick: (c) => {
    c.preventDefault(), r();
  }, children: t });
}, Ff = TE, NE = ({ challenge: n, index: e, solutions: t, onSubmit: r, onCancel: i, onClick: s, onNext: a, themeColor: o }) => {
  const { t: c } = Hx(), l = n.captchas ? H(n.captchas, e) : null, u = t ? H(t, e) : [], f = we.useMemo(() => o === "light" ? Ls : Ds, [o]);
  return ge(we.Suspense, { fallback: ge("div", { children: "Loading..." }), children: ge("div", { style: {
    overflowX: "auto",
    overflowY: "auto",
    width: "100%",
    maxWidth: "500px",
    maxHeight: "100%",
    display: "flex",
    flexDirection: "column"
  }, children: dn("div", { style: {
    backgroundColor: f.palette.background.default,
    display: "flex",
    flexDirection: "column",
    minWidth: "300px"
  }, children: [dn("div", { style: {
    display: "flex",
    alignItems: "center",
    width: "100%",
    backgroundColor: f.palette.primary.main,
    padding: "24px 16px"
  }, children: [dn("p", { style: {
    color: "#ffffff",
    fontWeight: 700,
    lineHeight: 1.5
  }, children: [c("WIDGET.SELECT_ALL"), ": "] }), ge("p", { style: {
    color: "#ffffff",
    fontWeight: 700,
    textTransform: "capitalize",
    lineHeight: 1.5
  }, children: `${H(n.captchas, e).captcha.target}` })] }), ge("div", { ...bl({ dev: { cy: "captcha-" + e } }), children: l && ge(AE, { challenge: l, solution: u, onClick: s, themeColor: o }) }), ge("div", { style: {
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    width: "100%"
  }, ...bl({ dev: { cy: "dots-captcha" } }) }), ge("div", { style: {
    padding: "8px 16px",
    display: "flex",
    width: "100%"
  } }), dn("div", { style: {
    padding: "0 16px 16px",
    display: "flex",
    alignItems: "center",
    justifyContent: "space-between",
    lineHeight: 1.75
  }, children: [ge(Ff, { themeColor: o, buttonType: "cancel", onClick: i, text: c("WIDGET.CANCEL") }), ge(Ff, { themeColor: o, buttonType: "next", text: e < n.captchas.length - 1 ? c("WIDGET.NEXT") : c("WIDGET.SUBMIT"), onClick: e < n.captchas.length - 1 ? a : r })] })] }) }) });
}, RE = NE;
function IE(n) {
  return n("return this");
}
const jf = typeof globalThis < "u" ? globalThis : typeof global < "u" ? global : typeof self < "u" ? self : typeof window < "u" ? window : IE(Function);
function OE(n, e) {
  return typeof jf[n] > "u" ? e : jf[n];
}
function ME() {
  return Number.NaN;
}
const Fe = /* @__PURE__ */ OE("BigInt", ME);
function LE() {
  return SE().then(() => {
    if (!It())
      throw new Error("Unable to initialize @polkadot/util-crypto");
    return !0;
  }).catch(() => !1);
}
function by(n) {
  return n instanceof Uint8Array || n != null && typeof n == "object" && n.constructor.name === "Uint8Array";
}
// @__NO_SIDE_EFFECTS__
function wy(...n) {
  const e = (s) => s, t = (s, a) => (o) => s(a(o)), r = n.map((s) => s.encode).reduceRight(t, e), i = n.map((s) => s.decode).reduce(t, e);
  return { encode: r, decode: i };
}
// @__NO_SIDE_EFFECTS__
function xy(n) {
  return {
    encode: (e) => {
      if (!Array.isArray(e) || e.length && typeof e[0] != "number")
        throw new Error("alphabet.encode input should be an array of numbers");
      return e.map((t) => {
        if (t < 0 || t >= n.length)
          throw new Error(`Digit index outside alphabet: ${t} (alphabet: ${n.length})`);
        return n[t];
      });
    },
    decode: (e) => {
      if (!Array.isArray(e) || e.length && typeof e[0] != "string")
        throw new Error("alphabet.decode input should be array of strings");
      return e.map((t) => {
        if (typeof t != "string")
          throw new Error(`alphabet.decode: not string element=${t}`);
        const r = n.indexOf(t);
        if (r === -1)
          throw new Error(`Unknown letter: "${t}". Allowed: ${n}`);
        return r;
      });
    }
  };
}
// @__NO_SIDE_EFFECTS__
function Sy(n = "") {
  if (typeof n != "string")
    throw new Error("join separator should be string");
  return {
    encode: (e) => {
      if (!Array.isArray(e) || e.length && typeof e[0] != "string")
        throw new Error("join.encode input should be array of strings");
      for (let t of e)
        if (typeof t != "string")
          throw new Error(`join.encode: non-string input=${t}`);
      return e.join(n);
    },
    decode: (e) => {
      if (typeof e != "string")
        throw new Error("join.decode input should be string");
      return e.split(n);
    }
  };
}
// @__NO_SIDE_EFFECTS__
function DE(n, e = "=") {
  if (typeof e != "string")
    throw new Error("padding chr should be string");
  return {
    encode(t) {
      if (!Array.isArray(t) || t.length && typeof t[0] != "string")
        throw new Error("padding.encode input should be array of strings");
      for (let r of t)
        if (typeof r != "string")
          throw new Error(`padding.encode: non-string input=${r}`);
      for (; t.length * n % 8; )
        t.push(e);
      return t;
    },
    decode(t) {
      if (!Array.isArray(t) || t.length && typeof t[0] != "string")
        throw new Error("padding.encode input should be array of strings");
      for (let i of t)
        if (typeof i != "string")
          throw new Error(`padding.decode: non-string input=${i}`);
      let r = t.length;
      if (r * n % 8)
        throw new Error("Invalid padding: string should have whole number of bytes");
      for (; r > 0 && t[r - 1] === e; r--)
        if (!((r - 1) * n % 8))
          throw new Error("Invalid padding: string has too much padding");
      return t.slice(0, r);
    }
  };
}
// @__NO_SIDE_EFFECTS__
function Wf(n, e, t) {
  if (e < 2)
    throw new Error(`convertRadix: wrong from=${e}, base cannot be less than 2`);
  if (t < 2)
    throw new Error(`convertRadix: wrong to=${t}, base cannot be less than 2`);
  if (!Array.isArray(n))
    throw new Error("convertRadix: data should be array");
  if (!n.length)
    return [];
  let r = 0;
  const i = [], s = Array.from(n);
  for (s.forEach((a) => {
    if (a < 0 || a >= e)
      throw new Error(`Wrong integer: ${a}`);
  }); ; ) {
    let a = 0, o = !0;
    for (let c = r; c < s.length; c++) {
      const l = s[c], u = e * a + l;
      if (!Number.isSafeInteger(u) || e * a / e !== a || u - l !== e * a)
        throw new Error("convertRadix: carry overflow");
      a = u % t;
      const f = Math.floor(u / t);
      if (s[c] = f, !Number.isSafeInteger(f) || f * t + a !== u)
        throw new Error("convertRadix: carry overflow");
      if (o)
        f ? o = !1 : r = c;
      else
        continue;
    }
    if (i.push(a), o)
      break;
  }
  for (let a = 0; a < n.length - 1 && n[a] === 0; a++)
    i.push(0);
  return i.reverse();
}
const Ey = /* @__NO_SIDE_EFFECTS__ */ (n, e) => e ? /* @__PURE__ */ Ey(e, n % e) : n, Fa = /* @__NO_SIDE_EFFECTS__ */ (n, e) => n + (e - /* @__PURE__ */ Ey(n, e));
// @__NO_SIDE_EFFECTS__
function qf(n, e, t, r) {
  if (!Array.isArray(n))
    throw new Error("convertRadix2: data should be array");
  if (e <= 0 || e > 32)
    throw new Error(`convertRadix2: wrong from=${e}`);
  if (t <= 0 || t > 32)
    throw new Error(`convertRadix2: wrong to=${t}`);
  if (/* @__PURE__ */ Fa(e, t) > 32)
    throw new Error(`convertRadix2: carry overflow from=${e} to=${t} carryBits=${/* @__PURE__ */ Fa(e, t)}`);
  let i = 0, s = 0;
  const a = 2 ** t - 1, o = [];
  for (const c of n) {
    if (c >= 2 ** e)
      throw new Error(`convertRadix2: invalid data word=${c} from=${e}`);
    if (i = i << e | c, s + e > 32)
      throw new Error(`convertRadix2: carry overflow pos=${s} from=${e}`);
    for (s += e; s >= t; s -= t)
      o.push((i >> s - t & a) >>> 0);
    i &= 2 ** s - 1;
  }
  if (i = i << t - s & a, !r && s >= e)
    throw new Error("Excess padding");
  if (!r && i)
    throw new Error(`Non-zero padding: ${i}`);
  return r && s > 0 && o.push(i >>> 0), o;
}
// @__NO_SIDE_EFFECTS__
function UE(n) {
  return {
    encode: (e) => {
      if (!by(e))
        throw new Error("radix.encode input should be Uint8Array");
      return /* @__PURE__ */ Wf(Array.from(e), 2 ** 8, n);
    },
    decode: (e) => {
      if (!Array.isArray(e) || e.length && typeof e[0] != "number")
        throw new Error("radix.decode input should be array of numbers");
      return Uint8Array.from(/* @__PURE__ */ Wf(e, n, 2 ** 8));
    }
  };
}
// @__NO_SIDE_EFFECTS__
function VE(n, e = !1) {
  if (n <= 0 || n > 32)
    throw new Error("radix2: bits should be in (0..32]");
  if (/* @__PURE__ */ Fa(8, n) > 32 || /* @__PURE__ */ Fa(n, 8) > 32)
    throw new Error("radix2: carry overflow");
  return {
    encode: (t) => {
      if (!by(t))
        throw new Error("radix2.encode input should be Uint8Array");
      return /* @__PURE__ */ qf(Array.from(t), 8, n, !e);
    },
    decode: (t) => {
      if (!Array.isArray(t) || t.length && typeof t[0] != "number")
        throw new Error("radix2.decode input should be array of numbers");
      return Uint8Array.from(/* @__PURE__ */ qf(t, n, 8, e));
    }
  };
}
const BE = /* @__PURE__ */ wy(/* @__PURE__ */ VE(6), /* @__PURE__ */ xy("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), /* @__PURE__ */ DE(6), /* @__PURE__ */ Sy("")), HE = (n) => /* @__PURE__ */ wy(/* @__PURE__ */ UE(58), /* @__PURE__ */ xy(n), /* @__PURE__ */ Sy("")), FE = /* @__PURE__ */ HE("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
function Cy({ coder: n, ipfs: e }, t) {
  return (r, i) => (t(r, i), n.decode(e && i ? r.substring(1) : r));
}
function Ay({ coder: n, ipfs: e }) {
  return (t, r) => {
    const i = n.encode(j(t));
    return e && r ? `${e}${i}` : i;
  };
}
function Py({ chars: n, ipfs: e, type: t, withPadding: r }) {
  return (i, s) => {
    if (typeof i != "string")
      throw new Error(`Expected ${t} string input`);
    if (e && s && !i.startsWith(e))
      throw new Error(`Expected ipfs-compatible ${t} to start with '${e}'`);
    for (let a = s ? 1 : 0, o = i.length; a < o; a++)
      if (!n.includes(i[a]))
        if (r && i[a] === "=") {
          if (a !== o - 1) {
            if (i[a + 1] !== "=")
              throw new Error(`Invalid ${t} padding sequence "${i[a]}${i[a + 1]}" at index ${a}`);
          }
        } else
          throw new Error(`Invalid ${t} character "${i[a]}" (0x${i.charCodeAt(a).toString(16)}) at index ${a}`);
    return !0;
  };
}
const Mu = {
  chars: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",
  coder: FE,
  ipfs: "z",
  type: "base58"
}, jE = /* @__PURE__ */ Py(Mu), WE = /* @__PURE__ */ Cy(Mu, jE), qE = /* @__PURE__ */ Ay(Mu), zE = Ze("SS58PRE");
function ky(n) {
  return hn(Me(zE, n), 512);
}
function XE(n) {
  const e = n[0] & 64 ? 2 : 1, t = e === 1 ? n[0] : (n[0] & 63) << 2 | n[1] >> 6 | (n[1] & 63) << 8, r = [34 + e, 35 + e].includes(n.length), i = n.length - (r ? 2 : 1), s = ky(n.subarray(0, i));
  return [(n[0] & 128) === 0 && ![46, 47].includes(n[0]) && (r ? n[n.length - 2] === s[0] && n[n.length - 1] === s[1] : n[n.length - 1] === s[0]), i, e, t];
}
const Ty = [
  {
    prefix: 0,
    network: "polkadot",
    displayName: "Polkadot Relay Chain",
    symbols: [
      "DOT"
    ],
    decimals: [
      10
    ],
    standardAccount: "*25519",
    website: "https://polkadot.network"
  },
  {
    prefix: 1,
    network: "BareSr25519",
    displayName: "Bare 32-bit Schnorr/Ristretto (S/R 25519) public key.",
    symbols: [],
    decimals: [],
    standardAccount: "Sr25519",
    website: null
  },
  {
    prefix: 2,
    network: "kusama",
    displayName: "Kusama Relay Chain",
    symbols: [
      "KSM"
    ],
    decimals: [
      12
    ],
    standardAccount: "*25519",
    website: "https://kusama.network"
  },
  {
    prefix: 3,
    network: "BareEd25519",
    displayName: "Bare 32-bit Ed25519 public key.",
    symbols: [],
    decimals: [],
    standardAccount: "Ed25519",
    website: null
  },
  {
    prefix: 4,
    network: "katalchain",
    displayName: "Katal Chain",
    symbols: [],
    decimals: [],
    standardAccount: "*25519",
    website: null
  },
  {
    prefix: 5,
    network: "astar",
    displayName: "Astar Network",
    symbols: [
      "ASTR"
    ],
    decimals: [
      18
    ],
    standardAccount: "*25519",
    website: "https://astar.network"
  },
  {
    prefix: 6,
    network: "bifrost",
    displayName: "Bifrost",
    symbols: [
      "BNC"
    ],
    decimals: [
      12
    ],
    standardAccount: "*25519",
    website: "https://bifrost.finance/"
  },
  {
    prefix: 7,
    network: "edgeware",
    displayName: "Edgeware",
    symbols: [
      "EDG"
    ],
    decimals: [
      18
    ],
    standardAccount: "*25519",
    website: "https://edgewa.re"
  },
  {
    prefix: 8,
    network: "karura",
    displayName: "Karura",
    symbols: [
      "KAR"
    ],
    decimals: [
      12
    ],
    standardAccount: "*25519",
    website: "https://karura.network/"
  },
  {
    prefix: 9,
    network: "reynolds",
    displayName: "Laminar Reynolds Canary",
    symbols: [
      "REY"
    ],
    decimals: [
      18
    ],
    standardAccount: "*25519",
    website: "http://laminar.network/"
  },
  {
    prefix: 10,
    network: "acala",
    displayName: "Acala",
    symbols: [
      "ACA"
    ],
    decimals: [
      12
    ],
    standardAccount: "*25519",
    website: "https://acala.network/"
  },
  {
    prefix: 11,
    network: "laminar",
    displayName: "Laminar",
    symbols: [
      "LAMI"
    ],
    decimals: [
      18
    ],
    standardAccount: "*25519",
    website: "http://laminar.network/"
  },
  {
    prefix: 12,
    network: "polymesh",
    displayName: "Polymesh",
    symbols: [
      "POLYX"
    ],
    decimals: [
      6
    ],
    standardAccount: "*25519",
    website: "https://polymath.network/"
  },
  {
    prefix: 13,
    network: "integritee",
    displayName: "Integritee",
    symbols: [
      "TEER"
    ],
    decimals: [
      12
    ],
    standardAccount: "*25519",
    website: "https://integritee.network"
  },
  {
    prefix: 14,
    network: "totem",
    displayName: "Totem",
    symbols: [
      "TOTEM"
    ],
    decimals: [
      0
    ],
    standardAccount: "*25519",
    website: "https://totemaccounting.com"
  },
  {
    prefix: 15,
    network: "synesthesia",
    displayName: "Synesthesia",
    symbols: [
      "SYN"
    ],
    decimals: [
      12
    ],
    standardAccount: "*25519",
    website: "https://synesthesia.network/"
  },
  {
    prefix: 16,
    network: "kulupu",
    displayName: "Kulupu",
    symbols: [
      "KLP"
    ],
    decimals: [
      12
    ],
    standardAccount: "*25519",
    website: "https://kulupu.network/"
  },
  {
    prefix: 17,
    network: "dark",
    displayName: "Dark Mainnet",
    symbols: [],
    decimals: [],
    standardAccount: "*25519",
    website: null
  },
  {
    prefix: 18,
    network: "darwinia",
    displayName: "Darwinia Network",
    symbols: [
      "RING"
    ],
    decimals: [
      18
    ],
    standardAccount: "secp256k1",
    website: "https://darwinia.network"
  },
  {
    prefix: 19,
    network: "watr",
    displayName: "Watr Protocol",
    symbols: [
      "WATR"
    ],
    decimals: [
      18
    ],
    standardAccount: "*25519",
    website: "https://www.watr.org"
  },
  {
    prefix: 20,
    network: "stafi",
    displayName: "Stafi",
    symbols: [
      "FIS"
    ],
    decimals: [
      12
    ],
    standardAccount: "*25519",
    website: "https://stafi.io"
  },
  {
    prefix: 21,
    network: "karmachain",
    displayName: "Karmacoin",
    symbols: [
      "KCOIN"
    ],
    decimals: [
      6
    ],
    standardAccount: "*25519",
    website: "https://karmaco.in"
  },
  {
    prefix: 22,
    network: "dock-pos-mainnet",
    displayName: "Dock Mainnet",
    symbols: [
      "DCK"
    ],
    decimals: [
      6
    ],
    standardAccount: "*25519",
    website: "https://dock.io"
  },
  {
    prefix: 23,
    network: "shift",
    displayName: "ShiftNrg",
    symbols: [],
    decimals: [],
    standardAccount: "*25519",
    website: null
  },
  {
    prefix: 24,
    network: "zero",
    displayName: "ZERO",
    symbols: [
      "ZERO"
    ],
    decimals: [
      18
    ],
    standardAccount: "*25519",
    website: "https://zero.io"
  },
  {
    prefix: 25,
    network: "zero-alphaville",
    displayName: "ZERO Alphaville",
    symbols: [
      "ZERO"
    ],
    decimals: [
      18
    ],
    standardAccount: "*25519",
    website: "https://zero.io"
  },
  {
    prefix: 26,
    network: "jupiter",
    displayName: "Jupiter",
    symbols: [
      "jDOT"
    ],
    decimals: [
      10
    ],
    standardAccount: "*25519",
    website: "https://jupiter.patract.io"
  },
  {
    prefix: 27,
    network: "kabocha",
    displayName: "Kabocha",
    symbols: [
      "KAB"
    ],
    decimals: [
      12
    ],
    standardAccount: "*25519",
    website: "https://kabocha.network"
  },
  {
    prefix: 28,
    network: "subsocial",
    displayName: "Subsocial",
    symbols: [],
    decimals: [],
    standardAccount: "*25519",
    website: null
  },
  {
    prefix: 29,
    network: "cord",
    displayName: "CORD Network",
    symbols: [
      "DHI",
      "WAY"
    ],
    decimals: [
      12,
      12
    ],
    standardAccount: "*25519",
    website: "https://cord.network/"
  },
  {
    prefix: 30,
    network: "phala",
    displayName: "Phala Network",
    symbols: [
      "PHA"
    ],
    decimals: [
      12
    ],
    standardAccount: "*25519",
    website: "https://phala.network"
  },
  {
    prefix: 31,
    network: "litentry",
    displayName: "Litentry Network",
    symbols: [
      "LIT"
    ],
    decimals: [
      12
    ],
    standardAccount: "*25519",
    website: "https://litentry.com/"
  },
  {
    prefix: 32,
    network: "robonomics",
    displayName: "Robonomics",
    symbols: [
      "XRT"
    ],
    decimals: [
      9
    ],
    standardAccount: "*25519",
    website: "https://robonomics.network"
  },
  {
    prefix: 33,
    network: "datahighway",
    displayName: "DataHighway",
    symbols: [],
    decimals: [],
    standardAccount: "*25519",
    website: null
  },
  {
    prefix: 34,
    network: "ares",
    displayName: "Ares Protocol",
    symbols: [
      "ARES"
    ],
    decimals: [
      12
    ],
    standardAccount: "*25519",
    website: "https://www.aresprotocol.com/"
  },
  {
    prefix: 35,
    network: "vln",
    displayName: "Valiu Liquidity Network",
    symbols: [
      "USDv"
    ],
    decimals: [
      15
    ],
    standardAccount: "*25519",
    website: "https://valiu.com/"
  },
  {
    prefix: 36,
    network: "centrifuge",
    displayName: "Centrifuge Chain",
    symbols: [
      "CFG"
    ],
    decimals: [
      18
    ],
    standardAccount: "*25519",
    website: "https://centrifuge.io/"
  },
  {
    prefix: 37,
    network: "nodle",
    displayName: "Nodle Chain",
    symbols: [
      "NODL"
    ],
    decimals: [
      11
    ],
    standardAccount: "*25519",
    website: "https://nodle.io/"
  },
  {
    prefix: 38,
    network: "kilt",
    displayName: "KILT Spiritnet",
    symbols: [
      "KILT"
    ],
    decimals: [
      15
    ],
    standardAccount: "*25519",
    website: "https://kilt.io/"
  },
  {
    prefix: 39,
    network: "mathchain",
    displayName: "MathChain mainnet",
    symbols: [
      "MATH"
    ],
    decimals: [
      18
    ],
    standardAccount: "*25519",
    website: "https://mathwallet.org"
  },
  {
    prefix: 40,
    network: "mathchain-testnet",
    displayName: "MathChain testnet",
    symbols: [
      "MATH"
    ],
    decimals: [
      18
    ],
    standardAccount: "*25519",
    website: "https://mathwallet.org"
  },
  {
    prefix: 41,
    network: "polimec",
    displayName: "Polimec Protocol",
    symbols: [
      "PLMC"
    ],
    decimals: [
      10
    ],
    standardAccount: "*25519",
    website: "https://www.polimec.org/"
  },
  {
    prefix: 42,
    network: "substrate",
    displayName: "Substrate",
    symbols: [],
    decimals: [],
    standardAccount: "*25519",
    website: "https://substrate.io/"
  },
  {
    prefix: 43,
    network: "BareSecp256k1",
    displayName: "Bare 32-bit ECDSA SECP-256k1 public key.",
    symbols: [],
    decimals: [],
    standardAccount: "secp256k1",
    website: null
  },
  {
    prefix: 44,
    network: "chainx",
    displayName: "ChainX",
    symbols: [
      "PCX"
    ],
    decimals: [
      8
    ],
    standardAccount: "*25519",
    website: "https://chainx.org/"
  },
  {
    prefix: 45,
    network: "uniarts",
    displayName: "UniArts Network",
    symbols: [
      "UART",
      "UINK"
    ],
    decimals: [
      12,
      12
    ],
    standardAccount: "*25519",
    website: "https://uniarts.me"
  },
  {
    prefix: 46,
    network: "reserved46",
    displayName: "This prefix is reserved.",
    symbols: [],
    decimals: [],
    standardAccount: null,
    website: null
  },
  {
    prefix: 47,
    network: "reserved47",
    displayName: "This prefix is reserved.",
    symbols: [],
    decimals: [],
    standardAccount: null,
    website: null
  },
  {
    prefix: 48,
    network: "neatcoin",
    displayName: "Neatcoin Mainnet",
    symbols: [
      "NEAT"
    ],
    decimals: [
      12
    ],
    standardAccount: "*25519",
    website: "https://neatcoin.org"
  },
  {
    prefix: 49,
    network: "picasso",
    displayName: "Picasso",
    symbols: [
      "PICA"
    ],
    decimals: [
      12
    ],
    standardAccount: "*25519",
    website: "https://picasso.composable.finance"
  },
  {
    prefix: 50,
    network: "composable",
    displayName: "Composable Finance",
    symbols: [
      "LAYR"
    ],
    decimals: [
      12
    ],
    standardAccount: "*25519",
    website: "https://composable.finance"
  },
  {
    prefix: 51,
    network: "oak",
    displayName: "OAK Network",
    symbols: [
      "OAK",
      "TUR"
    ],
    decimals: [
      10,
      10
    ],
    standardAccount: "*25519",
    website: "https://oak.tech"
  },
  {
    prefix: 52,
    network: "KICO",
    displayName: "KICO",
    symbols: [
      "KICO"
    ],
    decimals: [
      14
    ],
    standardAccount: "*25519",
    website: "https://dico.io"
  },
  {
    prefix: 53,
    network: "DICO",
    displayName: "DICO",
    symbols: [
      "DICO"
    ],
    decimals: [
      14
    ],
    standardAccount: "*25519",
    website: "https://dico.io"
  },
  {
    prefix: 54,
    network: "cere",
    displayName: "Cere Network",
    symbols: [
      "CERE"
    ],
    decimals: [
      10
    ],
    standardAccount: "*25519",
    website: "https://cere.network"
  },
  {
    prefix: 55,
    network: "xxnetwork",
    displayName: "xx network",
    symbols: [
      "XX"
    ],
    decimals: [
      9
    ],
    standardAccount: "*25519",
    website: "https://xx.network"
  },
  {
    prefix: 56,
    network: "pendulum",
    displayName: "Pendulum chain",
    symbols: [
      "PEN"
    ],
    decimals: [
      12
    ],
    standardAccount: "*25519",
    website: "https://pendulumchain.org/"
  },
  {
    prefix: 57,
    network: "amplitude",
    displayName: "Amplitude chain",
    symbols: [
      "AMPE"
    ],
    decimals: [
      12
    ],
    standardAccount: "*25519",
    website: "https://pendulumchain.org/"
  },
  {
    prefix: 58,
    network: "eternal-civilization",
    displayName: "Eternal Civilization",
    symbols: [
      "ECC"
    ],
    decimals: [
      12
    ],
    standardAccount: "*25519",
    website: "http://www.ysknfr.cn/"
  },
  {
    prefix: 63,
    network: "hydradx",
    displayName: "HydraDX",
    symbols: [
      "HDX"
    ],
    decimals: [
      12
    ],
    standardAccount: "*25519",
    website: "https://hydradx.io"
  },
  {
    prefix: 65,
    network: "aventus",
    displayName: "Aventus Mainnet",
    symbols: [
      "AVT"
    ],
    decimals: [
      18
    ],
    standardAccount: "*25519",
    website: "https://aventus.io"
  },
  {
    prefix: 66,
    network: "crust",
    displayName: "Crust Network",
    symbols: [
      "CRU"
    ],
    decimals: [
      12
    ],
    standardAccount: "*25519",
    website: "https://crust.network"
  },
  {
    prefix: 67,
    network: "genshiro",
    displayName: "Genshiro Network",
    symbols: [
      "GENS",
      "EQD",
      "LPT0"
    ],
    decimals: [
      9,
      9,
      9
    ],
    standardAccount: "*25519",
    website: "https://genshiro.equilibrium.io"
  },
  {
    prefix: 68,
    network: "equilibrium",
    displayName: "Equilibrium Network",
    symbols: [
      "EQ"
    ],
    decimals: [
      9
    ],
    standardAccount: "*25519",
    website: "https://equilibrium.io"
  },
  {
    prefix: 69,
    network: "sora",
    displayName: "SORA Network",
    symbols: [
      "XOR"
    ],
    decimals: [
      18
    ],
    standardAccount: "*25519",
    website: "https://sora.org"
  },
  {
    prefix: 71,
    network: "p3d",
    displayName: "3DP network",
    symbols: [
      "P3D"
    ],
    decimals: [
      12
    ],
    standardAccount: "*25519",
    website: "https://3dpass.org"
  },
  {
    prefix: 72,
    network: "p3dt",
    displayName: "3DP test network",
    symbols: [
      "P3Dt"
    ],
    decimals: [
      12
    ],
    standardAccount: "*25519",
    website: "https://3dpass.org"
  },
  {
    prefix: 73,
    network: "zeitgeist",
    displayName: "Zeitgeist",
    symbols: [
      "ZTG"
    ],
    decimals: [
      10
    ],
    standardAccount: "*25519",
    website: "https://zeitgeist.pm"
  },
  {
    prefix: 77,
    network: "manta",
    displayName: "Manta network",
    symbols: [
      "MANTA"
    ],
    decimals: [
      18
    ],
    standardAccount: "*25519",
    website: "https://manta.network"
  },
  {
    prefix: 78,
    network: "calamari",
    displayName: "Calamari: Manta Canary Network",
    symbols: [
      "KMA"
    ],
    decimals: [
      12
    ],
    standardAccount: "*25519",
    website: "https://manta.network"
  },
  {
    prefix: 81,
    network: "sora_dot_para",
    displayName: "SORA Polkadot Parachain",
    symbols: [
      "XOR"
    ],
    decimals: [
      18
    ],
    standardAccount: "*25519",
    website: "https://sora.org"
  },
  {
    prefix: 88,
    network: "polkadex",
    displayName: "Polkadex Mainnet",
    symbols: [
      "PDEX"
    ],
    decimals: [
      12
    ],
    standardAccount: "*25519",
    website: "https://polkadex.trade"
  },
  {
    prefix: 89,
    network: "polkadexparachain",
    displayName: "Polkadex Parachain",
    symbols: [
      "PDEX"
    ],
    decimals: [
      12
    ],
    standardAccount: "*25519",
    website: "https://polkadex.trade"
  },
  {
    prefix: 90,
    network: "frequency",
    displayName: "Frequency",
    symbols: [
      "FRQCY"
    ],
    decimals: [
      8
    ],
    standardAccount: "*25519",
    website: "https://www.frequency.xyz"
  },
  {
    prefix: 92,
    network: "anmol",
    displayName: "Anmol Network",
    symbols: [
      "ANML"
    ],
    decimals: [
      18
    ],
    standardAccount: "*25519",
    website: "https://anmol.network/"
  },
  {
    prefix: 93,
    network: "fragnova",
    displayName: "Fragnova Network",
    symbols: [
      "NOVA"
    ],
    decimals: [
      12
    ],
    standardAccount: "*25519",
    website: "https://fragnova.com"
  },
  {
    prefix: 98,
    network: "polkasmith",
    displayName: "PolkaSmith Canary Network",
    symbols: [
      "PKS"
    ],
    decimals: [
      18
    ],
    standardAccount: "*25519",
    website: "https://polkafoundry.com"
  },
  {
    prefix: 99,
    network: "polkafoundry",
    displayName: "PolkaFoundry Network",
    symbols: [
      "PKF"
    ],
    decimals: [
      18
    ],
    standardAccount: "*25519",
    website: "https://polkafoundry.com"
  },
  {
    prefix: 100,
    network: "ibtida",
    displayName: "Anmol Network Ibtida Canary network",
    symbols: [
      "IANML"
    ],
    decimals: [
      18
    ],
    standardAccount: "*25519",
    website: "https://anmol.network/"
  },
  {
    prefix: 101,
    network: "origintrail-parachain",
    displayName: "OriginTrail Parachain",
    symbols: [
      "OTP"
    ],
    decimals: [
      12
    ],
    standardAccount: "*25519",
    website: "https://parachain.origintrail.io/"
  },
  {
    prefix: 105,
    network: "pontem-network",
    displayName: "Pontem Network",
    symbols: [
      "PONT"
    ],
    decimals: [
      10
    ],
    standardAccount: "*25519",
    website: "https://pontem.network"
  },
  {
    prefix: 110,
    network: "heiko",
    displayName: "Heiko",
    symbols: [
      "HKO"
    ],
    decimals: [
      12
    ],
    standardAccount: "*25519",
    website: "https://parallel.fi/"
  },
  {
    prefix: 113,
    network: "integritee-incognito",
    displayName: "Integritee Incognito",
    symbols: [],
    decimals: [],
    standardAccount: "*25519",
    website: "https://integritee.network"
  },
  {
    prefix: 117,
    network: "tinker",
    displayName: "Tinker",
    symbols: [
      "TNKR"
    ],
    decimals: [
      12
    ],
    standardAccount: "*25519",
    website: "https://invarch.network"
  },
  {
    prefix: 126,
    network: "joystream",
    displayName: "Joystream",
    symbols: [
      "JOY"
    ],
    decimals: [
      10
    ],
    standardAccount: "*25519",
    website: "https://www.joystream.org"
  },
  {
    prefix: 128,
    network: "clover",
    displayName: "Clover Finance",
    symbols: [
      "CLV"
    ],
    decimals: [
      18
    ],
    standardAccount: "*25519",
    website: "https://clover.finance"
  },
  {
    prefix: 129,
    network: "dorafactory-polkadot",
    displayName: "Dorafactory Polkadot Network",
    symbols: [
      "DORA"
    ],
    decimals: [
      12
    ],
    standardAccount: "*25519",
    website: "https://dorafactory.org"
  },
  {
    prefix: 131,
    network: "litmus",
    displayName: "Litmus Network",
    symbols: [
      "LIT"
    ],
    decimals: [
      12
    ],
    standardAccount: "*25519",
    website: "https://litentry.com/"
  },
  {
    prefix: 136,
    network: "altair",
    displayName: "Altair",
    symbols: [
      "AIR"
    ],
    decimals: [
      18
    ],
    standardAccount: "*25519",
    website: "https://centrifuge.io/"
  },
  {
    prefix: 137,
    network: "vara",
    displayName: "Vara Network",
    symbols: [
      "VARA"
    ],
    decimals: [
      12
    ],
    standardAccount: "*25519",
    website: "https://vara.network/"
  },
  {
    prefix: 172,
    network: "parallel",
    displayName: "Parallel",
    symbols: [
      "PARA"
    ],
    decimals: [
      12
    ],
    standardAccount: "*25519",
    website: "https://parallel.fi/"
  },
  {
    prefix: 252,
    network: "social-network",
    displayName: "Social Network",
    symbols: [
      "NET"
    ],
    decimals: [
      18
    ],
    standardAccount: "*25519",
    website: "https://social.network"
  },
  {
    prefix: 255,
    network: "quartz_mainnet",
    displayName: "QUARTZ by UNIQUE",
    symbols: [
      "QTZ"
    ],
    decimals: [
      18
    ],
    standardAccount: "*25519",
    website: "https://unique.network"
  },
  {
    prefix: 268,
    network: "pioneer_network",
    displayName: "Pioneer Network by Bit.Country",
    symbols: [
      "NEER"
    ],
    decimals: [
      18
    ],
    standardAccount: "*25519",
    website: "https://bit.country"
  },
  {
    prefix: 420,
    network: "sora_kusama_para",
    displayName: "SORA Kusama Parachain",
    symbols: [
      "XOR"
    ],
    decimals: [
      18
    ],
    standardAccount: "*25519",
    website: "https://sora.org"
  },
  {
    prefix: 440,
    network: "allfeat_network",
    displayName: "Allfeat Network",
    symbols: [
      "AFT"
    ],
    decimals: [
      12
    ],
    standardAccount: "*25519",
    website: "https://allfeat.network"
  },
  {
    prefix: 666,
    network: "metaquity_network",
    displayName: "Metaquity Network",
    symbols: [
      "MQTY"
    ],
    decimals: [
      18
    ],
    standardAccount: "*25519",
    website: "https://metaquity.xyz/"
  },
  {
    prefix: 777,
    network: "curio",
    displayName: "Curio",
    symbols: [
      "CGT"
    ],
    decimals: [
      18
    ],
    standardAccount: "*25519",
    website: "https://parachain.capitaldex.exchange/"
  },
  {
    prefix: 789,
    network: "geek",
    displayName: "GEEK Network",
    symbols: [
      "GEEK"
    ],
    decimals: [
      18
    ],
    standardAccount: "*25519",
    website: "https://geek.gl"
  },
  {
    prefix: 995,
    network: "ternoa",
    displayName: "Ternoa",
    symbols: [
      "CAPS"
    ],
    decimals: [
      18
    ],
    standardAccount: "*25519",
    website: "https://www.ternoa.network"
  },
  {
    prefix: 1110,
    network: "efinity",
    displayName: "Efinity",
    symbols: [
      "EFI"
    ],
    decimals: [
      18
    ],
    standardAccount: "*25519",
    website: "https://efinity.io/"
  },
  {
    prefix: 1221,
    network: "peaq",
    displayName: "Peaq Network",
    symbols: [
      "PEAQ"
    ],
    decimals: [
      18
    ],
    standardAccount: "Sr25519",
    website: "https://www.peaq.network/"
  },
  {
    prefix: 1222,
    network: "krest",
    displayName: "Krest Network",
    symbols: [
      "KREST"
    ],
    decimals: [
      18
    ],
    standardAccount: "Sr25519",
    website: "https://www.peaq.network/"
  },
  {
    prefix: 1284,
    network: "moonbeam",
    displayName: "Moonbeam",
    symbols: [
      "GLMR"
    ],
    decimals: [
      18
    ],
    standardAccount: "secp256k1",
    website: "https://moonbeam.network"
  },
  {
    prefix: 1285,
    network: "moonriver",
    displayName: "Moonriver",
    symbols: [
      "MOVR"
    ],
    decimals: [
      18
    ],
    standardAccount: "secp256k1",
    website: "https://moonbeam.network"
  },
  {
    prefix: 1328,
    network: "ajuna",
    displayName: "Ajuna Network",
    symbols: [
      "AJUN"
    ],
    decimals: [
      12
    ],
    standardAccount: "*25519",
    website: "https://ajuna.io"
  },
  {
    prefix: 1337,
    network: "bajun",
    displayName: "Bajun Network",
    symbols: [
      "BAJU"
    ],
    decimals: [
      12
    ],
    standardAccount: "*25519",
    website: "https://ajuna.io"
  },
  {
    prefix: 1516,
    network: "societal",
    displayName: "Societal",
    symbols: [
      "SCTL"
    ],
    decimals: [
      12
    ],
    standardAccount: "*25519",
    website: "https://www.sctl.xyz"
  },
  {
    prefix: 1985,
    network: "seals",
    displayName: "Seals Network",
    symbols: [
      "SEAL"
    ],
    decimals: [
      9
    ],
    standardAccount: "*25519",
    website: "https://seals.app"
  },
  {
    prefix: 2007,
    network: "kapex",
    displayName: "Kapex",
    symbols: [
      "KAPEX"
    ],
    decimals: [
      12
    ],
    standardAccount: "*25519",
    website: "https://totemaccounting.com"
  },
  {
    prefix: 2009,
    network: "cloudwalk_mainnet",
    displayName: "CloudWalk Network Mainnet",
    symbols: [
      "CWN"
    ],
    decimals: [
      18
    ],
    standardAccount: "*25519",
    website: "https://explorer.mainnet.cloudwalk.io"
  },
  {
    prefix: 2021,
    network: "logion",
    displayName: "logion network",
    symbols: [
      "LGNT"
    ],
    decimals: [
      18
    ],
    standardAccount: "*25519",
    website: "https://logion.network"
  },
  {
    prefix: 2032,
    network: "interlay",
    displayName: "Interlay",
    symbols: [
      "INTR"
    ],
    decimals: [
      10
    ],
    standardAccount: "*25519",
    website: "https://interlay.io/"
  },
  {
    prefix: 2092,
    network: "kintsugi",
    displayName: "Kintsugi",
    symbols: [
      "KINT"
    ],
    decimals: [
      12
    ],
    standardAccount: "*25519",
    website: "https://interlay.io/"
  },
  {
    prefix: 2106,
    network: "bitgreen",
    displayName: "Bitgreen",
    symbols: [
      "BBB"
    ],
    decimals: [
      18
    ],
    standardAccount: "*25519",
    website: "https://bitgreen.org/"
  },
  {
    prefix: 2112,
    network: "chainflip",
    displayName: "Chainflip",
    symbols: [
      "FLIP"
    ],
    decimals: [
      18
    ],
    standardAccount: "*25519",
    website: "https://chainflip.io/"
  },
  {
    prefix: 2199,
    network: "moonsama",
    displayName: "Moonsama",
    symbols: [
      "SAMA"
    ],
    decimals: [
      18
    ],
    standardAccount: "secp256k1",
    website: "https://moonsama.com"
  },
  {
    prefix: 2206,
    network: "ICE",
    displayName: "ICE Network",
    symbols: [
      "ICY"
    ],
    decimals: [
      18
    ],
    standardAccount: "*25519",
    website: "https://icenetwork.io"
  },
  {
    prefix: 2207,
    network: "SNOW",
    displayName: "SNOW: ICE Canary Network",
    symbols: [
      "ICZ"
    ],
    decimals: [
      18
    ],
    standardAccount: "*25519",
    website: "https://icenetwork.io"
  },
  {
    prefix: 2254,
    network: "subspace_testnet",
    displayName: "Subspace testnet",
    symbols: [
      "tSSC"
    ],
    decimals: [
      18
    ],
    standardAccount: "*25519",
    website: "https://subspace.network"
  },
  {
    prefix: 3333,
    network: "peerplays",
    displayName: "Peerplays",
    symbols: [
      "PPY"
    ],
    decimals: [
      18
    ],
    standardAccount: "secp256k1",
    website: "https://www.peerplays.com/"
  },
  {
    prefix: 4450,
    network: "g1",
    displayName: "1",
    symbols: [
      "G1"
    ],
    decimals: [
      2
    ],
    standardAccount: "*25519",
    website: "https://duniter.org"
  },
  {
    prefix: 5234,
    network: "humanode",
    displayName: "Humanode Network",
    symbols: [
      "HMND"
    ],
    decimals: [
      18
    ],
    standardAccount: "*25519",
    website: "https://humanode.io"
  },
  {
    prefix: 5845,
    network: "tangle",
    displayName: "Tangle Network",
    symbols: [
      "TNT"
    ],
    decimals: [
      18
    ],
    standardAccount: "*25519",
    website: "https://www.tangle.tools/"
  },
  {
    prefix: 6094,
    network: "subspace",
    displayName: "Subspace",
    symbols: [
      "SSC"
    ],
    decimals: [
      18
    ],
    standardAccount: "*25519",
    website: "https://subspace.network"
  },
  {
    prefix: 7007,
    network: "tidefi",
    displayName: "Tidefi",
    symbols: [
      "TDFY"
    ],
    decimals: [
      12
    ],
    standardAccount: "*25519",
    website: "https://tidefi.com"
  },
  {
    prefix: 7013,
    network: "gm",
    displayName: "GM",
    symbols: [
      "FREN",
      "GM",
      "GN"
    ],
    decimals: [
      12,
      0,
      0
    ],
    standardAccount: "*25519",
    website: "https://gmordie.com"
  },
  {
    prefix: 7306,
    network: "krigan",
    displayName: "Krigan Network",
    symbols: [
      "KRGN"
    ],
    decimals: [
      9
    ],
    standardAccount: "*25519",
    website: "https://krigan.network"
  },
  {
    prefix: 7391,
    network: "unique_mainnet",
    displayName: "Unique Network",
    symbols: [
      "UNQ"
    ],
    decimals: [
      18
    ],
    standardAccount: "*25519",
    website: "https://unique.network"
  },
  {
    prefix: 8866,
    network: "golden_gate",
    displayName: "Golden Gate",
    symbols: [
      "GGX"
    ],
    decimals: [
      18
    ],
    standardAccount: "*25519",
    website: "https://ggxchain.io/"
  },
  {
    prefix: 8883,
    network: "sapphire_mainnet",
    displayName: "Sapphire by Unique",
    symbols: [
      "QTZ"
    ],
    decimals: [
      18
    ],
    standardAccount: "*25519",
    website: "https://unique.network"
  },
  {
    prefix: 8886,
    network: "golden_gate_sydney",
    displayName: "Golden Gate Sydney",
    symbols: [
      "GGXT"
    ],
    decimals: [
      18
    ],
    standardAccount: "*25519",
    website: "https://ggxchain.io/"
  },
  {
    prefix: 9072,
    network: "hashed",
    displayName: "Hashed Network",
    symbols: [
      "HASH"
    ],
    decimals: [
      18
    ],
    standardAccount: "*25519",
    website: "https://hashed.network"
  },
  {
    prefix: 9807,
    network: "dentnet",
    displayName: "DENTNet",
    symbols: [
      "DENTX"
    ],
    decimals: [
      18
    ],
    standardAccount: "*25519",
    website: "https://www.dentnet.io"
  },
  {
    prefix: 9935,
    network: "t3rn",
    displayName: "t3rn",
    symbols: [
      "TRN"
    ],
    decimals: [
      12
    ],
    standardAccount: "*25519",
    website: "https://t3rn.io/"
  },
  {
    prefix: 10041,
    network: "basilisk",
    displayName: "Basilisk",
    symbols: [
      "BSX"
    ],
    decimals: [
      12
    ],
    standardAccount: "*25519",
    website: "https://bsx.fi"
  },
  {
    prefix: 11330,
    network: "cess-testnet",
    displayName: "CESS Testnet",
    symbols: [
      "TCESS"
    ],
    decimals: [
      12
    ],
    standardAccount: "*25519",
    website: "https://cess.cloud"
  },
  {
    prefix: 11331,
    network: "cess",
    displayName: "CESS",
    symbols: [
      "CESS"
    ],
    decimals: [
      12
    ],
    standardAccount: "*25519",
    website: "https://cess.cloud"
  },
  {
    prefix: 11486,
    network: "luhn",
    displayName: "Luhn Network",
    symbols: [
      "LUHN"
    ],
    decimals: [
      18
    ],
    standardAccount: "*25519",
    website: "https://luhn.network"
  },
  {
    prefix: 11820,
    network: "contextfree",
    displayName: "Automata ContextFree",
    symbols: [
      "CTX"
    ],
    decimals: [
      18
    ],
    standardAccount: "*25519",
    website: "https://ata.network"
  },
  {
    prefix: 12155,
    network: "impact",
    displayName: "Impact Protocol Network",
    symbols: [
      "BSTY"
    ],
    decimals: [
      18
    ],
    standardAccount: "*25519",
    website: "https://impactprotocol.network/"
  },
  {
    prefix: 12191,
    network: "nftmart",
    displayName: "NFTMart",
    symbols: [
      "NMT"
    ],
    decimals: [
      12
    ],
    standardAccount: "*25519",
    website: "https://nftmart.io"
  },
  {
    prefix: 13116,
    network: "bittensor",
    displayName: "Bittensor",
    symbols: [
      "TAO"
    ],
    decimals: [
      9
    ],
    standardAccount: "*25519",
    website: "https://bittensor.com"
  },
  {
    prefix: 14697,
    network: "goro",
    displayName: "GORO Network",
    symbols: [
      "GORO"
    ],
    decimals: [
      9
    ],
    standardAccount: "*25519",
    website: "https://goro.network"
  }
], Ny = {
  kusama: [
    "0xb0a8d493285c2df73290dfb7e61f870f17b41801197a149ca93654499ea3dafe",
    "0xe3777fa922cafbff200cadeaea1a76bd7898ad5b89f7848999058b50e715f636",
    "0x3fd7b9eb6a00376e5be61f01abb429ffb0b104be05eaff4d458da48fcd425baf"
  ],
  polkadot: ["0x91b171bb158e2d3848fa23a9f1c25182fb8e20313b2c1eb49219da7a70ce90c3"],
  rococo: [
    "0x6408de7737c59c238890533af25896a2c20608d8b380bb01029acb392781063e",
    "0xaaf2cd1b74b5f726895921259421b534124726263982522174147046b8827897",
    "0x037f5f3c8e67b314062025fc886fcd6238ea25a4a9b45dce8d246815c9ebe770",
    "0xc196f81260cf1686172b47a79cf002120735d7cb0eb1474e8adce56618456fff",
    "0xf6e9983c37baf68846fedafe21e56718790e39fb1c582abc408b81bc7b208f9a",
    "0x5fce687da39305dfe682b117f0820b319348e8bb37eb16cf34acbf6a202de9d9",
    "0xe7c3d5edde7db964317cd9b51a3a059d7cd99f81bdbce14990047354334c9779",
    "0x1611e1dbf0405379b861e2e27daa90f480b2e6d3682414a80835a52e8cb8a215",
    "0x343442f12fa715489a8714e79a7b264ea88c0d5b8c66b684a7788a516032f6b9",
    "0x78bcd530c6b3a068bc17473cf5d2aff9c287102bed9af3ae3c41c33b9d6c6147",
    "0x47381ee0697153d64404fc578392c8fd5cba9073391908f46c888498415647bd",
    "0x19c0e4fa8ab75f5ac7865e0b8f74ff91eb9a100d336f423cd013a8befba40299"
  ],
  westend: ["0xe143f23803ac50e8f6f8e62695d1ce9e4e1d68aa36c1cd2cfd15340213f3423e"]
}, GE = {
  centrifuge: "polkadot",
  kusama: "polkadot",
  polkadot: "polkadot",
  sora: "polkadot",
  statemine: "polkadot",
  statemint: "polkadot",
  westmint: "polkadot"
}, ZE = {
  acala: 787,
  ajuna: 354,
  "aleph-node": 643,
  astar: 810,
  bifrost: 788,
  "bifrost-kusama": 788,
  centrifuge: 747,
  composable: 354,
  darwinia: 354,
  "dock-mainnet": 594,
  edgeware: 523,
  enjin: 1155,
  equilibrium: 99999997,
  genshiro: 99999996,
  hydradx: 354,
  "interlay-parachain": 354,
  karura: 686,
  khala: 434,
  kusama: 434,
  matrixchain: 1155,
  nodle: 1003,
  origintrail: 354,
  parallel: 354,
  pendulum: 354,
  phala: 354,
  picasso: 434,
  polkadex: 799,
  polkadot: 354,
  polymesh: 595,
  quartz: 631,
  sora: 617,
  stafi: 907,
  statemine: 434,
  statemint: 354,
  ternoa: 995,
  unique: 661,
  vtb: 694,
  xxnetwork: 1955,
  zeitgeist: 354
}, JE = {
  "": !0,
  "cess-testnet": !0,
  "dock-testnet": !0,
  jupiter: !0,
  "mathchain-testnet": !0,
  p3dt: !0,
  subspace_testnet: !0,
  "zero-alphaville": !0
}, zf = [0, 2, 42], KE = ["testnet"];
function YE(n) {
  var i, s;
  const e = n.network || "", t = e.replace(/_/g, "-").split("-"), r = n;
  return r.slip44 = ZE[e], r.hasLedgerSupport = !!r.slip44, r.genesisHash = Ny[e] || [], r.icon = GE[e] || "substrate", r.isTestnet = !!JE[e] || KE.includes(t[t.length - 1]), r.isIgnored = r.isTestnet || !(n.standardAccount && ((i = n.decimals) != null && i.length) && ((s = n.symbols) != null && s.length)) && n.prefix !== 42, r;
}
function QE({ genesisHash: n, prefix: e }) {
  return !!n.length || e === 42;
}
function $E(n) {
  return !n.isIgnored && !!n.network;
}
function eC(n, e) {
  const t = zf.includes(n.prefix), r = zf.includes(e.prefix);
  return t === r ? t ? 0 : n.displayName.localeCompare(e.displayName) : t ? -1 : 1;
}
const tC = Ty.map(YE), Ry = tC.filter($E).sort(eC);
Ry.filter(QE);
const wa = {
  allowedDecodedLengths: [1, 2, 4, 8, 32, 33],
  // publicKey has prefix + 2 checksum bytes, short only prefix + 1 checksum byte
  allowedEncodedLengths: [3, 4, 6, 10, 35, 36, 37, 38],
  allowedPrefix: Ry.map(({ prefix: n }) => n),
  prefix: 42
};
function rn(n, e, t = -1) {
  if (!n)
    throw new Error("Invalid empty address passed");
  if (te(n) || ye(n))
    return j(n);
  try {
    const r = WE(n);
    if (!wa.allowedEncodedLengths.includes(r.length))
      throw new Error("Invalid decoded address length");
    const [i, s, a, o] = XE(r);
    if (!i && !e)
      throw new Error("Invalid decoded address checksum");
    if (t !== -1 && t !== o)
      throw new Error(`Expected ss58Format ${t}, received ${o}`);
    return r.slice(a, s);
  } catch (r) {
    throw new Error(`Decoding ${n}: ${r.message}`);
  }
}
const Xf = { isLe: !1 }, mc = { isLe: !0 }, nC = { bitLength: 32, isLe: !1 }, gc = { bitLength: 32, isLe: !0 }, Ui = { bitLength: 256, isLe: !1 }, rC = { bitLength: 256, isLe: !0 }, iC = /^\d+$/, sC = 32;
class Lu {
  constructor() {
    b(this, "__internal__chainCode", new Uint8Array(32));
    b(this, "__internal__isHard", !1);
  }
  static from(e) {
    const t = new Lu(), [r, i] = e.startsWith("/") ? [e.substring(1), !0] : [e, !1];
    return t.soft(iC.test(r) ? new Z(r, 10) : r), i ? t.harden() : t;
  }
  get chainCode() {
    return this.__internal__chainCode;
  }
  get isHard() {
    return this.__internal__isHard;
  }
  get isSoft() {
    return !this.__internal__isHard;
  }
  hard(e) {
    return this.soft(e).harden();
  }
  harden() {
    return this.__internal__isHard = !0, this;
  }
  soft(e) {
    return xe(e) || Yt(e) || vr(e) ? this.soft(Lt(e, rC)) : ye(e) ? this.soft(Mt(e)) : Pe(e) ? this.soft(wn(Ze(e))) : e.length > sC ? this.soft(hn(e)) : (this.__internal__chainCode.fill(0), this.__internal__chainCode.set(e, 0), this);
  }
  soften() {
    return this.__internal__isHard = !1, this;
  }
}
const aC = /\/(\/?)([^/]+)/g;
function Iy(n) {
  const e = n.match(aC), t = [];
  let r = "";
  if (e) {
    r = e.join("");
    for (const i of e)
      t.push(Lu.from(i.substring(1)));
  }
  if (r !== n)
    throw new Error(`Re-constructed path "${r}" does not match input`);
  return {
    parts: e,
    path: t
  };
}
const oC = /^(\w+( \w+)*)((\/\/?[^/]+)*)(\/\/\/(.*))?$/;
function cC(n) {
  const e = n.match(oC);
  if (e === null)
    throw new Error("Unable to match provided value to a secret URI");
  const [, t, , r, , , i] = e, { path: s } = Iy(r);
  return {
    derivePath: r,
    password: i,
    path: s,
    phrase: t
  };
}
const lC = wn(Ze("Secp256k1HDKD"));
function uC(n, e) {
  if (!te(e) || e.length !== 32)
    throw new Error("Invalid chainCode passed to derive");
  return hn(Me(lC, n, e), 256);
}
function dC(n, e, t, r) {
  if (typeof n.setBigUint64 == "function")
    return n.setBigUint64(e, t, r);
  const i = BigInt(32), s = BigInt(4294967295), a = Number(t >> i & s), o = Number(t & s), c = r ? 4 : 0, l = r ? 0 : 4;
  n.setUint32(e + c, a, r), n.setUint32(e + l, o, r);
}
class Oy extends yo {
  constructor(e, t, r, i) {
    super(), this.blockLen = e, this.outputLen = t, this.padOffset = r, this.isLE = i, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(e), this.view = _a(this.buffer);
  }
  update(e) {
    Wr(this);
    const { view: t, buffer: r, blockLen: i } = this;
    e = In(e);
    const s = e.length;
    for (let a = 0; a < s; ) {
      const o = Math.min(i - this.pos, s - a);
      if (o === i) {
        const c = _a(e);
        for (; i <= s - a; a += i)
          this.process(c, a);
        continue;
      }
      r.set(e.subarray(a, a + o), this.pos), this.pos += o, a += o, this.pos === i && (this.process(t, 0), this.pos = 0);
    }
    return this.length += e.length, this.roundClean(), this;
  }
  digestInto(e) {
    Wr(this), Iu(e, this), this.finished = !0;
    const { buffer: t, view: r, blockLen: i, isLE: s } = this;
    let { pos: a } = this;
    t[a++] = 128, this.buffer.subarray(a).fill(0), this.padOffset > i - a && (this.process(r, 0), a = 0);
    for (let f = a; f < i; f++)
      t[f] = 0;
    dC(r, i - 8, BigInt(this.length * 8), s), this.process(r, 0);
    const o = _a(e), c = this.outputLen;
    if (c % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const l = c / 4, u = this.get();
    if (l > u.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let f = 0; f < l; f++)
      o.setUint32(4 * f, u[f], s);
  }
  digest() {
    const { buffer: e, outputLen: t } = this;
    this.digestInto(e);
    const r = e.slice(0, t);
    return this.destroy(), r;
  }
  _cloneInto(e) {
    e || (e = new this.constructor()), e.set(...this.get());
    const { blockLen: t, buffer: r, length: i, finished: s, destroyed: a, pos: o } = this;
    return e.length = i, e.pos = o, e.finished = s, e.destroyed = a, i % t && e.buffer.set(r), e;
  }
}
const fC = (n, e, t) => n & e ^ ~n & t, hC = (n, e, t) => n & e ^ n & t ^ e & t, pC = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), Ar = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), Pr = /* @__PURE__ */ new Uint32Array(64);
class mC extends Oy {
  constructor() {
    super(64, 32, 8, !1), this.A = Ar[0] | 0, this.B = Ar[1] | 0, this.C = Ar[2] | 0, this.D = Ar[3] | 0, this.E = Ar[4] | 0, this.F = Ar[5] | 0, this.G = Ar[6] | 0, this.H = Ar[7] | 0;
  }
  get() {
    const { A: e, B: t, C: r, D: i, E: s, F: a, G: o, H: c } = this;
    return [e, t, r, i, s, a, o, c];
  }
  // prettier-ignore
  set(e, t, r, i, s, a, o, c) {
    this.A = e | 0, this.B = t | 0, this.C = r | 0, this.D = i | 0, this.E = s | 0, this.F = a | 0, this.G = o | 0, this.H = c | 0;
  }
  process(e, t) {
    for (let f = 0; f < 16; f++, t += 4)
      Pr[f] = e.getUint32(t, !1);
    for (let f = 16; f < 64; f++) {
      const m = Pr[f - 15], y = Pr[f - 2], _ = Hn(m, 7) ^ Hn(m, 18) ^ m >>> 3, v = Hn(y, 17) ^ Hn(y, 19) ^ y >>> 10;
      Pr[f] = v + Pr[f - 7] + _ + Pr[f - 16] | 0;
    }
    let { A: r, B: i, C: s, D: a, E: o, F: c, G: l, H: u } = this;
    for (let f = 0; f < 64; f++) {
      const m = Hn(o, 6) ^ Hn(o, 11) ^ Hn(o, 25), y = u + m + fC(o, c, l) + pC[f] + Pr[f] | 0, v = (Hn(r, 2) ^ Hn(r, 13) ^ Hn(r, 22)) + hC(r, i, s) | 0;
      u = l, l = c, c = o, o = a + y | 0, a = s, s = i, i = r, r = y + v | 0;
    }
    r = r + this.A | 0, i = i + this.B | 0, s = s + this.C | 0, a = a + this.D | 0, o = o + this.E | 0, c = c + this.F | 0, l = l + this.G | 0, u = u + this.H | 0, this.set(r, i, s, a, o, c, l, u);
  }
  roundClean() {
    Pr.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
const js = /* @__PURE__ */ Ou(() => new mC());
const My = BigInt(0), _o = BigInt(1), gC = BigInt(2);
function er(n) {
  return n instanceof Uint8Array || n != null && typeof n == "object" && n.constructor.name === "Uint8Array";
}
const yC = /* @__PURE__ */ Array.from({ length: 256 }, (n, e) => e.toString(16).padStart(2, "0"));
function si(n) {
  if (!er(n))
    throw new Error("Uint8Array expected");
  let e = "";
  for (let t = 0; t < n.length; t++)
    e += yC[n[t]];
  return e;
}
function Ly(n) {
  const e = n.toString(16);
  return e.length & 1 ? `0${e}` : e;
}
function Du(n) {
  if (typeof n != "string")
    throw new Error("hex string expected, got " + typeof n);
  return BigInt(n === "" ? "0" : `0x${n}`);
}
const rr = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
function Gf(n) {
  if (n >= rr._0 && n <= rr._9)
    return n - rr._0;
  if (n >= rr._A && n <= rr._F)
    return n - (rr._A - 10);
  if (n >= rr._a && n <= rr._f)
    return n - (rr._a - 10);
}
function Vi(n) {
  if (typeof n != "string")
    throw new Error("hex string expected, got " + typeof n);
  const e = n.length, t = e / 2;
  if (e % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + e);
  const r = new Uint8Array(t);
  for (let i = 0, s = 0; i < t; i++, s += 2) {
    const a = Gf(n.charCodeAt(s)), o = Gf(n.charCodeAt(s + 1));
    if (a === void 0 || o === void 0) {
      const c = n[s] + n[s + 1];
      throw new Error('hex string expected, got non-hex character "' + c + '" at index ' + s);
    }
    r[i] = a * 16 + o;
  }
  return r;
}
function ri(n) {
  return Du(si(n));
}
function Ai(n) {
  if (!er(n))
    throw new Error("Uint8Array expected");
  return Du(si(Uint8Array.from(n).reverse()));
}
function Bi(n, e) {
  return Vi(n.toString(16).padStart(e * 2, "0"));
}
function As(n, e) {
  return Bi(n, e).reverse();
}
function _C(n) {
  return Vi(Ly(n));
}
function Pt(n, e, t) {
  let r;
  if (typeof e == "string")
    try {
      r = Vi(e);
    } catch (s) {
      throw new Error(`${n} must be valid hex string, got "${e}". Cause: ${s}`);
    }
  else if (er(e))
    r = Uint8Array.from(e);
  else
    throw new Error(`${n} must be hex string or Uint8Array`);
  const i = r.length;
  if (typeof t == "number" && i !== t)
    throw new Error(`${n} expected ${t} bytes, got ${i}`);
  return r;
}
function ai(...n) {
  let e = 0;
  for (let i = 0; i < n.length; i++) {
    const s = n[i];
    if (!er(s))
      throw new Error("Uint8Array expected");
    e += s.length;
  }
  let t = new Uint8Array(e), r = 0;
  for (let i = 0; i < n.length; i++) {
    const s = n[i];
    t.set(s, r), r += s.length;
  }
  return t;
}
function vC(n, e) {
  if (n.length !== e.length)
    return !1;
  let t = 0;
  for (let r = 0; r < n.length; r++)
    t |= n[r] ^ e[r];
  return t === 0;
}
function bC(n) {
  if (typeof n != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof n}`);
  return new Uint8Array(new TextEncoder().encode(n));
}
function wC(n) {
  let e;
  for (e = 0; n > My; n >>= _o, e += 1)
    ;
  return e;
}
function xC(n, e) {
  return n >> BigInt(e) & _o;
}
const SC = (n, e, t) => n | (t ? _o : My) << BigInt(e), Uu = (n) => (gC << BigInt(n - 1)) - _o, yc = (n) => new Uint8Array(n), Zf = (n) => Uint8Array.from(n);
function Dy(n, e, t) {
  if (typeof n != "number" || n < 2)
    throw new Error("hashLen must be a number");
  if (typeof e != "number" || e < 2)
    throw new Error("qByteLen must be a number");
  if (typeof t != "function")
    throw new Error("hmacFn must be a function");
  let r = yc(n), i = yc(n), s = 0;
  const a = () => {
    r.fill(1), i.fill(0), s = 0;
  }, o = (...f) => t(i, r, ...f), c = (f = yc()) => {
    i = o(Zf([0]), f), r = o(), f.length !== 0 && (i = o(Zf([1]), f), r = o());
  }, l = () => {
    if (s++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let f = 0;
    const m = [];
    for (; f < e; ) {
      r = o();
      const y = r.slice();
      m.push(y), f += r.length;
    }
    return ai(...m);
  };
  return (f, m) => {
    a(), c(f);
    let y;
    for (; !(y = m(l())); )
      c();
    return a(), y;
  };
}
const EC = {
  bigint: (n) => typeof n == "bigint",
  function: (n) => typeof n == "function",
  boolean: (n) => typeof n == "boolean",
  string: (n) => typeof n == "string",
  stringOrUint8Array: (n) => typeof n == "string" || er(n),
  isSafeInteger: (n) => Number.isSafeInteger(n),
  array: (n) => Array.isArray(n),
  field: (n, e) => e.Fp.isValid(n),
  hash: (n) => typeof n == "function" && Number.isSafeInteger(n.outputLen)
};
function ji(n, e, t = {}) {
  const r = (i, s, a) => {
    const o = EC[s];
    if (typeof o != "function")
      throw new Error(`Invalid validator "${s}", expected function`);
    const c = n[i];
    if (!(a && c === void 0) && !o(c, n))
      throw new Error(`Invalid param ${String(i)}=${c} (${typeof c}), expected ${s}`);
  };
  for (const [i, s] of Object.entries(e))
    r(i, s, !1);
  for (const [i, s] of Object.entries(t))
    r(i, s, !0);
  return n;
}
const CC = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bitGet: xC,
  bitLen: wC,
  bitMask: Uu,
  bitSet: SC,
  bytesToHex: si,
  bytesToNumberBE: ri,
  bytesToNumberLE: Ai,
  concatBytes: ai,
  createHmacDrbg: Dy,
  ensureBytes: Pt,
  equalBytes: vC,
  hexToBytes: Vi,
  hexToNumber: Du,
  isBytes: er,
  numberToBytesBE: Bi,
  numberToBytesLE: As,
  numberToHexUnpadded: Ly,
  numberToVarBytesBE: _C,
  utf8ToBytes: bC,
  validateObject: ji
}, Symbol.toStringTag, { value: "Module" }));
const Ot = BigInt(0), Ge = BigInt(1), ei = BigInt(2), AC = BigInt(3), wl = BigInt(4), Jf = BigInt(5), Kf = BigInt(8);
BigInt(9);
BigInt(16);
function He(n, e) {
  const t = n % e;
  return t >= Ot ? t : e + t;
}
function PC(n, e, t) {
  if (t <= Ot || e < Ot)
    throw new Error("Expected power/modulo > 0");
  if (t === Ge)
    return Ot;
  let r = Ge;
  for (; e > Ot; )
    e & Ge && (r = r * n % t), n = n * n % t, e >>= Ge;
  return r;
}
function tt(n, e, t) {
  let r = n;
  for (; e-- > Ot; )
    r *= r, r %= t;
  return r;
}
function xl(n, e) {
  if (n === Ot || e <= Ot)
    throw new Error(`invert: expected positive integers, got n=${n} mod=${e}`);
  let t = He(n, e), r = e, i = Ot, s = Ge;
  for (; t !== Ot; ) {
    const o = r / t, c = r % t, l = i - s * o;
    r = t, t = c, i = s, s = l;
  }
  if (r !== Ge)
    throw new Error("invert: does not exist");
  return He(i, e);
}
function kC(n) {
  const e = (n - Ge) / ei;
  let t, r, i;
  for (t = n - Ge, r = 0; t % ei === Ot; t /= ei, r++)
    ;
  for (i = ei; i < n && PC(i, e, n) !== n - Ge; i++)
    ;
  if (r === 1) {
    const a = (n + Ge) / wl;
    return function(c, l) {
      const u = c.pow(l, a);
      if (!c.eql(c.sqr(u), l))
        throw new Error("Cannot find square root");
      return u;
    };
  }
  const s = (t + Ge) / ei;
  return function(o, c) {
    if (o.pow(c, e) === o.neg(o.ONE))
      throw new Error("Cannot find square root");
    let l = r, u = o.pow(o.mul(o.ONE, i), t), f = o.pow(c, s), m = o.pow(c, t);
    for (; !o.eql(m, o.ONE); ) {
      if (o.eql(m, o.ZERO))
        return o.ZERO;
      let y = 1;
      for (let v = o.sqr(m); y < l && !o.eql(v, o.ONE); y++)
        v = o.sqr(v);
      const _ = o.pow(u, Ge << BigInt(l - y - 1));
      u = o.sqr(_), f = o.mul(f, _), m = o.mul(m, u), l = y;
    }
    return f;
  };
}
function TC(n) {
  if (n % wl === AC) {
    const e = (n + Ge) / wl;
    return function(r, i) {
      const s = r.pow(i, e);
      if (!r.eql(r.sqr(s), i))
        throw new Error("Cannot find square root");
      return s;
    };
  }
  if (n % Kf === Jf) {
    const e = (n - Jf) / Kf;
    return function(r, i) {
      const s = r.mul(i, ei), a = r.pow(s, e), o = r.mul(i, a), c = r.mul(r.mul(o, ei), a), l = r.mul(o, r.sub(c, r.ONE));
      if (!r.eql(r.sqr(l), i))
        throw new Error("Cannot find square root");
      return l;
    };
  }
  return kC(n);
}
const NC = (n, e) => (He(n, e) & Ge) === Ge, RC = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function IC(n) {
  const e = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  }, t = RC.reduce((r, i) => (r[i] = "function", r), e);
  return ji(n, t);
}
function OC(n, e, t) {
  if (t < Ot)
    throw new Error("Expected power > 0");
  if (t === Ot)
    return n.ONE;
  if (t === Ge)
    return e;
  let r = n.ONE, i = e;
  for (; t > Ot; )
    t & Ge && (r = n.mul(r, i)), i = n.sqr(i), t >>= Ge;
  return r;
}
function MC(n, e) {
  const t = new Array(e.length), r = e.reduce((s, a, o) => n.is0(a) ? s : (t[o] = s, n.mul(s, a)), n.ONE), i = n.inv(r);
  return e.reduceRight((s, a, o) => n.is0(a) ? s : (t[o] = n.mul(s, t[o]), n.mul(s, a)), i), t;
}
function Uy(n, e) {
  const t = e !== void 0 ? e : n.toString(2).length, r = Math.ceil(t / 8);
  return { nBitLength: t, nByteLength: r };
}
function Vy(n, e, t = !1, r = {}) {
  if (n <= Ot)
    throw new Error(`Expected Field ORDER > 0, got ${n}`);
  const { nBitLength: i, nByteLength: s } = Uy(n, e);
  if (s > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const a = TC(n), o = Object.freeze({
    ORDER: n,
    BITS: i,
    BYTES: s,
    MASK: Uu(i),
    ZERO: Ot,
    ONE: Ge,
    create: (c) => He(c, n),
    isValid: (c) => {
      if (typeof c != "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof c}`);
      return Ot <= c && c < n;
    },
    is0: (c) => c === Ot,
    isOdd: (c) => (c & Ge) === Ge,
    neg: (c) => He(-c, n),
    eql: (c, l) => c === l,
    sqr: (c) => He(c * c, n),
    add: (c, l) => He(c + l, n),
    sub: (c, l) => He(c - l, n),
    mul: (c, l) => He(c * l, n),
    pow: (c, l) => OC(o, c, l),
    div: (c, l) => He(c * xl(l, n), n),
    // Same as above, but doesn't normalize
    sqrN: (c) => c * c,
    addN: (c, l) => c + l,
    subN: (c, l) => c - l,
    mulN: (c, l) => c * l,
    inv: (c) => xl(c, n),
    sqrt: r.sqrt || ((c) => a(o, c)),
    invertBatch: (c) => MC(o, c),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (c, l, u) => u ? l : c,
    toBytes: (c) => t ? As(c, s) : Bi(c, s),
    fromBytes: (c) => {
      if (c.length !== s)
        throw new Error(`Fp.fromBytes: expected ${s}, got ${c.length}`);
      return t ? Ai(c) : ri(c);
    }
  });
  return Object.freeze(o);
}
function LC(n, e) {
  if (!n.isOdd)
    throw new Error("Field doesn't have isOdd");
  const t = n.sqrt(e);
  return n.isOdd(t) ? n.neg(t) : t;
}
function By(n) {
  if (typeof n != "bigint")
    throw new Error("field order must be bigint");
  const e = n.toString(2).length;
  return Math.ceil(e / 8);
}
function Hy(n) {
  const e = By(n);
  return e + Math.ceil(e / 2);
}
function DC(n, e, t = !1) {
  const r = n.length, i = By(e), s = Hy(e);
  if (r < 16 || r < s || r > 1024)
    throw new Error(`expected ${s}-1024 bytes of input, got ${r}`);
  const a = t ? ri(n) : Ai(n), o = He(a, e - Ge) + Ge;
  return t ? As(o, i) : Bi(o, i);
}
const UC = BigInt(0), _c = BigInt(1);
function Fy(n, e) {
  const t = (i, s) => {
    const a = s.negate();
    return i ? a : s;
  }, r = (i) => {
    const s = Math.ceil(e / i) + 1, a = 2 ** (i - 1);
    return { windows: s, windowSize: a };
  };
  return {
    constTimeNegate: t,
    // non-const time multiplication ladder
    unsafeLadder(i, s) {
      let a = n.ZERO, o = i;
      for (; s > UC; )
        s & _c && (a = a.add(o)), o = o.double(), s >>= _c;
      return a;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(i, s) {
      const { windows: a, windowSize: o } = r(s), c = [];
      let l = i, u = l;
      for (let f = 0; f < a; f++) {
        u = l, c.push(u);
        for (let m = 1; m < o; m++)
          u = u.add(l), c.push(u);
        l = u.double();
      }
      return c;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(i, s, a) {
      const { windows: o, windowSize: c } = r(i);
      let l = n.ZERO, u = n.BASE;
      const f = BigInt(2 ** i - 1), m = 2 ** i, y = BigInt(i);
      for (let _ = 0; _ < o; _++) {
        const v = _ * c;
        let C = Number(a & f);
        a >>= y, C > c && (C -= m, a += _c);
        const A = v, R = v + Math.abs(C) - 1, I = _ % 2 !== 0, D = C < 0;
        C === 0 ? u = u.add(t(I, s[A])) : l = l.add(t(D, s[R]));
      }
      return { p: l, f: u };
    },
    wNAFCached(i, s, a, o) {
      const c = i._WINDOW_SIZE || 1;
      let l = s.get(i);
      return l || (l = this.precomputeWindow(i, c), c !== 1 && s.set(i, o(l))), this.wNAF(c, l, a);
    }
  };
}
function Vu(n) {
  return IC(n.Fp), ji(n, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  }), Object.freeze({
    ...Uy(n.n, n.nBitLength),
    ...n,
    p: n.Fp.ORDER
  });
}
function VC(n) {
  const e = Vu(n);
  ji(e, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo: t, Fp: r, a: i } = e;
  if (t) {
    if (!r.eql(i, r.ZERO))
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    if (typeof t != "object" || typeof t.beta != "bigint" || typeof t.splitScalar != "function")
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
  }
  return Object.freeze({ ...e });
}
const { bytesToNumberBE: BC, hexToBytes: HC } = CC, ni = {
  // asn.1 DER encoding utils
  Err: class extends Error {
    constructor(e = "") {
      super(e);
    }
  },
  _parseInt(n) {
    const { Err: e } = ni;
    if (n.length < 2 || n[0] !== 2)
      throw new e("Invalid signature integer tag");
    const t = n[1], r = n.subarray(2, t + 2);
    if (!t || r.length !== t)
      throw new e("Invalid signature integer: wrong length");
    if (r[0] & 128)
      throw new e("Invalid signature integer: negative");
    if (r[0] === 0 && !(r[1] & 128))
      throw new e("Invalid signature integer: unnecessary leading zero");
    return { d: BC(r), l: n.subarray(t + 2) };
  },
  toSig(n) {
    const { Err: e } = ni, t = typeof n == "string" ? HC(n) : n;
    if (!er(t))
      throw new Error("ui8a expected");
    let r = t.length;
    if (r < 2 || t[0] != 48)
      throw new e("Invalid signature tag");
    if (t[1] !== r - 2)
      throw new e("Invalid signature: incorrect length");
    const { d: i, l: s } = ni._parseInt(t.subarray(2)), { d: a, l: o } = ni._parseInt(s);
    if (o.length)
      throw new e("Invalid signature: left bytes after parsing");
    return { r: i, s: a };
  },
  hexFromSig(n) {
    const e = (l) => Number.parseInt(l[0], 16) & 8 ? "00" + l : l, t = (l) => {
      const u = l.toString(16);
      return u.length & 1 ? `0${u}` : u;
    }, r = e(t(n.s)), i = e(t(n.r)), s = r.length / 2, a = i.length / 2, o = t(s), c = t(a);
    return `30${t(a + s + 4)}02${c}${i}02${o}${r}`;
  }
}, lr = BigInt(0), _n = BigInt(1);
BigInt(2);
const Yf = BigInt(3);
BigInt(4);
function FC(n) {
  const e = VC(n), { Fp: t } = e, r = e.toBytes || ((_, v, C) => {
    const A = v.toAffine();
    return ai(Uint8Array.from([4]), t.toBytes(A.x), t.toBytes(A.y));
  }), i = e.fromBytes || ((_) => {
    const v = _.subarray(1), C = t.fromBytes(v.subarray(0, t.BYTES)), A = t.fromBytes(v.subarray(t.BYTES, 2 * t.BYTES));
    return { x: C, y: A };
  });
  function s(_) {
    const { a: v, b: C } = e, A = t.sqr(_), R = t.mul(A, _);
    return t.add(t.add(R, t.mul(_, v)), C);
  }
  if (!t.eql(t.sqr(e.Gy), s(e.Gx)))
    throw new Error("bad generator point: equation left != right");
  function a(_) {
    return typeof _ == "bigint" && lr < _ && _ < e.n;
  }
  function o(_) {
    if (!a(_))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function c(_) {
    const { allowedPrivateKeyLengths: v, nByteLength: C, wrapPrivateKey: A, n: R } = e;
    if (v && typeof _ != "bigint") {
      if (er(_) && (_ = si(_)), typeof _ != "string" || !v.includes(_.length))
        throw new Error("Invalid key");
      _ = _.padStart(C * 2, "0");
    }
    let I;
    try {
      I = typeof _ == "bigint" ? _ : ri(Pt("private key", _, C));
    } catch {
      throw new Error(`private key must be ${C} bytes, hex or bigint, not ${typeof _}`);
    }
    return A && (I = He(I, R)), o(I), I;
  }
  const l = /* @__PURE__ */ new Map();
  function u(_) {
    if (!(_ instanceof f))
      throw new Error("ProjectivePoint expected");
  }
  class f {
    constructor(v, C, A) {
      if (this.px = v, this.py = C, this.pz = A, v == null || !t.isValid(v))
        throw new Error("x required");
      if (C == null || !t.isValid(C))
        throw new Error("y required");
      if (A == null || !t.isValid(A))
        throw new Error("z required");
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(v) {
      const { x: C, y: A } = v || {};
      if (!v || !t.isValid(C) || !t.isValid(A))
        throw new Error("invalid affine point");
      if (v instanceof f)
        throw new Error("projective point not allowed");
      const R = (I) => t.eql(I, t.ZERO);
      return R(C) && R(A) ? f.ZERO : new f(C, A, t.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(v) {
      const C = t.invertBatch(v.map((A) => A.pz));
      return v.map((A, R) => A.toAffine(C[R])).map(f.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(v) {
      const C = f.fromAffine(i(Pt("pointHex", v)));
      return C.assertValidity(), C;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(v) {
      return f.BASE.multiply(c(v));
    }
    // "Private method", don't use it directly
    _setWindowSize(v) {
      this._WINDOW_SIZE = v, l.delete(this);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      if (this.is0()) {
        if (e.allowInfinityPoint && !t.is0(this.py))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x: v, y: C } = this.toAffine();
      if (!t.isValid(v) || !t.isValid(C))
        throw new Error("bad point: x or y not FE");
      const A = t.sqr(C), R = s(v);
      if (!t.eql(A, R))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y: v } = this.toAffine();
      if (t.isOdd)
        return !t.isOdd(v);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(v) {
      u(v);
      const { px: C, py: A, pz: R } = this, { px: I, py: D, pz: L } = v, V = t.eql(t.mul(C, L), t.mul(I, R)), F = t.eql(t.mul(A, L), t.mul(D, R));
      return V && F;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new f(this.px, t.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: v, b: C } = e, A = t.mul(C, Yf), { px: R, py: I, pz: D } = this;
      let L = t.ZERO, V = t.ZERO, F = t.ZERO, U = t.mul(R, R), Y = t.mul(I, I), Q = t.mul(D, D), O = t.mul(R, I);
      return O = t.add(O, O), F = t.mul(R, D), F = t.add(F, F), L = t.mul(v, F), V = t.mul(A, Q), V = t.add(L, V), L = t.sub(Y, V), V = t.add(Y, V), V = t.mul(L, V), L = t.mul(O, L), F = t.mul(A, F), Q = t.mul(v, Q), O = t.sub(U, Q), O = t.mul(v, O), O = t.add(O, F), F = t.add(U, U), U = t.add(F, U), U = t.add(U, Q), U = t.mul(U, O), V = t.add(V, U), Q = t.mul(I, D), Q = t.add(Q, Q), U = t.mul(Q, O), L = t.sub(L, U), F = t.mul(Q, Y), F = t.add(F, F), F = t.add(F, F), new f(L, V, F);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(v) {
      u(v);
      const { px: C, py: A, pz: R } = this, { px: I, py: D, pz: L } = v;
      let V = t.ZERO, F = t.ZERO, U = t.ZERO;
      const Y = e.a, Q = t.mul(e.b, Yf);
      let O = t.mul(C, I), B = t.mul(A, D), P = t.mul(R, L), d = t.add(C, A), h = t.add(I, D);
      d = t.mul(d, h), h = t.add(O, B), d = t.sub(d, h), h = t.add(C, R);
      let g = t.add(I, L);
      return h = t.mul(h, g), g = t.add(O, P), h = t.sub(h, g), g = t.add(A, R), V = t.add(D, L), g = t.mul(g, V), V = t.add(B, P), g = t.sub(g, V), U = t.mul(Y, h), V = t.mul(Q, P), U = t.add(V, U), V = t.sub(B, U), U = t.add(B, U), F = t.mul(V, U), B = t.add(O, O), B = t.add(B, O), P = t.mul(Y, P), h = t.mul(Q, h), B = t.add(B, P), P = t.sub(O, P), P = t.mul(Y, P), h = t.add(h, P), O = t.mul(B, h), F = t.add(F, O), O = t.mul(g, h), V = t.mul(d, V), V = t.sub(V, O), O = t.mul(d, B), U = t.mul(g, U), U = t.add(U, O), new f(V, F, U);
    }
    subtract(v) {
      return this.add(v.negate());
    }
    is0() {
      return this.equals(f.ZERO);
    }
    wNAF(v) {
      return y.wNAFCached(this, l, v, (C) => {
        const A = t.invertBatch(C.map((R) => R.pz));
        return C.map((R, I) => R.toAffine(A[I])).map(f.fromAffine);
      });
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(v) {
      const C = f.ZERO;
      if (v === lr)
        return C;
      if (o(v), v === _n)
        return this;
      const { endo: A } = e;
      if (!A)
        return y.unsafeLadder(this, v);
      let { k1neg: R, k1: I, k2neg: D, k2: L } = A.splitScalar(v), V = C, F = C, U = this;
      for (; I > lr || L > lr; )
        I & _n && (V = V.add(U)), L & _n && (F = F.add(U)), U = U.double(), I >>= _n, L >>= _n;
      return R && (V = V.negate()), D && (F = F.negate()), F = new f(t.mul(F.px, A.beta), F.py, F.pz), V.add(F);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(v) {
      o(v);
      let C = v, A, R;
      const { endo: I } = e;
      if (I) {
        const { k1neg: D, k1: L, k2neg: V, k2: F } = I.splitScalar(C);
        let { p: U, f: Y } = this.wNAF(L), { p: Q, f: O } = this.wNAF(F);
        U = y.constTimeNegate(D, U), Q = y.constTimeNegate(V, Q), Q = new f(t.mul(Q.px, I.beta), Q.py, Q.pz), A = U.add(Q), R = Y.add(O);
      } else {
        const { p: D, f: L } = this.wNAF(C);
        A = D, R = L;
      }
      return f.normalizeZ([A, R])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(v, C, A) {
      const R = f.BASE, I = (L, V) => V === lr || V === _n || !L.equals(R) ? L.multiplyUnsafe(V) : L.multiply(V), D = I(this, C).add(I(v, A));
      return D.is0() ? void 0 : D;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z)  (x=x/z, y=y/z)
    toAffine(v) {
      const { px: C, py: A, pz: R } = this, I = this.is0();
      v == null && (v = I ? t.ONE : t.inv(R));
      const D = t.mul(C, v), L = t.mul(A, v), V = t.mul(R, v);
      if (I)
        return { x: t.ZERO, y: t.ZERO };
      if (!t.eql(V, t.ONE))
        throw new Error("invZ was invalid");
      return { x: D, y: L };
    }
    isTorsionFree() {
      const { h: v, isTorsionFree: C } = e;
      if (v === _n)
        return !0;
      if (C)
        return C(f, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: v, clearCofactor: C } = e;
      return v === _n ? this : C ? C(f, this) : this.multiplyUnsafe(e.h);
    }
    toRawBytes(v = !0) {
      return this.assertValidity(), r(f, this, v);
    }
    toHex(v = !0) {
      return si(this.toRawBytes(v));
    }
  }
  f.BASE = new f(e.Gx, e.Gy, t.ONE), f.ZERO = new f(t.ZERO, t.ONE, t.ZERO);
  const m = e.nBitLength, y = Fy(f, e.endo ? Math.ceil(m / 2) : m);
  return {
    CURVE: e,
    ProjectivePoint: f,
    normPrivateKeyToScalar: c,
    weierstrassEquation: s,
    isWithinCurveOrder: a
  };
}
function jC(n) {
  const e = Vu(n);
  return ji(e, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  }), Object.freeze({ lowS: !0, ...e });
}
function WC(n) {
  const e = jC(n), { Fp: t, n: r } = e, i = t.BYTES + 1, s = 2 * t.BYTES + 1;
  function a(h) {
    return lr < h && h < t.ORDER;
  }
  function o(h) {
    return He(h, r);
  }
  function c(h) {
    return xl(h, r);
  }
  const { ProjectivePoint: l, normPrivateKeyToScalar: u, weierstrassEquation: f, isWithinCurveOrder: m } = FC({
    ...e,
    toBytes(h, g, E) {
      const w = g.toAffine(), x = t.toBytes(w.x), T = ai;
      return E ? T(Uint8Array.from([g.hasEvenY() ? 2 : 3]), x) : T(Uint8Array.from([4]), x, t.toBytes(w.y));
    },
    fromBytes(h) {
      const g = h.length, E = h[0], w = h.subarray(1);
      if (g === i && (E === 2 || E === 3)) {
        const x = ri(w);
        if (!a(x))
          throw new Error("Point is not on curve");
        const T = f(x);
        let S = t.sqrt(T);
        const p = (S & _n) === _n;
        return (E & 1) === 1 !== p && (S = t.neg(S)), { x, y: S };
      } else if (g === s && E === 4) {
        const x = t.fromBytes(w.subarray(0, t.BYTES)), T = t.fromBytes(w.subarray(t.BYTES, 2 * t.BYTES));
        return { x, y: T };
      } else
        throw new Error(`Point of length ${g} was invalid. Expected ${i} compressed bytes or ${s} uncompressed bytes`);
    }
  }), y = (h) => si(Bi(h, e.nByteLength));
  function _(h) {
    const g = r >> _n;
    return h > g;
  }
  function v(h) {
    return _(h) ? o(-h) : h;
  }
  const C = (h, g, E) => ri(h.slice(g, E));
  class A {
    constructor(g, E, w) {
      this.r = g, this.s = E, this.recovery = w, this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(g) {
      const E = e.nByteLength;
      return g = Pt("compactSignature", g, E * 2), new A(C(g, 0, E), C(g, E, 2 * E));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(g) {
      const { r: E, s: w } = ni.toSig(Pt("DER", g));
      return new A(E, w);
    }
    assertValidity() {
      if (!m(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!m(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(g) {
      return new A(this.r, this.s, g);
    }
    recoverPublicKey(g) {
      const { r: E, s: w, recovery: x } = this, T = F(Pt("msgHash", g));
      if (x == null || ![0, 1, 2, 3].includes(x))
        throw new Error("recovery id invalid");
      const S = x === 2 || x === 3 ? E + e.n : E;
      if (S >= t.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const p = x & 1 ? "03" : "02", k = l.fromHex(p + y(S)), q = c(S), X = o(-T * q), W = o(w * q), se = l.BASE.multiplyAndAddUnsafe(k, X, W);
      if (!se)
        throw new Error("point at infinify");
      return se.assertValidity(), se;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return _(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new A(this.r, o(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return Vi(this.toDERHex());
    }
    toDERHex() {
      return ni.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return Vi(this.toCompactHex());
    }
    toCompactHex() {
      return y(this.r) + y(this.s);
    }
  }
  const R = {
    isValidPrivateKey(h) {
      try {
        return u(h), !0;
      } catch {
        return !1;
      }
    },
    normPrivateKeyToScalar: u,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const h = Hy(e.n);
      return DC(e.randomBytes(h), e.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(h = 8, g = l.BASE) {
      return g._setWindowSize(h), g.multiply(BigInt(3)), g;
    }
  };
  function I(h, g = !0) {
    return l.fromPrivateKey(h).toRawBytes(g);
  }
  function D(h) {
    const g = er(h), E = typeof h == "string", w = (g || E) && h.length;
    return g ? w === i || w === s : E ? w === 2 * i || w === 2 * s : h instanceof l;
  }
  function L(h, g, E = !0) {
    if (D(h))
      throw new Error("first arg must be private key");
    if (!D(g))
      throw new Error("second arg must be public key");
    return l.fromHex(g).multiply(u(h)).toRawBytes(E);
  }
  const V = e.bits2int || function(h) {
    const g = ri(h), E = h.length * 8 - e.nBitLength;
    return E > 0 ? g >> BigInt(E) : g;
  }, F = e.bits2int_modN || function(h) {
    return o(V(h));
  }, U = Uu(e.nBitLength);
  function Y(h) {
    if (typeof h != "bigint")
      throw new Error("bigint expected");
    if (!(lr <= h && h < U))
      throw new Error(`bigint expected < 2^${e.nBitLength}`);
    return Bi(h, e.nByteLength);
  }
  function Q(h, g, E = O) {
    if (["recovered", "canonical"].some((le) => le in E))
      throw new Error("sign() legacy options not supported");
    const { hash: w, randomBytes: x } = e;
    let { lowS: T, prehash: S, extraEntropy: p } = E;
    T == null && (T = !0), h = Pt("msgHash", h), S && (h = Pt("prehashed msgHash", w(h)));
    const k = F(h), q = u(g), X = [Y(q), Y(k)];
    if (p != null) {
      const le = p === !0 ? x(t.BYTES) : p;
      X.push(Pt("extraEntropy", le));
    }
    const W = ai(...X), se = k;
    function ce(le) {
      const De = V(le);
      if (!m(De))
        return;
      const de = c(De), me = l.BASE.multiply(De).toAffine(), Re = o(me.x);
      if (Re === lr)
        return;
      const be = o(de * o(se + Re * q));
      if (be === lr)
        return;
      let Te = (me.x === Re ? 0 : 2) | Number(me.y & _n), xr = be;
      return T && _(be) && (xr = v(be), Te ^= 1), new A(Re, xr, Te);
    }
    return { seed: W, k2sig: ce };
  }
  const O = { lowS: e.lowS, prehash: !1 }, B = { lowS: e.lowS, prehash: !1 };
  function P(h, g, E = O) {
    const { seed: w, k2sig: x } = Q(h, g, E), T = e;
    return Dy(T.hash.outputLen, T.nByteLength, T.hmac)(w, x);
  }
  l.BASE._setWindowSize(8);
  function d(h, g, E, w = B) {
    var me;
    const x = h;
    if (g = Pt("msgHash", g), E = Pt("publicKey", E), "strict" in w)
      throw new Error("options.strict was renamed to lowS");
    const { lowS: T, prehash: S } = w;
    let p, k;
    try {
      if (typeof x == "string" || er(x))
        try {
          p = A.fromDER(x);
        } catch (Re) {
          if (!(Re instanceof ni.Err))
            throw Re;
          p = A.fromCompact(x);
        }
      else if (typeof x == "object" && typeof x.r == "bigint" && typeof x.s == "bigint") {
        const { r: Re, s: be } = x;
        p = new A(Re, be);
      } else
        throw new Error("PARSE");
      k = l.fromHex(E);
    } catch (Re) {
      if (Re.message === "PARSE")
        throw new Error("signature must be Signature instance, Uint8Array or hex string");
      return !1;
    }
    if (T && p.hasHighS())
      return !1;
    S && (g = e.hash(g));
    const { r: q, s: X } = p, W = F(g), se = c(X), ce = o(W * se), le = o(q * se), De = (me = l.BASE.multiplyAndAddUnsafe(k, ce, le)) == null ? void 0 : me.toAffine();
    return De ? o(De.x) === q : !1;
  }
  return {
    CURVE: e,
    getPublicKey: I,
    getSharedSecret: L,
    sign: P,
    verify: d,
    ProjectivePoint: l,
    Signature: A,
    utils: R
  };
}
class jy extends yo {
  constructor(e, t) {
    super(), this.finished = !1, this.destroyed = !1, $g(e);
    const r = In(t);
    if (this.iHash = e.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const i = this.blockLen, s = new Uint8Array(i);
    s.set(r.length > i ? e.create().update(r).digest() : r);
    for (let a = 0; a < s.length; a++)
      s[a] ^= 54;
    this.iHash.update(s), this.oHash = e.create();
    for (let a = 0; a < s.length; a++)
      s[a] ^= 106;
    this.oHash.update(s), s.fill(0);
  }
  update(e) {
    return Wr(this), this.iHash.update(e), this;
  }
  digestInto(e) {
    Wr(this), Ru(e, this.outputLen), this.finished = !0, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy();
  }
  digest() {
    const e = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(e), e;
  }
  _cloneInto(e) {
    e || (e = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: t, iHash: r, finished: i, destroyed: s, blockLen: a, outputLen: o } = this;
    return e = e, e.finished = i, e.destroyed = s, e.blockLen = a, e.outputLen = o, e.oHash = t._cloneInto(e.oHash), e.iHash = r._cloneInto(e.iHash), e;
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
}
const vo = (n, e, t) => new jy(n, e).update(t).digest();
vo.create = (n, e) => new jy(n, e);
function qC(n) {
  return {
    hash: n,
    hmac: (e, ...t) => vo(n, e, ny(...t)),
    randomBytes: iy
  };
}
function zC(n, e) {
  const t = (r) => WC({ ...n, ...qC(r) });
  return Object.freeze({ ...t(e), create: t });
}
const Wy = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"), Qf = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), XC = BigInt(1), Sl = BigInt(2), $f = (n, e) => (n + e / Sl) / e;
function GC(n) {
  const e = Wy, t = BigInt(3), r = BigInt(6), i = BigInt(11), s = BigInt(22), a = BigInt(23), o = BigInt(44), c = BigInt(88), l = n * n * n % e, u = l * l * n % e, f = tt(u, t, e) * u % e, m = tt(f, t, e) * u % e, y = tt(m, Sl, e) * l % e, _ = tt(y, i, e) * y % e, v = tt(_, s, e) * _ % e, C = tt(v, o, e) * v % e, A = tt(C, c, e) * C % e, R = tt(A, o, e) * v % e, I = tt(R, t, e) * u % e, D = tt(I, a, e) * _ % e, L = tt(D, r, e) * l % e, V = tt(L, Sl, e);
  if (!El.eql(El.sqr(V), n))
    throw new Error("Cannot find square root");
  return V;
}
const El = Vy(Wy, void 0, void 0, { sqrt: GC }), Wi = zC({
  a: BigInt(0),
  // equation params: a, b
  b: BigInt(7),
  // Seem to be rigid: bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975
  Fp: El,
  // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n
  n: Qf,
  // Curve order, total count of valid points in the field
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  // Cofactor
  lowS: !0,
  // Allow only low-S signatures by default in sign() and verify()
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (n) => {
      const e = Qf, t = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), r = -XC * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), i = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), s = t, a = BigInt("0x100000000000000000000000000000000"), o = $f(s * n, e), c = $f(-r * n, e);
      let l = He(n - o * t - c * i, e), u = He(-o * r - c * s, e);
      const f = l > a, m = u > a;
      if (f && (l = e - l), m && (u = e - u), l > a || u > a)
        throw new Error("splitScalar: Endomorphism failed, k=" + n);
      return { k1neg: f, k1: l, k2neg: m, k2: u };
    }
  }
}, js);
BigInt(0);
Wi.ProjectivePoint;
function Hi(n, e) {
  if (n.length !== 32)
    throw new Error("Expected valid 32-byte private key as a seed");
  if (!Rt || !e && It()) {
    const t = tE(n), r = t.slice(32);
    if (fu(r))
      throw new Error("Invalid publicKey generated from WASM interface");
    return {
      publicKey: r,
      secretKey: t.slice(0, 32)
    };
  }
  return {
    publicKey: Wi.getPublicKey(n, !0),
    secretKey: n
  };
}
function qy(n, e) {
  return (t, { chainCode: r, isHard: i }) => {
    if (!i)
      throw new Error("A soft key was found in the path and is not supported");
    return n(e(t.secretKey.subarray(0, 32), r));
  };
}
const eh = /* @__PURE__ */ qy(Hi, uC), ZC = wn(Ze("Ed25519HDKD"));
function JC(n, e) {
  if (!te(e) || e.length !== 32)
    throw new Error("Invalid chainCode passed to derive");
  return hn(Me(ZC, n, e));
}
function Ws(n = 32) {
  return dy(new Uint8Array(n));
}
const KC = /* @__PURE__ */ _y(Ws), [YC, QC] = /* @__PURE__ */ (() => ae.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((n) => BigInt(n))))(), kr = /* @__PURE__ */ new Uint32Array(80), Tr = /* @__PURE__ */ new Uint32Array(80);
class $C extends Oy {
  constructor() {
    super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;
  }
  // prettier-ignore
  get() {
    const { Ah: e, Al: t, Bh: r, Bl: i, Ch: s, Cl: a, Dh: o, Dl: c, Eh: l, El: u, Fh: f, Fl: m, Gh: y, Gl: _, Hh: v, Hl: C } = this;
    return [e, t, r, i, s, a, o, c, l, u, f, m, y, _, v, C];
  }
  // prettier-ignore
  set(e, t, r, i, s, a, o, c, l, u, f, m, y, _, v, C) {
    this.Ah = e | 0, this.Al = t | 0, this.Bh = r | 0, this.Bl = i | 0, this.Ch = s | 0, this.Cl = a | 0, this.Dh = o | 0, this.Dl = c | 0, this.Eh = l | 0, this.El = u | 0, this.Fh = f | 0, this.Fl = m | 0, this.Gh = y | 0, this.Gl = _ | 0, this.Hh = v | 0, this.Hl = C | 0;
  }
  process(e, t) {
    for (let I = 0; I < 16; I++, t += 4)
      kr[I] = e.getUint32(t), Tr[I] = e.getUint32(t += 4);
    for (let I = 16; I < 80; I++) {
      const D = kr[I - 15] | 0, L = Tr[I - 15] | 0, V = ae.rotrSH(D, L, 1) ^ ae.rotrSH(D, L, 8) ^ ae.shrSH(D, L, 7), F = ae.rotrSL(D, L, 1) ^ ae.rotrSL(D, L, 8) ^ ae.shrSL(D, L, 7), U = kr[I - 2] | 0, Y = Tr[I - 2] | 0, Q = ae.rotrSH(U, Y, 19) ^ ae.rotrBH(U, Y, 61) ^ ae.shrSH(U, Y, 6), O = ae.rotrSL(U, Y, 19) ^ ae.rotrBL(U, Y, 61) ^ ae.shrSL(U, Y, 6), B = ae.add4L(F, O, Tr[I - 7], Tr[I - 16]), P = ae.add4H(B, V, Q, kr[I - 7], kr[I - 16]);
      kr[I] = P | 0, Tr[I] = B | 0;
    }
    let { Ah: r, Al: i, Bh: s, Bl: a, Ch: o, Cl: c, Dh: l, Dl: u, Eh: f, El: m, Fh: y, Fl: _, Gh: v, Gl: C, Hh: A, Hl: R } = this;
    for (let I = 0; I < 80; I++) {
      const D = ae.rotrSH(f, m, 14) ^ ae.rotrSH(f, m, 18) ^ ae.rotrBH(f, m, 41), L = ae.rotrSL(f, m, 14) ^ ae.rotrSL(f, m, 18) ^ ae.rotrBL(f, m, 41), V = f & y ^ ~f & v, F = m & _ ^ ~m & C, U = ae.add5L(R, L, F, QC[I], Tr[I]), Y = ae.add5H(U, A, D, V, YC[I], kr[I]), Q = U | 0, O = ae.rotrSH(r, i, 28) ^ ae.rotrBH(r, i, 34) ^ ae.rotrBH(r, i, 39), B = ae.rotrSL(r, i, 28) ^ ae.rotrBL(r, i, 34) ^ ae.rotrBL(r, i, 39), P = r & s ^ r & o ^ s & o, d = i & a ^ i & c ^ a & c;
      A = v | 0, R = C | 0, v = y | 0, C = _ | 0, y = f | 0, _ = m | 0, { h: f, l: m } = ae.add(l | 0, u | 0, Y | 0, Q | 0), l = o | 0, u = c | 0, o = s | 0, c = a | 0, s = r | 0, a = i | 0;
      const h = ae.add3L(Q, B, d);
      r = ae.add3H(h, Y, O, P), i = h | 0;
    }
    ({ h: r, l: i } = ae.add(this.Ah | 0, this.Al | 0, r | 0, i | 0)), { h: s, l: a } = ae.add(this.Bh | 0, this.Bl | 0, s | 0, a | 0), { h: o, l: c } = ae.add(this.Ch | 0, this.Cl | 0, o | 0, c | 0), { h: l, l: u } = ae.add(this.Dh | 0, this.Dl | 0, l | 0, u | 0), { h: f, l: m } = ae.add(this.Eh | 0, this.El | 0, f | 0, m | 0), { h: y, l: _ } = ae.add(this.Fh | 0, this.Fl | 0, y | 0, _ | 0), { h: v, l: C } = ae.add(this.Gh | 0, this.Gl | 0, v | 0, C | 0), { h: A, l: R } = ae.add(this.Hh | 0, this.Hl | 0, A | 0, R | 0), this.set(r, i, s, a, o, c, l, u, f, m, y, _, v, C, A, R);
  }
  roundClean() {
    kr.fill(0), Tr.fill(0);
  }
  destroy() {
    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
}
const qs = /* @__PURE__ */ Ou(() => new $C());
const An = BigInt(0), sn = BigInt(1), na = BigInt(2), e3 = BigInt(8), t3 = { zip215: !0 };
function n3(n) {
  const e = Vu(n);
  return ji(n, {
    hash: "function",
    a: "bigint",
    d: "bigint",
    randomBytes: "function"
  }, {
    adjustScalarBytes: "function",
    domain: "function",
    uvRatio: "function",
    mapToCurve: "function"
  }), Object.freeze({ ...e });
}
function Bu(n) {
  const e = n3(n), { Fp: t, n: r, prehash: i, hash: s, randomBytes: a, nByteLength: o, h: c } = e, l = na << BigInt(o * 8) - sn, u = t.create, f = e.uvRatio || ((w, x) => {
    try {
      return { isValid: !0, value: t.sqrt(w * t.inv(x)) };
    } catch {
      return { isValid: !1, value: An };
    }
  }), m = e.adjustScalarBytes || ((w) => w), y = e.domain || ((w, x, T) => {
    if (x.length || T)
      throw new Error("Contexts/pre-hash are not supported");
    return w;
  }), _ = (w) => typeof w == "bigint" && An < w, v = (w, x) => _(w) && _(x) && w < x, C = (w) => w === An || v(w, l);
  function A(w, x) {
    if (v(w, x))
      return w;
    throw new Error(`Expected valid scalar < ${x}, got ${typeof w} ${w}`);
  }
  function R(w) {
    return w === An ? w : A(w, r);
  }
  const I = /* @__PURE__ */ new Map();
  function D(w) {
    if (!(w instanceof L))
      throw new Error("ExtendedPoint expected");
  }
  class L {
    constructor(x, T, S, p) {
      if (this.ex = x, this.ey = T, this.ez = S, this.et = p, !C(x))
        throw new Error("x required");
      if (!C(T))
        throw new Error("y required");
      if (!C(S))
        throw new Error("z required");
      if (!C(p))
        throw new Error("t required");
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static fromAffine(x) {
      if (x instanceof L)
        throw new Error("extended point not allowed");
      const { x: T, y: S } = x || {};
      if (!C(T) || !C(S))
        throw new Error("invalid affine point");
      return new L(T, S, sn, u(T * S));
    }
    static normalizeZ(x) {
      const T = t.invertBatch(x.map((S) => S.ez));
      return x.map((S, p) => S.toAffine(T[p])).map(L.fromAffine);
    }
    // "Private method", don't use it directly
    _setWindowSize(x) {
      this._WINDOW_SIZE = x, I.delete(this);
    }
    // Not required for fromHex(), which always creates valid points.
    // Could be useful for fromAffine().
    assertValidity() {
      const { a: x, d: T } = e;
      if (this.is0())
        throw new Error("bad point: ZERO");
      const { ex: S, ey: p, ez: k, et: q } = this, X = u(S * S), W = u(p * p), se = u(k * k), ce = u(se * se), le = u(X * x), De = u(se * u(le + W)), de = u(ce + u(T * u(X * W)));
      if (De !== de)
        throw new Error("bad point: equation left != right (1)");
      const me = u(S * p), Re = u(k * q);
      if (me !== Re)
        throw new Error("bad point: equation left != right (2)");
    }
    // Compare one point to another.
    equals(x) {
      D(x);
      const { ex: T, ey: S, ez: p } = this, { ex: k, ey: q, ez: X } = x, W = u(T * X), se = u(k * p), ce = u(S * X), le = u(q * p);
      return W === se && ce === le;
    }
    is0() {
      return this.equals(L.ZERO);
    }
    negate() {
      return new L(u(-this.ex), this.ey, this.ez, u(-this.et));
    }
    // Fast algo for doubling Extended Point.
    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
    // Cost: 4M + 4S + 1*a + 6add + 1*2.
    double() {
      const { a: x } = e, { ex: T, ey: S, ez: p } = this, k = u(T * T), q = u(S * S), X = u(na * u(p * p)), W = u(x * k), se = T + S, ce = u(u(se * se) - k - q), le = W + q, De = le - X, de = W - q, me = u(ce * De), Re = u(le * de), be = u(ce * de), Te = u(De * le);
      return new L(me, Re, Te, be);
    }
    // Fast algo for adding 2 Extended Points.
    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
    // Cost: 9M + 1*a + 1*d + 7add.
    add(x) {
      D(x);
      const { a: T, d: S } = e, { ex: p, ey: k, ez: q, et: X } = this, { ex: W, ey: se, ez: ce, et: le } = x;
      if (T === BigInt(-1)) {
        const Gi = u((k - p) * (se + W)), We = u((k + p) * (se - W)), Ue = u(We - Gi);
        if (Ue === An)
          return this.double();
        const Zi = u(q * na * le), qe = u(X * na * ce), ze = qe + Zi, Ji = We + Gi, Xe = qe - Zi, Qe = u(ze * Ue), Ys = u(Ji * Xe), $e = u(ze * Xe), et = u(Ue * Ji);
        return new L(Qe, Ys, et, $e);
      }
      const De = u(p * W), de = u(k * se), me = u(X * S * le), Re = u(q * ce), be = u((p + k) * (W + se) - De - de), Te = Re - me, xr = Re + me, je = u(de - T * De), Je = u(be * Te), Ks = u(xr * je), Ke = u(be * je), Ye = u(Te * xr);
      return new L(Je, Ks, Ye, Ke);
    }
    subtract(x) {
      return this.add(x.negate());
    }
    wNAF(x) {
      return U.wNAFCached(this, I, x, L.normalizeZ);
    }
    // Constant-time multiplication.
    multiply(x) {
      const { p: T, f: S } = this.wNAF(A(x, r));
      return L.normalizeZ([T, S])[0];
    }
    // Non-constant-time multiplication. Uses double-and-add algorithm.
    // It's faster, but should only be used when you don't care about
    // an exposed private key e.g. sig verification.
    // Does NOT allow scalars higher than CURVE.n.
    multiplyUnsafe(x) {
      let T = R(x);
      return T === An ? F : this.equals(F) || T === sn ? this : this.equals(V) ? this.wNAF(T).p : U.unsafeLadder(this, T);
    }
    // Checks if point is of small order.
    // If you add something to small order point, you will have "dirty"
    // point with torsion component.
    // Multiplies point by cofactor and checks if the result is 0.
    isSmallOrder() {
      return this.multiplyUnsafe(c).is0();
    }
    // Multiplies point by curve order and checks if the result is 0.
    // Returns `false` is the point is dirty.
    isTorsionFree() {
      return U.unsafeLadder(this, r).is0();
    }
    // Converts Extended point to default (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    toAffine(x) {
      const { ex: T, ey: S, ez: p } = this, k = this.is0();
      x == null && (x = k ? e3 : t.inv(p));
      const q = u(T * x), X = u(S * x), W = u(p * x);
      if (k)
        return { x: An, y: sn };
      if (W !== sn)
        throw new Error("invZ was invalid");
      return { x: q, y: X };
    }
    clearCofactor() {
      const { h: x } = e;
      return x === sn ? this : this.multiplyUnsafe(x);
    }
    // Converts hash string or Uint8Array to Point.
    // Uses algo from RFC8032 5.1.3.
    static fromHex(x, T = !1) {
      const { d: S, a: p } = e, k = t.BYTES;
      x = Pt("pointHex", x, k);
      const q = x.slice(), X = x[k - 1];
      q[k - 1] = X & -129;
      const W = Ai(q);
      W === An || (T ? A(W, l) : A(W, t.ORDER));
      const se = u(W * W), ce = u(se - sn), le = u(S * se - p);
      let { isValid: De, value: de } = f(ce, le);
      if (!De)
        throw new Error("Point.fromHex: invalid y coordinate");
      const me = (de & sn) === sn, Re = (X & 128) !== 0;
      if (!T && de === An && Re)
        throw new Error("Point.fromHex: x=0 and x_0=1");
      return Re !== me && (de = u(-de)), L.fromAffine({ x: de, y: W });
    }
    static fromPrivateKey(x) {
      return O(x).point;
    }
    toRawBytes() {
      const { x, y: T } = this.toAffine(), S = As(T, t.BYTES);
      return S[S.length - 1] |= x & sn ? 128 : 0, S;
    }
    toHex() {
      return si(this.toRawBytes());
    }
  }
  L.BASE = new L(e.Gx, e.Gy, sn, u(e.Gx * e.Gy)), L.ZERO = new L(An, sn, sn, An);
  const { BASE: V, ZERO: F } = L, U = Fy(L, o * 8);
  function Y(w) {
    return He(w, r);
  }
  function Q(w) {
    return Y(Ai(w));
  }
  function O(w) {
    const x = o;
    w = Pt("private key", w, x);
    const T = Pt("hashed private key", s(w), 2 * x), S = m(T.slice(0, x)), p = T.slice(x, 2 * x), k = Q(S), q = V.multiply(k), X = q.toRawBytes();
    return { head: S, prefix: p, scalar: k, point: q, pointBytes: X };
  }
  function B(w) {
    return O(w).pointBytes;
  }
  function P(w = new Uint8Array(), ...x) {
    const T = ai(...x);
    return Q(s(y(T, Pt("context", w), !!i)));
  }
  function d(w, x, T = {}) {
    w = Pt("message", w), i && (w = i(w));
    const { prefix: S, scalar: p, pointBytes: k } = O(x), q = P(T.context, S, w), X = V.multiply(q).toRawBytes(), W = P(T.context, X, k, w), se = Y(q + W * p);
    R(se);
    const ce = ai(X, As(se, t.BYTES));
    return Pt("result", ce, o * 2);
  }
  const h = t3;
  function g(w, x, T, S = h) {
    const { context: p, zip215: k } = S, q = t.BYTES;
    w = Pt("signature", w, 2 * q), x = Pt("message", x), i && (x = i(x));
    const X = Ai(w.slice(q, 2 * q));
    let W, se, ce;
    try {
      W = L.fromHex(T, k), se = L.fromHex(w.slice(0, q), k), ce = V.multiplyUnsafe(X);
    } catch {
      return !1;
    }
    if (!k && W.isSmallOrder())
      return !1;
    const le = P(p, se.toRawBytes(), W.toRawBytes(), x);
    return se.add(W.multiplyUnsafe(le)).subtract(ce).clearCofactor().equals(L.ZERO);
  }
  return V._setWindowSize(8), {
    CURVE: e,
    getPublicKey: B,
    sign: d,
    verify: g,
    ExtendedPoint: L,
    utils: {
      getExtendedPublicKey: O,
      // ed25519 private keys are uniform 32b. No need to check for modulo bias, like in secp256k1.
      randomPrivateKey: () => a(t.BYTES),
      /**
       * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT
       * values. This slows down first getPublicKey() by milliseconds (see Speed section),
       * but allows to speed-up subsequent getPublicKey() calls up to 20x.
       * @param windowSize 2, 4, 8, 16
       */
      precompute(w = 8, x = L.BASE) {
        return x._setWindowSize(w), x.multiply(BigInt(3)), x;
      }
    }
  };
}
const Hu = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"), th = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
BigInt(0);
const r3 = BigInt(1), Cl = BigInt(2), i3 = BigInt(5), nh = BigInt(10), s3 = BigInt(20), a3 = BigInt(40), rh = BigInt(80);
function o3(n) {
  const e = Hu, r = n * n % e * n % e, i = tt(r, Cl, e) * r % e, s = tt(i, r3, e) * n % e, a = tt(s, i3, e) * s % e, o = tt(a, nh, e) * a % e, c = tt(o, s3, e) * o % e, l = tt(c, a3, e) * c % e, u = tt(l, rh, e) * l % e, f = tt(u, rh, e) * l % e, m = tt(f, nh, e) * a % e;
  return { pow_p_5_8: tt(m, Cl, e) * n % e, b2: r };
}
function c3(n) {
  return n[0] &= 248, n[31] &= 127, n[31] |= 64, n;
}
function l3(n, e) {
  const t = Hu, r = He(e * e * e, t), i = He(r * r * e, t), s = o3(n * i).pow_p_5_8;
  let a = He(n * r * s, t);
  const o = He(e * a * a, t), c = a, l = He(a * th, t), u = o === n, f = o === He(-n, t), m = o === He(-n * th, t);
  return u && (a = c), (f || m) && (a = l), NC(a, t) && (a = He(-a, t)), { isValid: u || f, value: a };
}
const hr = Vy(Hu, void 0, !0), Fu = {
  // Param: a
  a: BigInt(-1),
  // Fp.create(-1) is proper; our way still works and is faster
  // d is equal to -121665/121666 over finite field.
  // Negative number is P - number, and division is invert(number, P)
  d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
  // Finite field p over which we'll do calculations; 2n**255n - 19n
  Fp: hr,
  // Subgroup order: how many points curve has
  // 2n**252n + 27742317777372353535851937790883648493n;
  n: BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),
  // Cofactor
  h: BigInt(8),
  // Base point (x, y) aka generator point
  Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
  Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),
  hash: qs,
  randomBytes: iy,
  adjustScalarBytes: c3,
  // dom2
  // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.
  // Constant-time, u/v
  uvRatio: l3
}, ju = /* @__PURE__ */ Bu(Fu);
function zy(n, e, t) {
  if (e.length > 255)
    throw new Error("Context is too big");
  return ny(ty("SigEd25519 no Ed25519 collisions"), new Uint8Array([t ? 1 : 0, e.length]), e, n);
}
({
  ...Fu
});
({
  ...Fu
});
const u3 = (hr.ORDER + BigInt(3)) / BigInt(8);
hr.pow(Cl, u3);
hr.sqrt(hr.neg(hr.ONE));
(hr.ORDER - BigInt(5)) / BigInt(8);
BigInt(486662);
LC(hr, hr.neg(BigInt(486664)));
BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function Wu(n, e) {
  if (!Rt || !e && It()) {
    const r = QS(n);
    return {
      publicKey: r.slice(32),
      secretKey: r.slice(0, 64)
    };
  }
  const t = ju.getPublicKey(n);
  return {
    publicKey: t,
    secretKey: Wt([n, t])
  };
}
function d3(n, { publicKey: e, secretKey: t }, r) {
  if (t) {
    if (!e)
      throw new Error("Expected a valid publicKey");
  } else
    throw new Error("Expected a valid secretKey");
  const i = j(n), s = t.subarray(0, 32);
  return !Rt || !r && It() ? $S(e, s, i) : ju.sign(i, s);
}
function Xy(n, e, t, r) {
  const i = j(n), s = j(t), a = j(e);
  if (s.length !== 32)
    throw new Error(`Invalid publicKey, received ${s.length}, expected 32`);
  if (a.length !== 64)
    throw new Error(`Invalid signature, received ${a.length} bytes, expected 64`);
  try {
    return !Rt || !r && It() ? eE(a, i, s) : ju.verify(a, i, s);
  } catch {
    return !1;
  }
}
const f3 = /* @__PURE__ */ qy(Wu, JC), Al = 64, h3 = 32, vc = Al + h3;
function Gy(n) {
  const e = j(n);
  if (e.length !== vc)
    throw new Error(`Expected keypair with ${vc} bytes, found ${e.length}`);
  return {
    publicKey: e.slice(Al, vc),
    secretKey: e.slice(0, Al)
  };
}
function p3({ publicKey: n, secretKey: e }) {
  return Me(e, n).slice();
}
function Zy(n) {
  return (e, t) => {
    if (!te(t) || t.length !== 32)
      throw new Error("Invalid chainCode passed to derive");
    return Gy(n(p3(e), t));
  };
}
const m3 = /* @__PURE__ */ Zy(aE), g3 = /* @__PURE__ */ Zy(oE);
function y3(n, { chainCode: e, isSoft: t }) {
  return t ? g3(n, e) : m3(n, e);
}
const _3 = {
  ecdsa: eh,
  ed25519: f3,
  // FIXME This is Substrate-compatible, not Ethereum-compatible
  ethereum: eh,
  sr25519: y3
};
function Jy(n, e, t) {
  const r = _3[t];
  let i = n;
  for (const s of e)
    i = r(i, s);
  return i;
}
function Ky(n) {
  const e = j(n);
  if (e.length !== 32)
    throw new Error(`Expected a seed matching 32 bytes, found ${e.length}`);
  return Gy(cE(e));
}
function v3(n, { publicKey: e, secretKey: t }) {
  if ((e == null ? void 0 : e.length) !== 32)
    throw new Error("Expected a valid publicKey, 32-bytes");
  if ((t == null ? void 0 : t.length) !== 64)
    throw new Error("Expected a valid secretKey, 64-bytes");
  return lE(e, t, j(n));
}
function Yy(n, e, t) {
  const r = j(t), i = j(e);
  if (r.length !== 32)
    throw new Error(`Invalid publicKey, received ${r.length} bytes, expected 32`);
  if (i.length !== 64)
    throw new Error(`Invalid signature, received ${i.length} bytes, expected 64`);
  return uE(i, j(n), r);
}
const ih = new Uint8Array();
function b3(n, { secretKey: e }, t = ih, r = ih) {
  if ((e == null ? void 0 : e.length) !== 64)
    throw new Error("Invalid secretKey, expected 64-bytes");
  return dE(e, j(t), j(n), j(r));
}
const sh = new Uint8Array();
function w3(n, e, t, r = sh, i = sh) {
  const s = j(t), a = j(e);
  if (s.length !== 32)
    throw new Error("Invalid publicKey, expected 32-bytes");
  if (a.length !== 96)
    throw new Error("Invalid vrfSign output, expected 96 bytes");
  return fE(s, j(r), j(n), j(i), a);
}
function bo(n, e = wa.prefix) {
  const t = rn(n);
  if (e < 0 || e > 16383 || [46, 47].includes(e))
    throw new Error("Out of range ss58Format specified");
  if (!wa.allowedDecodedLengths.includes(t.length))
    throw new Error(`Expected a valid key to convert, with length ${wa.allowedDecodedLengths.join(", ")}`);
  const r = Me(e < 64 ? [e] : [
    (e & 252) >> 2 | 64,
    e >> 8 | (e & 3) << 6
  ], t);
  return qE(Me(r, ky(r).subarray(0, [32, 33].includes(t.length) ? 2 : 1)));
}
const [Qy, $y, e0] = [[], [], []], x3 = /* @__PURE__ */ BigInt(0), es = /* @__PURE__ */ BigInt(1), S3 = /* @__PURE__ */ BigInt(2), E3 = /* @__PURE__ */ BigInt(7), C3 = /* @__PURE__ */ BigInt(256), A3 = /* @__PURE__ */ BigInt(113);
for (let n = 0, e = es, t = 1, r = 0; n < 24; n++) {
  [t, r] = [r, (2 * t + 3 * r) % 5], Qy.push(2 * (5 * r + t)), $y.push((n + 1) * (n + 2) / 2 % 64);
  let i = x3;
  for (let s = 0; s < 7; s++)
    e = (e << es ^ (e >> E3) * A3) % C3, e & S3 && (i ^= es << (es << /* @__PURE__ */ BigInt(s)) - es);
  e0.push(i);
}
const [P3, k3] = /* @__PURE__ */ ay(e0, !0), ah = (n, e, t) => t > 32 ? ly(n, e, t) : oy(n, e, t), oh = (n, e, t) => t > 32 ? uy(n, e, t) : cy(n, e, t);
function T3(n, e = 24) {
  const t = new Uint32Array(10);
  for (let r = 24 - e; r < 24; r++) {
    for (let a = 0; a < 10; a++)
      t[a] = n[a] ^ n[a + 10] ^ n[a + 20] ^ n[a + 30] ^ n[a + 40];
    for (let a = 0; a < 10; a += 2) {
      const o = (a + 8) % 10, c = (a + 2) % 10, l = t[c], u = t[c + 1], f = ah(l, u, 1) ^ t[o], m = oh(l, u, 1) ^ t[o + 1];
      for (let y = 0; y < 50; y += 10)
        n[a + y] ^= f, n[a + y + 1] ^= m;
    }
    let i = n[2], s = n[3];
    for (let a = 0; a < 24; a++) {
      const o = $y[a], c = ah(i, s, o), l = oh(i, s, o), u = Qy[a];
      i = n[u], s = n[u + 1], n[u] = c, n[u + 1] = l;
    }
    for (let a = 0; a < 50; a += 10) {
      for (let o = 0; o < 10; o++)
        t[o] = n[a + o];
      for (let o = 0; o < 10; o++)
        n[a + o] ^= ~t[(o + 2) % 10] & t[(o + 4) % 10];
    }
    n[0] ^= P3[r], n[1] ^= k3[r];
  }
  t.fill(0);
}
class qu extends yo {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(e, t, r, i = !1, s = 24) {
    if (super(), this.blockLen = e, this.suffix = t, this.outputLen = r, this.enableXOF = i, this.rounds = s, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, Ft(r), 0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200), this.state32 = Ur(this.state);
  }
  keccak() {
    T3(this.state32, this.rounds), this.posOut = 0, this.pos = 0;
  }
  update(e) {
    Wr(this);
    const { blockLen: t, state: r } = this;
    e = In(e);
    const i = e.length;
    for (let s = 0; s < i; ) {
      const a = Math.min(t - this.pos, i - s);
      for (let o = 0; o < a; o++)
        r[this.pos++] ^= e[s++];
      this.pos === t && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = !0;
    const { state: e, suffix: t, pos: r, blockLen: i } = this;
    e[r] ^= t, t & 128 && r === i - 1 && this.keccak(), e[i - 1] ^= 128, this.keccak();
  }
  writeInto(e) {
    Wr(this, !1), Ru(e), this.finish();
    const t = this.state, { blockLen: r } = this;
    for (let i = 0, s = e.length; i < s; ) {
      this.posOut >= r && this.keccak();
      const a = Math.min(r - this.posOut, s - i);
      e.set(t.subarray(this.posOut, this.posOut + a), i), this.posOut += a, i += a;
    }
    return e;
  }
  xofInto(e) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(e);
  }
  xof(e) {
    return Ft(e), this.xofInto(new Uint8Array(e));
  }
  digestInto(e) {
    if (Iu(e, this), this.finished)
      throw new Error("digest() was already called");
    return this.writeInto(e), this.destroy(), e;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = !0, this.state.fill(0);
  }
  _cloneInto(e) {
    const { blockLen: t, suffix: r, outputLen: i, rounds: s, enableXOF: a } = this;
    return e || (e = new qu(t, r, i, a, s)), e.state32.set(this.state32), e.pos = this.pos, e.posOut = this.posOut, e.finished = this.finished, e.rounds = s, e.suffix = r, e.outputLen = i, e.enableXOF = a, e.destroyed = this.destroyed, e;
  }
}
const t0 = (n, e, t) => Ou(() => new qu(e, n, t)), N3 = /* @__PURE__ */ t0(1, 136, 256 / 8), R3 = /* @__PURE__ */ t0(1, 72, 512 / 8), zs = /* @__PURE__ */ vy({ 256: gE, 512: yE }, { 256: N3, 512: R3 });
function Pl(n, e, t) {
  return n === "keccak" ? zs(e, void 0, t) : hn(e, void 0, void 0, t);
}
const zu = {
  chars: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  coder: BE,
  type: "base64",
  withPadding: !0
}, I3 = /* @__PURE__ */ Py(zu), O3 = /* @__PURE__ */ Cy(zu, I3), M3 = /* @__PURE__ */ Ay(zu);
function n0(n, e) {
  if (![33, 65].includes(n.length))
    throw new Error(`Invalid publicKey provided, received ${n.length} bytes input`);
  return n.length === 33 ? n : !Rt || !e && It() ? nE(n) : Wi.ProjectivePoint.fromHex(n).toRawBytes(!0);
}
function Xu(n, e) {
  if (![33, 65].includes(n.length))
    throw new Error(`Invalid publicKey provided, received ${n.length} bytes input`);
  if (n.length === 65)
    return n.subarray(1);
  if (!Rt || !e && It())
    return rE(n).subarray(1);
  const { px: t, py: r } = Wi.ProjectivePoint.fromHex(n);
  return Me(Lt(t, Ui), Lt(r, Ui));
}
function L3(n, e, t, r = "blake2", i) {
  const s = j(e).subarray(0, 64), a = j(n), o = !Rt || !i && It() ? iE(a, s, t) : Wi.Signature.fromCompact(s).addRecoveryBit(t).recoverPublicKey(a).toRawBytes();
  if (!o)
    throw new Error("Unable to recover publicKey from signature");
  return r === "keccak" ? Xu(o, i) : n0(o, i);
}
function ch(n, { secretKey: e }, t = "blake2", r) {
  if ((e == null ? void 0 : e.length) !== 32)
    throw new Error("Expected valid secp256k1 secretKey, 32-bytes");
  const i = Pl(t, n, r);
  if (!Rt || !r && It())
    return sE(i, e);
  const s = Wi.sign(i, e, { lowS: !0 });
  return Me(Lt(s.r, Ui), Lt(s.s, Ui), new Uint8Array([s.recovery || 0]));
}
const r0 = "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141".replace(/ /g, ""), bc = Fe(`0x${r0}`), wc = new Z(r0, "hex");
function D3(n, e) {
  let t = Ta(e, Xf);
  if (t >= bc)
    throw new Error("Tweak parameter is out of range");
  if (t += Ta(n, Xf), t >= bc && (t -= bc), t === ii)
    throw new Error("Invalid resulting private key");
  return hu(t, Ui);
}
function U3(n, e) {
  const t = new Z(e);
  if (t.cmp(wc) >= 0)
    throw new Error("Tweak parameter is out of range");
  if (t.iadd(new Z(n)), t.cmp(wc) >= 0 && t.isub(wc), t.isZero())
    throw new Error("Invalid resulting private key");
  return Lt(t, Ui);
}
function V3(n, e, t) {
  if (!te(n) || n.length !== 32)
    throw new Error("Expected seckey to be an Uint8Array with length 32");
  if (!te(e) || e.length !== 32)
    throw new Error("Expected tweak to be an Uint8Array with length 32");
  return !Rt || t ? U3(n, e) : D3(n, e);
}
function B3(n, e, t, r = "blake2", i) {
  const s = j(e);
  if (s.length !== 65)
    throw new Error(`Expected signature with 65 bytes, ${s.length} found instead`);
  const a = L3(Pl(r, n), s, s[64], r, i), o = Pl(r, a, i), c = j(t);
  return jt(a, c) || (r === "keccak" ? jt(o.slice(-20), c.slice(-20)) : jt(o, c));
}
function H3(n) {
  return [33, 65].includes(n.length) && (n = zs(Xu(n))), n.slice(-20);
}
function Gu(n) {
  if (!n)
    return "0x";
  const e = j(n);
  if (![20, 32, 33, 65].includes(e.length))
    throw new Error(`Invalid address or publicKey provided, received ${e.length} bytes input`);
  const t = pe(H3(e), -1, !1), r = pe(zs(t), -1, !1);
  let i = "";
  for (let s = 0; s < 40; s++)
    i = `${i}${parseInt(r[s], 16) > 7 ? t[s].toUpperCase() : t[s]}`;
  return `0x${i}`;
}
function F3(n, e) {
  return n !== (e > 7 ? n.toUpperCase() : n.toLowerCase());
}
function j3(n) {
  const e = n.replace("0x", ""), t = pe(zs(e.toLowerCase()), -1, !1);
  for (let r = 0; r < 40; r++)
    if (F3(e[r], parseInt(t[r], 16)))
      return !1;
  return !0;
}
function W3(n) {
  return !n || n.length !== 42 || !ye(n) ? !1 : /^(0x)?[0-9a-f]{40}$/.test(n) || /^(0x)?[0-9A-F]{40}$/.test(n) ? !0 : j3(n);
}
const q3 = {
  256: js,
  512: qs
}, z3 = {
  256: pE,
  512: mE
};
function i0(n, e, t = 256, r) {
  const i = j(n);
  return !Rt || !r && It() ? z3[t](i, e) : vo(q3[t], i, e);
}
const Zu = 2147483648;
function X3(n) {
  if (!n.startsWith("m/"))
    return !1;
  const e = n.split("/").slice(1);
  for (const t of e) {
    const r = /^\d+'?$/.test(t) ? parseInt(t.replace(/'$/, ""), 10) : Number.NaN;
    if (isNaN(r) || r >= Zu || r < 0)
      return !1;
  }
  return !0;
}
const G3 = Ze("Bitcoin seed");
function s0(n, e) {
  return {
    chainCode: e,
    publicKey: Hi(n).publicKey,
    secretKey: n
  };
}
function a0(n, e) {
  const t = Lt(e, nC), r = e >= Zu ? Me(new Uint8Array(1), n.secretKey, t) : Me(n.publicKey, t);
  try {
    const i = i0(n.chainCode, r, 512);
    return s0(V3(n.secretKey, i.slice(0, 32)), i.slice(32));
  } catch {
    return a0(n, e + 1);
  }
}
function Z3(n, e = "") {
  const t = i0(G3, n, 512);
  let r = s0(t.slice(0, 32), t.slice(32));
  if (!e || e === "m" || e === "M" || e === "m'" || e === "M'")
    return r;
  if (!X3(e))
    throw new Error("Invalid derivation path");
  const i = e.split("/").slice(1);
  for (const s of i)
    r = a0(r, parseInt(s, 10) + (s.length > 1 && s.endsWith("'") ? Zu : 0));
  return r;
}
function J3(n, e, t, r) {
  $g(n);
  const i = ry({ dkLen: 32, asyncTick: 10 }, r), { c: s, dkLen: a, asyncTick: o } = i;
  if (Ft(s), Ft(a), Ft(o), s < 1)
    throw new Error("PBKDF2: iterations (c) should be >= 1");
  const c = In(e), l = In(t), u = new Uint8Array(a), f = vo.create(n, c), m = f._cloneInto().update(l);
  return { c: s, dkLen: a, asyncTick: o, DK: u, PRF: f, PRFSalt: m };
}
function K3(n, e, t, r, i) {
  return n.destroy(), e.destroy(), r && r.destroy(), i.fill(0), t;
}
function Ju(n, e, t, r) {
  const { c: i, dkLen: s, DK: a, PRF: o, PRFSalt: c } = J3(n, e, t, r);
  let l;
  const u = new Uint8Array(4), f = _a(u), m = new Uint8Array(o.outputLen);
  for (let y = 1, _ = 0; _ < s; y++, _ += o.outputLen) {
    const v = a.subarray(_, _ + o.outputLen);
    f.setInt32(0, y, !1), (l = c._cloneInto(l)).update(u).digestInto(m), v.set(m.subarray(0, v.length));
    for (let C = 1; C < i; C++) {
      o._cloneInto(l).update(m).digestInto(m);
      for (let A = 0; A < v.length; A++)
        v[A] ^= m[A];
    }
  }
  return K3(o, c, a, l, m);
}
function o0(n, e = Ws(), t = 2048, r) {
  const i = j(n), s = j(e);
  return {
    password: !Rt || !r && It() ? _E(i, s, t) : Ju(qs, i, s, { c: t, dkLen: 64 }),
    rounds: t,
    salt: e
  };
}
const Y3 = /* @__PURE__ */ vy({ 256: bE, 512: wE }, { 256: js, 512: qs }), Q3 = /* @__PURE__ */ EE(256, Y3), c0 = "abandon|ability|able|about|above|absent|absorb|abstract|absurd|abuse|access|accident|account|accuse|achieve|acid|acoustic|acquire|across|act|action|actor|actress|actual|adapt|add|addict|address|adjust|admit|adult|advance|advice|aerobic|affair|afford|afraid|again|age|agent|agree|ahead|aim|air|airport|aisle|alarm|album|alcohol|alert|alien|all|alley|allow|almost|alone|alpha|already|also|alter|always|amateur|amazing|among|amount|amused|analyst|anchor|ancient|anger|angle|angry|animal|ankle|announce|annual|another|answer|antenna|antique|anxiety|any|apart|apology|appear|apple|approve|april|arch|arctic|area|arena|argue|arm|armed|armor|army|around|arrange|arrest|arrive|arrow|art|artefact|artist|artwork|ask|aspect|assault|asset|assist|assume|asthma|athlete|atom|attack|attend|attitude|attract|auction|audit|august|aunt|author|auto|autumn|average|avocado|avoid|awake|aware|away|awesome|awful|awkward|axis|baby|bachelor|bacon|badge|bag|balance|balcony|ball|bamboo|banana|banner|bar|barely|bargain|barrel|base|basic|basket|battle|beach|bean|beauty|because|become|beef|before|begin|behave|behind|believe|below|belt|bench|benefit|best|betray|better|between|beyond|bicycle|bid|bike|bind|biology|bird|birth|bitter|black|blade|blame|blanket|blast|bleak|bless|blind|blood|blossom|blouse|blue|blur|blush|board|boat|body|boil|bomb|bone|bonus|book|boost|border|boring|borrow|boss|bottom|bounce|box|boy|bracket|brain|brand|brass|brave|bread|breeze|brick|bridge|brief|bright|bring|brisk|broccoli|broken|bronze|broom|brother|brown|brush|bubble|buddy|budget|buffalo|build|bulb|bulk|bullet|bundle|bunker|burden|burger|burst|bus|business|busy|butter|buyer|buzz|cabbage|cabin|cable|cactus|cage|cake|call|calm|camera|camp|can|canal|cancel|candy|cannon|canoe|canvas|canyon|capable|capital|captain|car|carbon|card|cargo|carpet|carry|cart|case|cash|casino|castle|casual|cat|catalog|catch|category|cattle|caught|cause|caution|cave|ceiling|celery|cement|census|century|cereal|certain|chair|chalk|champion|change|chaos|chapter|charge|chase|chat|cheap|check|cheese|chef|cherry|chest|chicken|chief|child|chimney|choice|choose|chronic|chuckle|chunk|churn|cigar|cinnamon|circle|citizen|city|civil|claim|clap|clarify|claw|clay|clean|clerk|clever|click|client|cliff|climb|clinic|clip|clock|clog|close|cloth|cloud|clown|club|clump|cluster|clutch|coach|coast|coconut|code|coffee|coil|coin|collect|color|column|combine|come|comfort|comic|common|company|concert|conduct|confirm|congress|connect|consider|control|convince|cook|cool|copper|copy|coral|core|corn|correct|cost|cotton|couch|country|couple|course|cousin|cover|coyote|crack|cradle|craft|cram|crane|crash|crater|crawl|crazy|cream|credit|creek|crew|cricket|crime|crisp|critic|crop|cross|crouch|crowd|crucial|cruel|cruise|crumble|crunch|crush|cry|crystal|cube|culture|cup|cupboard|curious|current|curtain|curve|cushion|custom|cute|cycle|dad|damage|damp|dance|danger|daring|dash|daughter|dawn|day|deal|debate|debris|decade|december|decide|decline|decorate|decrease|deer|defense|define|defy|degree|delay|deliver|demand|demise|denial|dentist|deny|depart|depend|deposit|depth|deputy|derive|describe|desert|design|desk|despair|destroy|detail|detect|develop|device|devote|diagram|dial|diamond|diary|dice|diesel|diet|differ|digital|dignity|dilemma|dinner|dinosaur|direct|dirt|disagree|discover|disease|dish|dismiss|disorder|display|distance|divert|divide|divorce|dizzy|doctor|document|dog|doll|dolphin|domain|donate|donkey|donor|door|dose|double|dove|draft|dragon|drama|drastic|draw|dream|dress|drift|drill|drink|drip|drive|drop|drum|dry|duck|dumb|dune|during|dust|dutch|duty|dwarf|dynamic|eager|eagle|early|earn|earth|easily|east|easy|echo|ecology|economy|edge|edit|educate|effort|egg|eight|either|elbow|elder|electric|elegant|element|elephant|elevator|elite|else|embark|embody|embrace|emerge|emotion|employ|empower|empty|enable|enact|end|endless|endorse|enemy|energy|enforce|engage|engine|enhance|enjoy|enlist|enough|enrich|enroll|ensure|enter|entire|entry|envelope|episode|equal|equip|era|erase|erode|erosion|error|erupt|escape|essay|essence|estate|eternal|ethics|evidence|evil|evoke|evolve|exact|example|excess|exchange|excite|exclude|excuse|execute|exercise|exhaust|exhibit|exile|exist|exit|exotic|expand|expect|expire|explain|expose|express|extend|extra|eye|eyebrow|fabric|face|faculty|fade|faint|faith|fall|false|fame|family|famous|fan|fancy|fantasy|farm|fashion|fat|fatal|father|fatigue|fault|favorite|feature|february|federal|fee|feed|feel|female|fence|festival|fetch|fever|few|fiber|fiction|field|figure|file|film|filter|final|find|fine|finger|finish|fire|firm|first|fiscal|fish|fit|fitness|fix|flag|flame|flash|flat|flavor|flee|flight|flip|float|flock|floor|flower|fluid|flush|fly|foam|focus|fog|foil|fold|follow|food|foot|force|forest|forget|fork|fortune|forum|forward|fossil|foster|found|fox|fragile|frame|frequent|fresh|friend|fringe|frog|front|frost|frown|frozen|fruit|fuel|fun|funny|furnace|fury|future|gadget|gain|galaxy|gallery|game|gap|garage|garbage|garden|garlic|garment|gas|gasp|gate|gather|gauge|gaze|general|genius|genre|gentle|genuine|gesture|ghost|giant|gift|giggle|ginger|giraffe|girl|give|glad|glance|glare|glass|glide|glimpse|globe|gloom|glory|glove|glow|glue|goat|goddess|gold|good|goose|gorilla|gospel|gossip|govern|gown|grab|grace|grain|grant|grape|grass|gravity|great|green|grid|grief|grit|grocery|group|grow|grunt|guard|guess|guide|guilt|guitar|gun|gym|habit|hair|half|hammer|hamster|hand|happy|harbor|hard|harsh|harvest|hat|have|hawk|hazard|head|health|heart|heavy|hedgehog|height|hello|helmet|help|hen|hero|hidden|high|hill|hint|hip|hire|history|hobby|hockey|hold|hole|holiday|hollow|home|honey|hood|hope|horn|horror|horse|hospital|host|hotel|hour|hover|hub|huge|human|humble|humor|hundred|hungry|hunt|hurdle|hurry|hurt|husband|hybrid|ice|icon|idea|identify|idle|ignore|ill|illegal|illness|image|imitate|immense|immune|impact|impose|improve|impulse|inch|include|income|increase|index|indicate|indoor|industry|infant|inflict|inform|inhale|inherit|initial|inject|injury|inmate|inner|innocent|input|inquiry|insane|insect|inside|inspire|install|intact|interest|into|invest|invite|involve|iron|island|isolate|issue|item|ivory|jacket|jaguar|jar|jazz|jealous|jeans|jelly|jewel|job|join|joke|journey|joy|judge|juice|jump|jungle|junior|junk|just|kangaroo|keen|keep|ketchup|key|kick|kid|kidney|kind|kingdom|kiss|kit|kitchen|kite|kitten|kiwi|knee|knife|knock|know|lab|label|labor|ladder|lady|lake|lamp|language|laptop|large|later|latin|laugh|laundry|lava|law|lawn|lawsuit|layer|lazy|leader|leaf|learn|leave|lecture|left|leg|legal|legend|leisure|lemon|lend|length|lens|leopard|lesson|letter|level|liar|liberty|library|license|life|lift|light|like|limb|limit|link|lion|liquid|list|little|live|lizard|load|loan|lobster|local|lock|logic|lonely|long|loop|lottery|loud|lounge|love|loyal|lucky|luggage|lumber|lunar|lunch|luxury|lyrics|machine|mad|magic|magnet|maid|mail|main|major|make|mammal|man|manage|mandate|mango|mansion|manual|maple|marble|march|margin|marine|market|marriage|mask|mass|master|match|material|math|matrix|matter|maximum|maze|meadow|mean|measure|meat|mechanic|medal|media|melody|melt|member|memory|mention|menu|mercy|merge|merit|merry|mesh|message|metal|method|middle|midnight|milk|million|mimic|mind|minimum|minor|minute|miracle|mirror|misery|miss|mistake|mix|mixed|mixture|mobile|model|modify|mom|moment|monitor|monkey|monster|month|moon|moral|more|morning|mosquito|mother|motion|motor|mountain|mouse|move|movie|much|muffin|mule|multiply|muscle|museum|mushroom|music|must|mutual|myself|mystery|myth|naive|name|napkin|narrow|nasty|nation|nature|near|neck|need|negative|neglect|neither|nephew|nerve|nest|net|network|neutral|never|news|next|nice|night|noble|noise|nominee|noodle|normal|north|nose|notable|note|nothing|notice|novel|now|nuclear|number|nurse|nut|oak|obey|object|oblige|obscure|observe|obtain|obvious|occur|ocean|october|odor|off|offer|office|often|oil|okay|old|olive|olympic|omit|once|one|onion|online|only|open|opera|opinion|oppose|option|orange|orbit|orchard|order|ordinary|organ|orient|original|orphan|ostrich|other|outdoor|outer|output|outside|oval|oven|over|own|owner|oxygen|oyster|ozone|pact|paddle|page|pair|palace|palm|panda|panel|panic|panther|paper|parade|parent|park|parrot|party|pass|patch|path|patient|patrol|pattern|pause|pave|payment|peace|peanut|pear|peasant|pelican|pen|penalty|pencil|people|pepper|perfect|permit|person|pet|phone|photo|phrase|physical|piano|picnic|picture|piece|pig|pigeon|pill|pilot|pink|pioneer|pipe|pistol|pitch|pizza|place|planet|plastic|plate|play|please|pledge|pluck|plug|plunge|poem|poet|point|polar|pole|police|pond|pony|pool|popular|portion|position|possible|post|potato|pottery|poverty|powder|power|practice|praise|predict|prefer|prepare|present|pretty|prevent|price|pride|primary|print|priority|prison|private|prize|problem|process|produce|profit|program|project|promote|proof|property|prosper|protect|proud|provide|public|pudding|pull|pulp|pulse|pumpkin|punch|pupil|puppy|purchase|purity|purpose|purse|push|put|puzzle|pyramid|quality|quantum|quarter|question|quick|quit|quiz|quote|rabbit|raccoon|race|rack|radar|radio|rail|rain|raise|rally|ramp|ranch|random|range|rapid|rare|rate|rather|raven|raw|razor|ready|real|reason|rebel|rebuild|recall|receive|recipe|record|recycle|reduce|reflect|reform|refuse|region|regret|regular|reject|relax|release|relief|rely|remain|remember|remind|remove|render|renew|rent|reopen|repair|repeat|replace|report|require|rescue|resemble|resist|resource|response|result|retire|retreat|return|reunion|reveal|review|reward|rhythm|rib|ribbon|rice|rich|ride|ridge|rifle|right|rigid|ring|riot|ripple|risk|ritual|rival|river|road|roast|robot|robust|rocket|romance|roof|rookie|room|rose|rotate|rough|round|route|royal|rubber|rude|rug|rule|run|runway|rural|sad|saddle|sadness|safe|sail|salad|salmon|salon|salt|salute|same|sample|sand|satisfy|satoshi|sauce|sausage|save|say|scale|scan|scare|scatter|scene|scheme|school|science|scissors|scorpion|scout|scrap|screen|script|scrub|sea|search|season|seat|second|secret|section|security|seed|seek|segment|select|sell|seminar|senior|sense|sentence|series|service|session|settle|setup|seven|shadow|shaft|shallow|share|shed|shell|sheriff|shield|shift|shine|ship|shiver|shock|shoe|shoot|shop|short|shoulder|shove|shrimp|shrug|shuffle|shy|sibling|sick|side|siege|sight|sign|silent|silk|silly|silver|similar|simple|since|sing|siren|sister|situate|six|size|skate|sketch|ski|skill|skin|skirt|skull|slab|slam|sleep|slender|slice|slide|slight|slim|slogan|slot|slow|slush|small|smart|smile|smoke|smooth|snack|snake|snap|sniff|snow|soap|soccer|social|sock|soda|soft|solar|soldier|solid|solution|solve|someone|song|soon|sorry|sort|soul|sound|soup|source|south|space|spare|spatial|spawn|speak|special|speed|spell|spend|sphere|spice|spider|spike|spin|spirit|split|spoil|sponsor|spoon|sport|spot|spray|spread|spring|spy|square|squeeze|squirrel|stable|stadium|staff|stage|stairs|stamp|stand|start|state|stay|steak|steel|stem|step|stereo|stick|still|sting|stock|stomach|stone|stool|story|stove|strategy|street|strike|strong|struggle|student|stuff|stumble|style|subject|submit|subway|success|such|sudden|suffer|sugar|suggest|suit|summer|sun|sunny|sunset|super|supply|supreme|sure|surface|surge|surprise|surround|survey|suspect|sustain|swallow|swamp|swap|swarm|swear|sweet|swift|swim|swing|switch|sword|symbol|symptom|syrup|system|table|tackle|tag|tail|talent|talk|tank|tape|target|task|taste|tattoo|taxi|teach|team|tell|ten|tenant|tennis|tent|term|test|text|thank|that|theme|then|theory|there|they|thing|this|thought|three|thrive|throw|thumb|thunder|ticket|tide|tiger|tilt|timber|time|tiny|tip|tired|tissue|title|toast|tobacco|today|toddler|toe|together|toilet|token|tomato|tomorrow|tone|tongue|tonight|tool|tooth|top|topic|topple|torch|tornado|tortoise|toss|total|tourist|toward|tower|town|toy|track|trade|traffic|tragic|train|transfer|trap|trash|travel|tray|treat|tree|trend|trial|tribe|trick|trigger|trim|trip|trophy|trouble|truck|true|truly|trumpet|trust|truth|try|tube|tuition|tumble|tuna|tunnel|turkey|turn|turtle|twelve|twenty|twice|twin|twist|two|type|typical|ugly|umbrella|unable|unaware|uncle|uncover|under|undo|unfair|unfold|unhappy|uniform|unique|unit|universe|unknown|unlock|until|unusual|unveil|update|upgrade|uphold|upon|upper|upset|urban|urge|usage|use|used|useful|useless|usual|utility|vacant|vacuum|vague|valid|valley|valve|van|vanish|vapor|various|vast|vault|vehicle|velvet|vendor|venture|venue|verb|verify|version|very|vessel|veteran|viable|vibrant|vicious|victory|video|view|village|vintage|violin|virtual|virus|visa|visit|visual|vital|vivid|vocal|voice|void|volcano|volume|vote|voyage|wage|wagon|wait|walk|wall|walnut|want|warfare|warm|warrior|wash|wasp|waste|water|wave|way|wealth|weapon|wear|weasel|weather|web|wedding|weekend|weird|welcome|west|wet|whale|what|wheat|wheel|when|where|whip|whisper|wide|width|wife|wild|will|win|window|wine|wing|wink|winner|winter|wire|wisdom|wise|wish|witness|wolf|woman|wonder|wood|wool|word|work|world|worry|worth|wrap|wreck|wrestle|wrist|write|wrong|yard|year|yellow|you|young|youth|zebra|zero|zone|zoo".split("|"), lh = "Invalid mnemonic", l0 = "Invalid entropy", $3 = "Invalid mnemonic checksum";
function kl(n) {
  return (n || "").normalize("NFKD");
}
function u0(n) {
  return parseInt(n, 2);
}
function d0(n) {
  return n.map((e) => e.toString(2).padStart(8, "0")).join("");
}
function f0(n) {
  return d0(Array.from(Q3(n))).slice(0, n.length * 8 / 32);
}
function uh(n, e) {
  return o0(Ze(kl(n)), Ze(`mnemonic${kl(e)}`)).password;
}
function h0(n, e = c0) {
  const t = kl(n).split(" ");
  if (t.length % 3 !== 0)
    throw new Error(lh);
  const r = t.map((u) => {
    const f = e.indexOf(u);
    if (f === -1)
      throw new Error(lh);
    return f.toString(2).padStart(11, "0");
  }).join(""), i = Math.floor(r.length / 33) * 32, s = r.slice(0, i), a = r.slice(i), o = s.match(/(.{1,8})/g), c = o == null ? void 0 : o.map(u0);
  if (!c || c.length % 4 !== 0 || c.length < 16 || c.length > 32)
    throw new Error(l0);
  const l = j(c);
  if (f0(l) !== a)
    throw new Error($3);
  return l;
}
function eA(n, e = c0) {
  if (n.length % 4 !== 0 || n.length < 16 || n.length > 32)
    throw new Error(l0);
  const t = `${d0(Array.from(n))}${f0(n)}`.match(/(.{1,11})/g), r = t == null ? void 0 : t.map((i) => e[u0(i)]);
  if (!r || r.length < 12)
    throw new Error("Unable to map entropy to mnemonic");
  return r.join(" ");
}
function tA(n, e) {
  try {
    h0(n, e);
  } catch {
    return !1;
  }
  return !0;
}
function nA(n, e, t) {
  return !Rt || !e && !t && It() ? ZS(n) : h0(n, e);
}
function Ku(n, e, t) {
  return !Rt || !e && !t && It() ? YS(n) : tA(n, e);
}
function rA(n, e = "", t, r = 32) {
  if (Ku(n)) {
    if (![32, 64].includes(r))
      throw new Error(`Invalid seed length ${r}, expected 32 or 64`);
  } else
    throw new Error("Invalid bip39 mnemonic specified");
  return r === 32 ? !Rt || !t && It() ? KS(n, e) : uh(n, e).subarray(0, 32) : uh(n, e);
}
function iA(n, e = "", t, r) {
  if (Ku(n, t, r)) {
    if (!t && !r && It())
      return JS(n, e);
  } else
    throw new Error("Invalid bip39 mnemonic specified");
  const i = nA(n, t), s = Ze(`mnemonic${e}`);
  return o0(i, s).password.slice(0, 32);
}
function ra(n, e) {
  return n << e | n >>> 32 - e;
}
function fi(n, e) {
  let t = n[e + 3] & 255;
  return t = t << 8 | n[e + 2] & 255, t = t << 8 | n[e + 1] & 255, t << 8 | n[e + 0] & 255;
}
function xc(n, e, t) {
  for (let r = 0; r < 4; r++)
    n[e + r] = t & 255, t >>>= 8;
}
function sA(n, e, t, r, i) {
  let s = 0;
  for (let a = 0; a < i; a++)
    s |= n[e + a] ^ t[r + a];
  return (1 & s - 1 >>> 8) - 1;
}
function Tl(n, e, t, r, i) {
  const s = new Uint32Array(16), a = new Uint32Array(16), o = new Uint32Array(16), c = new Uint32Array(4);
  let l, u, f;
  for (l = 0; l < 4; l++)
    a[5 * l] = fi(r, 4 * l), a[1 + l] = fi(t, 4 * l), a[6 + l] = fi(e, 4 * l), a[11 + l] = fi(t, 16 + 4 * l);
  for (l = 0; l < 16; l++)
    o[l] = a[l];
  for (l = 0; l < 20; l++) {
    for (u = 0; u < 4; u++) {
      for (f = 0; f < 4; f++)
        c[f] = a[(5 * u + 4 * f) % 16];
      for (c[1] ^= ra(c[0] + c[3] | 0, 7), c[2] ^= ra(c[1] + c[0] | 0, 9), c[3] ^= ra(c[2] + c[1] | 0, 13), c[0] ^= ra(c[3] + c[2] | 0, 18), f = 0; f < 4; f++)
        s[4 * u + (u + f) % 4] = c[f];
    }
    for (f = 0; f < 16; f++)
      a[f] = s[f];
  }
  if (i) {
    for (l = 0; l < 16; l++)
      a[l] = a[l] + o[l] | 0;
    for (l = 0; l < 4; l++)
      a[5 * l] = a[5 * l] - fi(r, 4 * l) | 0, a[6 + l] = a[6 + l] - fi(e, 4 * l) | 0;
    for (l = 0; l < 4; l++)
      xc(n, 4 * l, a[5 * l]), xc(n, 16 + 4 * l, a[6 + l]);
  } else
    for (l = 0; l < 16; l++)
      xc(n, 4 * l, a[l] + o[l] | 0);
}
const Nl = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
function aA(n, e, t, r, i, s, a) {
  const o = new Uint8Array(16), c = new Uint8Array(64);
  let l, u;
  if (!i)
    return 0;
  for (u = 0; u < 16; u++)
    o[u] = 0;
  for (u = 0; u < 8; u++)
    o[u] = s[u];
  for (; i >= 64; ) {
    for (Tl(c, o, a, Nl, !1), u = 0; u < 64; u++)
      n[e + u] = (t ? t[r + u] : 0) ^ c[u];
    for (l = 1, u = 8; u < 16; u++)
      l = l + (o[u] & 255) | 0, o[u] = l & 255, l >>>= 8;
    i -= 64, e += 64, t && (r += 64);
  }
  if (i > 0)
    for (Tl(c, o, a, Nl, !1), u = 0; u < i; u++)
      n[e + u] = (t ? t[r + u] : 0) ^ c[u];
  return 0;
}
function Rl(n, e, t, r, i, s, a) {
  const o = new Uint8Array(32);
  return Tl(o, s, a, Nl, !0), aA(n, e, t, r, i, s.subarray(16), o);
}
function Sc(n, e) {
  let t = 0;
  for (let r = 0; r < 17; r++)
    t = t + (n[r] + e[r] | 0) | 0, n[r] = t & 255, t >>>= 8;
}
const oA = new Uint32Array([5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 252]);
function p0(n, e, t, r, i, s) {
  let a, o, c;
  const l = new Uint32Array(17), u = new Uint32Array(17), f = new Uint32Array(17), m = new Uint32Array(17), y = new Uint32Array(17);
  for (o = 0; o < 17; o++)
    u[o] = f[o] = 0;
  for (o = 0; o < 16; o++)
    u[o] = s[o];
  for (u[3] &= 15, u[4] &= 252, u[7] &= 15, u[8] &= 252, u[11] &= 15, u[12] &= 252, u[15] &= 15; i > 0; ) {
    for (o = 0; o < 17; o++)
      m[o] = 0;
    for (o = 0; o < 16 && o < i; ++o)
      m[o] = t[r + o];
    for (m[o] = 1, r += o, i -= o, Sc(f, m), a = 0; a < 17; a++)
      for (l[a] = 0, o = 0; o < 17; o++)
        l[a] = l[a] + f[o] * (o <= a ? u[a - o] : 320 * u[a + 17 - o] | 0) | 0 | 0;
    for (a = 0; a < 17; a++)
      f[a] = l[a];
    for (c = 0, o = 0; o < 16; o++)
      c = c + f[o] | 0, f[o] = c & 255, c >>>= 8;
    for (c = c + f[16] | 0, f[16] = c & 3, c = 5 * (c >>> 2) | 0, o = 0; o < 16; o++)
      c = c + f[o] | 0, f[o] = c & 255, c >>>= 8;
    c = c + f[16] | 0, f[16] = c;
  }
  for (o = 0; o < 17; o++)
    y[o] = f[o];
  Sc(f, oA);
  const _ = -(f[16] >>> 7) | 0;
  for (o = 0; o < 17; o++)
    f[o] ^= _ & (y[o] ^ f[o]);
  for (o = 0; o < 16; o++)
    m[o] = s[o + 16];
  for (m[16] = 0, Sc(f, m), o = 0; o < 16; o++)
    n[e + o] = f[o];
  return 0;
}
function cA(n, e, t, r, i, s) {
  const a = new Uint8Array(16);
  return p0(a, 0, t, r, i, s), sA(n, e, a, 0, 16);
}
function lA(n, e, t, r, i) {
  if (t < 32)
    return -1;
  Rl(n, 0, e, 0, t, r, i), p0(n, 16, n, 32, t - 32, n);
  for (let s = 0; s < 16; s++)
    n[s] = 0;
  return 0;
}
function uA(n, e, t, r, i) {
  const s = new Uint8Array(32);
  if (t < 32 || (Rl(s, 0, null, 0, 32, r, i), cA(e, 16, e, 32, t - 32, s) !== 0))
    return -1;
  Rl(n, 0, e, 0, t, r, i);
  for (let a = 0; a < 32; a++)
    n[a] = 0;
  return 0;
}
const dA = 32, fA = 24, Il = 32, Ol = 16;
function m0(n, e) {
  if (n.length !== dA)
    throw new Error("bad key size");
  if (e.length !== fA)
    throw new Error("bad nonce size");
}
function g0(...n) {
  for (let e = 0, t = n.length; e < t; e++)
    if (!(n[e] instanceof Uint8Array))
      throw new TypeError("unexpected type, use Uint8Array");
}
function hA(n, e, t) {
  g0(n, e, t), m0(t, e);
  const r = new Uint8Array(Il + n.length), i = new Uint8Array(r.length);
  for (let s = 0; s < n.length; s++)
    r[s + Il] = n[s];
  return lA(i, r, r.length, e, t), i.subarray(Ol);
}
function pA(n, e, t) {
  g0(n, e, t), m0(t, e);
  const r = new Uint8Array(Ol + n.length), i = new Uint8Array(r.length);
  for (let s = 0; s < n.length; s++)
    r[s + Ol] = n[s];
  return r.length < 32 || uA(i, r, r.length, e, t) !== 0 ? null : i.subarray(Il);
}
function mA(n, e, t) {
  return pA(n, e, t);
}
function gA(n, e, t = Ws(24)) {
  return {
    encrypted: hA(n, t, e),
    nonce: t
  };
}
const Se = (n, e) => n << e | n >>> 32 - e;
function dh(n, e, t, r, i, s) {
  let a = n[e++] ^ t[r++], o = n[e++] ^ t[r++], c = n[e++] ^ t[r++], l = n[e++] ^ t[r++], u = n[e++] ^ t[r++], f = n[e++] ^ t[r++], m = n[e++] ^ t[r++], y = n[e++] ^ t[r++], _ = n[e++] ^ t[r++], v = n[e++] ^ t[r++], C = n[e++] ^ t[r++], A = n[e++] ^ t[r++], R = n[e++] ^ t[r++], I = n[e++] ^ t[r++], D = n[e++] ^ t[r++], L = n[e++] ^ t[r++], V = a, F = o, U = c, Y = l, Q = u, O = f, B = m, P = y, d = _, h = v, g = C, E = A, w = R, x = I, T = D, S = L;
  for (let p = 0; p < 8; p += 2)
    Q ^= Se(V + w | 0, 7), d ^= Se(Q + V | 0, 9), w ^= Se(d + Q | 0, 13), V ^= Se(w + d | 0, 18), h ^= Se(O + F | 0, 7), x ^= Se(h + O | 0, 9), F ^= Se(x + h | 0, 13), O ^= Se(F + x | 0, 18), T ^= Se(g + B | 0, 7), U ^= Se(T + g | 0, 9), B ^= Se(U + T | 0, 13), g ^= Se(B + U | 0, 18), Y ^= Se(S + E | 0, 7), P ^= Se(Y + S | 0, 9), E ^= Se(P + Y | 0, 13), S ^= Se(E + P | 0, 18), F ^= Se(V + Y | 0, 7), U ^= Se(F + V | 0, 9), Y ^= Se(U + F | 0, 13), V ^= Se(Y + U | 0, 18), B ^= Se(O + Q | 0, 7), P ^= Se(B + O | 0, 9), Q ^= Se(P + B | 0, 13), O ^= Se(Q + P | 0, 18), E ^= Se(g + h | 0, 7), d ^= Se(E + g | 0, 9), h ^= Se(d + E | 0, 13), g ^= Se(h + d | 0, 18), w ^= Se(S + T | 0, 7), x ^= Se(w + S | 0, 9), T ^= Se(x + w | 0, 13), S ^= Se(T + x | 0, 18);
  i[s++] = a + V | 0, i[s++] = o + F | 0, i[s++] = c + U | 0, i[s++] = l + Y | 0, i[s++] = u + Q | 0, i[s++] = f + O | 0, i[s++] = m + B | 0, i[s++] = y + P | 0, i[s++] = _ + d | 0, i[s++] = v + h | 0, i[s++] = C + g | 0, i[s++] = A + E | 0, i[s++] = R + w | 0, i[s++] = I + x | 0, i[s++] = D + T | 0, i[s++] = L + S | 0;
}
function Ec(n, e, t, r, i) {
  let s = r + 0, a = r + 16 * i;
  for (let o = 0; o < 16; o++)
    t[a + o] = n[e + (2 * i - 1) * 16 + o];
  for (let o = 0; o < i; o++, s += 16, e += 16)
    dh(t, a, n, e, t, s), o > 0 && (a += 16), dh(t, s, n, e += 16, t, a);
}
function yA(n, e, t) {
  const r = ry({
    dkLen: 32,
    asyncTick: 10,
    maxmem: 1073742848
  }, t), { N: i, r: s, p: a, dkLen: o, asyncTick: c, maxmem: l, onProgress: u } = r;
  if (Ft(i), Ft(s), Ft(a), Ft(o), Ft(c), Ft(l), u !== void 0 && typeof u != "function")
    throw new Error("progressCb should be function");
  const f = 128 * s, m = f / 4;
  if (i <= 1 || i & i - 1 || i >= 2 ** (f / 8) || i > 2 ** 32)
    throw new Error("Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32");
  if (a < 0 || a > (2 ** 32 - 1) * 32 / f)
    throw new Error("Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)");
  if (o < 0 || o > (2 ** 32 - 1) * 32)
    throw new Error("Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32");
  const y = f * (i + a);
  if (y > l)
    throw new Error(`Scrypt: parameters too large, ${y} (128 * r * (N + p)) > ${l} (maxmem)`);
  const _ = Ju(js, n, e, { c: 1, dkLen: f * a }), v = Ur(_), C = Ur(new Uint8Array(f * i)), A = Ur(new Uint8Array(f));
  let R = () => {
  };
  if (u) {
    const I = 2 * i * a, D = Math.max(Math.floor(I / 1e4), 1);
    let L = 0;
    R = () => {
      L++, u && (!(L % D) || L === I) && u(L / I);
    };
  }
  return { N: i, r: s, p: a, dkLen: o, blockSize32: m, V: C, B32: v, B: _, tmp: A, blockMixCb: R, asyncTick: c };
}
function _A(n, e, t, r, i) {
  const s = Ju(js, n, t, { c: 1, dkLen: e });
  return t.fill(0), r.fill(0), i.fill(0), s;
}
function vA(n, e, t) {
  const { N: r, r: i, p: s, dkLen: a, blockSize32: o, V: c, B32: l, B: u, tmp: f, blockMixCb: m } = yA(n, e, t);
  for (let y = 0; y < s; y++) {
    const _ = o * y;
    for (let v = 0; v < o; v++)
      c[v] = l[_ + v];
    for (let v = 0, C = 0; v < r - 1; v++)
      Ec(c, C, c, C += o, i), m();
    Ec(c, (r - 1) * o, l, _, i), m();
    for (let v = 0; v < r; v++) {
      const C = l[_ + o - 16] % r;
      for (let A = 0; A < o; A++)
        f[A] = l[_ + A] ^ c[C * o + A];
      Ec(f, 0, l, _, i), m();
    }
  }
  return _A(n, a, u, c, f);
}
const xa = {
  N: 32768,
  p: 1,
  r: 8
};
function y0(n, e = Ws(), t = xa, r) {
  const i = j(n);
  return {
    params: t,
    password: !Rt || !r && It() ? vE(i, e, Math.log2(t.N), t.r, t.p) : vA(i, e, J({ dkLen: 64 }, t)),
    salt: e
  };
}
function bA(n) {
  const e = n.subarray(0, 32), t = fn(n.subarray(32 + 0, 32 + 4), mc).toNumber(), r = fn(n.subarray(32 + 4, 32 + 8), mc).toNumber(), i = fn(n.subarray(32 + 8, 32 + 12), mc).toNumber();
  if (t !== xa.N || r !== xa.p || i !== xa.r)
    throw new Error("Invalid injected scrypt params found");
  return { params: { N: t, p: r, r: i }, salt: e };
}
function wA(n, { N: e, p: t, r }) {
  return Me(n, Lt(e, gc), Lt(t, gc), Lt(r, gc));
}
const _0 = ["scrypt", "xsalsa20-poly1305"], xA = ["none"], SA = "3", fh = 24, EA = 32 + 3 * 4;
function CA(n, e, t = _0) {
  if (n) {
    if (t.includes("xsalsa20-poly1305") && !e)
      throw new Error("Password required to decode encrypted data");
  } else
    throw new Error("No encrypted data available to decode");
  let r = n;
  if (e) {
    let i;
    if (t.includes("scrypt")) {
      const { params: s, salt: a } = bA(n);
      i = y0(e, a, s).password, n = n.subarray(EA);
    } else
      i = Ze(e);
    r = mA(n.subarray(fh), n.subarray(0, fh), Wm(i, 256, !0));
  }
  if (!r)
    throw new Error("Unable to decode using the supplied passphrase");
  return r;
}
function AA(n, e, t) {
  return {
    encoded: M3(n),
    encoding: {
      content: e,
      type: t ? _0 : xA,
      version: SA
    }
  };
}
const hh = (n) => (e, t, r) => B3(e, t, r, n), v0 = [
  ["ecdsa", hh("blake2")],
  ["ethereum", hh("keccak")]
], PA = [
  ["ed25519", Xy],
  ["sr25519", Yy],
  ...v0
], kA = ["ed25519", "sr25519", "ecdsa"];
function b0(n, { message: e, publicKey: t, signature: r }, i = PA) {
  return n.isValid = i.some(([s, a]) => {
    try {
      if (a(e, r, t))
        return n.crypto = s, !0;
    } catch {
    }
    return !1;
  }), n;
}
function TA(n, { message: e, publicKey: t, signature: r }) {
  if (![0, 1, 2].includes(r[0]))
    throw new Error(`Unknown crypto type, expected signature prefix [0..2], found ${r[0]}`);
  const i = kA[r[0]] || "none";
  n.crypto = i;
  try {
    n.isValid = {
      ecdsa: () => b0(n, { message: e, publicKey: t, signature: r.subarray(1) }, v0).isValid,
      ed25519: () => Xy(e, r.subarray(1), t),
      none: () => {
        throw Error("no verify for `none` crypto type");
      },
      sr25519: () => Yy(e, r.subarray(1), t)
    }[i]();
  } catch {
  }
  return n;
}
function NA(n) {
  return [0, 1, 2].includes(n[0]) && [65, 66].includes(n.length) ? TA : b0;
}
function ph(n, e, t) {
  const r = j(e);
  if (![64, 65, 66].includes(r.length))
    throw new Error(`Invalid signature length, expected [64..66] bytes, found ${r.length}`);
  const i = rn(t), s = { message: j(n), publicKey: i, signature: r }, a = { crypto: "none", isValid: !1, isWrapped: vs(s.message, !0), publicKey: i }, o = vs(s.message, !1), c = NA(r);
  return c(a, s), a.crypto !== "none" || a.isWrapped && !o ? a : (s.message = o ? Gm(s.message) : Zm(s.message), c(a, s));
}
const Zt = Fe("11400714785074694791"), qn = Fe("14029467366897019727"), mh = Fe("1609587929392839161"), ts = Fe("9650029242287828579"), gh = Fe("2870177450012600261"), sr = Fe("0xffffffffffffffff"), RA = Fe(7), IA = Fe(11), OA = Fe(12), MA = Fe(16), LA = Fe(18), DA = Fe(23), UA = Fe(27), VA = Fe(29), _i = Fe(31), BA = Fe(32), HA = Fe(33), FA = Fe(64), yh = Fe(256);
function un(n, e) {
  const t = n & sr;
  return (t << e | t >> FA - e) & sr;
}
function Ml(n, e, t) {
  const r = new Array(t);
  let i = 0;
  for (let a = 0; a < t; a++, i += 2)
    r[a] = Fe(n[e + i] | n[e + 1 + i] << 8);
  let s = ii;
  for (let a = t - 1; a >= 0; a--)
    s = (s << MA) + r[a];
  return s;
}
function jA(n, e) {
  const t = {
    seed: n,
    u8a: new Uint8Array(32),
    u8asize: 0,
    v1: n + Zt + qn,
    v2: n + qn,
    v3: n,
    v4: n - Zt
  };
  if (e.length < 32)
    return t.u8a.set(e), t.u8asize = e.length, t;
  const r = e.length - 32;
  let i = 0;
  if (r >= 0) {
    const s = (a) => Zt * un(a + qn * Ml(e, i, 4), _i);
    do
      t.v1 = s(t.v1), i += 8, t.v2 = s(t.v2), i += 8, t.v3 = s(t.v3), i += 8, t.v4 = s(t.v4), i += 8;
    while (i <= r);
  }
  return i < e.length && (t.u8a.set(e.subarray(i, e.length)), t.u8asize = e.length - i), t;
}
function WA(n, e) {
  const { seed: t, u8a: r, u8asize: i, v1: s, v2: a, v3: o, v4: c } = jA(Fe(e), n);
  let l = 0, u = sr & Fe(n.length) + (n.length >= 32 ? ((((un(s, Br) + un(a, RA) + un(o, OA) + un(c, LA) ^ Zt * un(s * qn, _i)) * Zt + ts ^ Zt * un(a * qn, _i)) * Zt + ts ^ Zt * un(o * qn, _i)) * Zt + ts ^ Zt * un(c * qn, _i)) * Zt + ts : t + gh);
  for (; l <= i - 8; )
    u = sr & ts + Zt * un(u ^ Zt * un(qn * Ml(r, l, 4), _i), UA), l += 8;
  for (l + 4 <= i && (u = sr & mh + qn * un(u ^ Zt * Ml(r, l, 2), DA), l += 4); l < i; )
    u = sr & Zt * un(u ^ gh * Fe(r[l++]), IA);
  u = sr & qn * (u ^ u >> HA), u = sr & mh * (u ^ u >> VA), u = sr & (u ^ u >> BA);
  const f = new Uint8Array(8);
  for (let m = 7; m >= 0; m--)
    f[m] = Number(u % yh), u = u / yh;
  return f;
}
function Pi(n, e = 64, t) {
  const r = Math.ceil(e / 64), i = j(n);
  if (!Rt || !t && It())
    return xE(i, r);
  const s = new Uint8Array(r * 8);
  for (let a = 0; a < r; a++)
    s.set(WA(i, a).reverse(), a * 8);
  return s;
}
function qA(n) {
  return new Promise((e) => {
    document.readyState === "complete" ? e(n()) : window.addEventListener("load", () => e(n()));
  });
}
const ja = window;
ja.injectedWeb3 = ja.injectedWeb3 || {};
w0();
let _h = null;
function w0() {
  return Object.values(ja.injectedWeb3).filter(({ connect: n, enable: e }) => !!(n || e)).length !== 0;
}
function zA(n) {
  return Promise.all(Object.entries(ja.injectedWeb3).map(([e, { connect: t, enable: r, version: i }]) => Promise.resolve().then(() => t ? t(n) : r ? r(n).then((s) => J({ name: e, version: i || "unknown" }, s)) : Promise.reject(new Error("No connect(..) or enable(...) hook found"))).catch(({ message: s }) => {
    console.error(`Error initializing ${e}: ${s}`);
  }))).then((e) => e.filter((t) => !!t));
}
function XA(n, e = []) {
  if (!n)
    throw new Error("You must pass a name for your app to the web3Enable function");
  const t = e.length ? Promise.all(e.map((r) => r().catch(() => !1))) : Promise.resolve([!0]);
  return _h = qA(() => t.then(() => zA(n).then((r) => r.map((i) => (i.accounts.subscribe || (i.accounts.subscribe = (s) => (i.accounts.get().then(s).catch(console.error), () => {
  })), i))).catch(() => []).then((r) => {
    const i = r.map(({ name: s, version: a }) => `${s}/${a}`);
    return w0(), console.info(`web3Enable: Enabled ${r.length} extension${r.length !== 1 ? "s" : ""}: ${i.join(", ")}`), r;
  }))), _h;
}
class Ll extends Error {
  constructor(e) {
    super(e || "No account found");
  }
}
class GA extends Error {
  constructor(e) {
    super(e || "No extensions found");
  }
}
class x0 {
}
class ZA extends x0 {
  async getAccount(e) {
    const { dappName: t, userAccountAddress: r } = e;
    if (!r)
      throw new Ll("No account address provided");
    const i = await XA(t);
    if (i.length === 0)
      throw new GA();
    for (const s of i) {
      const o = (await s.accounts.get()).find((c) => c.address === r);
      if (o)
        return { account: o, extension: s };
    }
    throw new Ll("No account found matching " + r);
  }
}
const vh = { name: "@polkadot/api", path: import.meta && import.meta.url ? new URL(import.meta.url).pathname.substring(0, new URL(import.meta.url).pathname.lastIndexOf("/") + 1) : "auto", type: "esm", version: "10.11.1" };
function S0(n, e) {
  return n.findMetaCall(j(e));
}
function E0(n, e) {
  return n.findMetaError(j(e));
}
function Le(n) {
  return typeof n == "function";
}
function Yu(n) {
  var e = function(r) {
    Error.call(r), r.stack = new Error().stack;
  }, t = n(e);
  return t.prototype = Object.create(Error.prototype), t.prototype.constructor = t, t;
}
var Cc = Yu(function(n) {
  return function(t) {
    n(this), this.message = t ? t.length + ` errors occurred during unsubscription:
` + t.map(function(r, i) {
      return i + 1 + ") " + r.toString();
    }).join(`
  `) : "", this.name = "UnsubscriptionError", this.errors = t;
  };
});
function Wa(n, e) {
  if (n) {
    var t = n.indexOf(e);
    0 <= t && n.splice(t, 1);
  }
}
var gr = function() {
  function n(e) {
    this.initialTeardown = e, this.closed = !1, this._parentage = null, this._finalizers = null;
  }
  return n.prototype.unsubscribe = function() {
    var e, t, r, i, s;
    if (!this.closed) {
      this.closed = !0;
      var a = this._parentage;
      if (a)
        if (this._parentage = null, Array.isArray(a))
          try {
            for (var o = Di(a), c = o.next(); !c.done; c = o.next()) {
              var l = c.value;
              l.remove(this);
            }
          } catch (v) {
            e = { error: v };
          } finally {
            try {
              c && !c.done && (t = o.return) && t.call(o);
            } finally {
              if (e)
                throw e.error;
            }
          }
        else
          a.remove(this);
      var u = this.initialTeardown;
      if (Le(u))
        try {
          u();
        } catch (v) {
          s = v instanceof Cc ? v.errors : [v];
        }
      var f = this._finalizers;
      if (f) {
        this._finalizers = null;
        try {
          for (var m = Di(f), y = m.next(); !y.done; y = m.next()) {
            var _ = y.value;
            try {
              bh(_);
            } catch (v) {
              s = s ?? [], v instanceof Cc ? s = $n($n([], jr(s)), jr(v.errors)) : s.push(v);
            }
          }
        } catch (v) {
          r = { error: v };
        } finally {
          try {
            y && !y.done && (i = m.return) && i.call(m);
          } finally {
            if (r)
              throw r.error;
          }
        }
      }
      if (s)
        throw new Cc(s);
    }
  }, n.prototype.add = function(e) {
    var t;
    if (e && e !== this)
      if (this.closed)
        bh(e);
      else {
        if (e instanceof n) {
          if (e.closed || e._hasParent(this))
            return;
          e._addParent(this);
        }
        (this._finalizers = (t = this._finalizers) !== null && t !== void 0 ? t : []).push(e);
      }
  }, n.prototype._hasParent = function(e) {
    var t = this._parentage;
    return t === e || Array.isArray(t) && t.includes(e);
  }, n.prototype._addParent = function(e) {
    var t = this._parentage;
    this._parentage = Array.isArray(t) ? (t.push(e), t) : t ? [t, e] : e;
  }, n.prototype._removeParent = function(e) {
    var t = this._parentage;
    t === e ? this._parentage = null : Array.isArray(t) && Wa(t, e);
  }, n.prototype.remove = function(e) {
    var t = this._finalizers;
    t && Wa(t, e), e instanceof n && e._removeParent(this);
  }, n.EMPTY = function() {
    var e = new n();
    return e.closed = !0, e;
  }(), n;
}(), C0 = gr.EMPTY;
function A0(n) {
  return n instanceof gr || n && "closed" in n && Le(n.remove) && Le(n.add) && Le(n.unsubscribe);
}
function bh(n) {
  Le(n) ? n() : n.unsubscribe();
}
var P0 = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: !1,
  useDeprecatedNextContext: !1
}, Dl = {
  setTimeout: function(n, e) {
    for (var t = [], r = 2; r < arguments.length; r++)
      t[r - 2] = arguments[r];
    var i = Dl.delegate;
    return i != null && i.setTimeout ? i.setTimeout.apply(i, $n([n, e], jr(t))) : setTimeout.apply(void 0, $n([n, e], jr(t)));
  },
  clearTimeout: function(n) {
    var e = Dl.delegate;
    return ((e == null ? void 0 : e.clearTimeout) || clearTimeout)(n);
  },
  delegate: void 0
};
function k0(n) {
  Dl.setTimeout(function() {
    throw n;
  });
}
function wh() {
}
function Sa(n) {
  n();
}
var Qu = function(n) {
  pn(e, n);
  function e(t) {
    var r = n.call(this) || this;
    return r.isStopped = !1, t ? (r.destination = t, A0(t) && t.add(r)) : r.destination = QA, r;
  }
  return e.create = function(t, r, i) {
    return new qa(t, r, i);
  }, e.prototype.next = function(t) {
    this.isStopped || this._next(t);
  }, e.prototype.error = function(t) {
    this.isStopped || (this.isStopped = !0, this._error(t));
  }, e.prototype.complete = function() {
    this.isStopped || (this.isStopped = !0, this._complete());
  }, e.prototype.unsubscribe = function() {
    this.closed || (this.isStopped = !0, n.prototype.unsubscribe.call(this), this.destination = null);
  }, e.prototype._next = function(t) {
    this.destination.next(t);
  }, e.prototype._error = function(t) {
    try {
      this.destination.error(t);
    } finally {
      this.unsubscribe();
    }
  }, e.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  }, e;
}(gr), JA = Function.prototype.bind;
function Ac(n, e) {
  return JA.call(n, e);
}
var KA = function() {
  function n(e) {
    this.partialObserver = e;
  }
  return n.prototype.next = function(e) {
    var t = this.partialObserver;
    if (t.next)
      try {
        t.next(e);
      } catch (r) {
        ia(r);
      }
  }, n.prototype.error = function(e) {
    var t = this.partialObserver;
    if (t.error)
      try {
        t.error(e);
      } catch (r) {
        ia(r);
      }
    else
      ia(e);
  }, n.prototype.complete = function() {
    var e = this.partialObserver;
    if (e.complete)
      try {
        e.complete();
      } catch (t) {
        ia(t);
      }
  }, n;
}(), qa = function(n) {
  pn(e, n);
  function e(t, r, i) {
    var s = n.call(this) || this, a;
    if (Le(t) || !t)
      a = {
        next: t ?? void 0,
        error: r ?? void 0,
        complete: i ?? void 0
      };
    else {
      var o;
      s && P0.useDeprecatedNextContext ? (o = Object.create(t), o.unsubscribe = function() {
        return s.unsubscribe();
      }, a = {
        next: t.next && Ac(t.next, o),
        error: t.error && Ac(t.error, o),
        complete: t.complete && Ac(t.complete, o)
      }) : a = t;
    }
    return s.destination = new KA(a), s;
  }
  return e;
}(Qu);
function ia(n) {
  k0(n);
}
function YA(n) {
  throw n;
}
var QA = {
  closed: !0,
  next: wh,
  error: YA,
  complete: wh
}, $u = function() {
  return typeof Symbol == "function" && Symbol.observable || "@@observable";
}();
function ci(n) {
  return n;
}
function $A(n) {
  return n.length === 0 ? ci : n.length === 1 ? n[0] : function(t) {
    return n.reduce(function(r, i) {
      return i(r);
    }, t);
  };
}
var Nt = function() {
  function n(e) {
    e && (this._subscribe = e);
  }
  return n.prototype.lift = function(e) {
    var t = new n();
    return t.source = this, t.operator = e, t;
  }, n.prototype.subscribe = function(e, t, r) {
    var i = this, s = tP(e) ? e : new qa(e, t, r);
    return Sa(function() {
      var a = i, o = a.operator, c = a.source;
      s.add(o ? o.call(s, c) : c ? i._subscribe(s) : i._trySubscribe(s));
    }), s;
  }, n.prototype._trySubscribe = function(e) {
    try {
      return this._subscribe(e);
    } catch (t) {
      e.error(t);
    }
  }, n.prototype.forEach = function(e, t) {
    var r = this;
    return t = xh(t), new t(function(i, s) {
      var a = new qa({
        next: function(o) {
          try {
            e(o);
          } catch (c) {
            s(c), a.unsubscribe();
          }
        },
        error: s,
        complete: i
      });
      r.subscribe(a);
    });
  }, n.prototype._subscribe = function(e) {
    var t;
    return (t = this.source) === null || t === void 0 ? void 0 : t.subscribe(e);
  }, n.prototype[$u] = function() {
    return this;
  }, n.prototype.pipe = function() {
    for (var e = [], t = 0; t < arguments.length; t++)
      e[t] = arguments[t];
    return $A(e)(this);
  }, n.prototype.toPromise = function(e) {
    var t = this;
    return e = xh(e), new e(function(r, i) {
      var s;
      t.subscribe(function(a) {
        return s = a;
      }, function(a) {
        return i(a);
      }, function() {
        return r(s);
      });
    });
  }, n.create = function(e) {
    return new n(e);
  }, n;
}();
function xh(n) {
  var e;
  return (e = n ?? P0.Promise) !== null && e !== void 0 ? e : Promise;
}
function eP(n) {
  return n && Le(n.next) && Le(n.error) && Le(n.complete);
}
function tP(n) {
  return n && n instanceof Qu || eP(n) && A0(n);
}
function T0(n) {
  return Le(n == null ? void 0 : n.lift);
}
function Ht(n) {
  return function(e) {
    if (T0(e))
      return e.lift(function(t) {
        try {
          return n(t, this);
        } catch (r) {
          this.error(r);
        }
      });
    throw new TypeError("Unable to lift unknown Observable type");
  };
}
function Bt(n, e, t, r, i) {
  return new nP(n, e, t, r, i);
}
var nP = function(n) {
  pn(e, n);
  function e(t, r, i, s, a, o) {
    var c = n.call(this, t) || this;
    return c.onFinalize = a, c.shouldUnsubscribe = o, c._next = r ? function(l) {
      try {
        r(l);
      } catch (u) {
        t.error(u);
      }
    } : n.prototype._next, c._error = s ? function(l) {
      try {
        s(l);
      } catch (u) {
        t.error(u);
      } finally {
        this.unsubscribe();
      }
    } : n.prototype._error, c._complete = i ? function() {
      try {
        i();
      } catch (l) {
        t.error(l);
      } finally {
        this.unsubscribe();
      }
    } : n.prototype._complete, c;
  }
  return e.prototype.unsubscribe = function() {
    var t;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var r = this.closed;
      n.prototype.unsubscribe.call(this), !r && ((t = this.onFinalize) === null || t === void 0 || t.call(this));
    }
  }, e;
}(Qu);
function ed() {
  return Ht(function(n, e) {
    var t = null;
    n._refCount++;
    var r = Bt(e, void 0, void 0, void 0, function() {
      if (!n || n._refCount <= 0 || 0 < --n._refCount) {
        t = null;
        return;
      }
      var i = n._connection, s = t;
      t = null, i && (!s || i === s) && i.unsubscribe(), e.unsubscribe();
    });
    n.subscribe(r), r.closed || (t = n.connect());
  });
}
var rP = function(n) {
  pn(e, n);
  function e(t, r) {
    var i = n.call(this) || this;
    return i.source = t, i.subjectFactory = r, i._subject = null, i._refCount = 0, i._connection = null, T0(t) && (i.lift = t.lift), i;
  }
  return e.prototype._subscribe = function(t) {
    return this.getSubject().subscribe(t);
  }, e.prototype.getSubject = function() {
    var t = this._subject;
    return (!t || t.isStopped) && (this._subject = this.subjectFactory()), this._subject;
  }, e.prototype._teardown = function() {
    this._refCount = 0;
    var t = this._connection;
    this._subject = this._connection = null, t == null || t.unsubscribe();
  }, e.prototype.connect = function() {
    var t = this, r = this._connection;
    if (!r) {
      r = this._connection = new gr();
      var i = this.getSubject();
      r.add(this.source.subscribe(Bt(i, void 0, function() {
        t._teardown(), i.complete();
      }, function(s) {
        t._teardown(), i.error(s);
      }, function() {
        return t._teardown();
      }))), r.closed && (this._connection = null, r = gr.EMPTY);
    }
    return r;
  }, e.prototype.refCount = function() {
    return ed()(this);
  }, e;
}(Nt), iP = Yu(function(n) {
  return function() {
    n(this), this.name = "ObjectUnsubscribedError", this.message = "object unsubscribed";
  };
}), wo = function(n) {
  pn(e, n);
  function e() {
    var t = n.call(this) || this;
    return t.closed = !1, t.currentObservers = null, t.observers = [], t.isStopped = !1, t.hasError = !1, t.thrownError = null, t;
  }
  return e.prototype.lift = function(t) {
    var r = new Sh(this, this);
    return r.operator = t, r;
  }, e.prototype._throwIfClosed = function() {
    if (this.closed)
      throw new iP();
  }, e.prototype.next = function(t) {
    var r = this;
    Sa(function() {
      var i, s;
      if (r._throwIfClosed(), !r.isStopped) {
        r.currentObservers || (r.currentObservers = Array.from(r.observers));
        try {
          for (var a = Di(r.currentObservers), o = a.next(); !o.done; o = a.next()) {
            var c = o.value;
            c.next(t);
          }
        } catch (l) {
          i = { error: l };
        } finally {
          try {
            o && !o.done && (s = a.return) && s.call(a);
          } finally {
            if (i)
              throw i.error;
          }
        }
      }
    });
  }, e.prototype.error = function(t) {
    var r = this;
    Sa(function() {
      if (r._throwIfClosed(), !r.isStopped) {
        r.hasError = r.isStopped = !0, r.thrownError = t;
        for (var i = r.observers; i.length; )
          i.shift().error(t);
      }
    });
  }, e.prototype.complete = function() {
    var t = this;
    Sa(function() {
      if (t._throwIfClosed(), !t.isStopped) {
        t.isStopped = !0;
        for (var r = t.observers; r.length; )
          r.shift().complete();
      }
    });
  }, e.prototype.unsubscribe = function() {
    this.isStopped = this.closed = !0, this.observers = this.currentObservers = null;
  }, Object.defineProperty(e.prototype, "observed", {
    get: function() {
      var t;
      return ((t = this.observers) === null || t === void 0 ? void 0 : t.length) > 0;
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype._trySubscribe = function(t) {
    return this._throwIfClosed(), n.prototype._trySubscribe.call(this, t);
  }, e.prototype._subscribe = function(t) {
    return this._throwIfClosed(), this._checkFinalizedStatuses(t), this._innerSubscribe(t);
  }, e.prototype._innerSubscribe = function(t) {
    var r = this, i = this, s = i.hasError, a = i.isStopped, o = i.observers;
    return s || a ? C0 : (this.currentObservers = null, o.push(t), new gr(function() {
      r.currentObservers = null, Wa(o, t);
    }));
  }, e.prototype._checkFinalizedStatuses = function(t) {
    var r = this, i = r.hasError, s = r.thrownError, a = r.isStopped;
    i ? t.error(s) : a && t.complete();
  }, e.prototype.asObservable = function() {
    var t = new Nt();
    return t.source = this, t;
  }, e.create = function(t, r) {
    return new Sh(t, r);
  }, e;
}(Nt), Sh = function(n) {
  pn(e, n);
  function e(t, r) {
    var i = n.call(this) || this;
    return i.destination = t, i.source = r, i;
  }
  return e.prototype.next = function(t) {
    var r, i;
    (i = (r = this.destination) === null || r === void 0 ? void 0 : r.next) === null || i === void 0 || i.call(r, t);
  }, e.prototype.error = function(t) {
    var r, i;
    (i = (r = this.destination) === null || r === void 0 ? void 0 : r.error) === null || i === void 0 || i.call(r, t);
  }, e.prototype.complete = function() {
    var t, r;
    (r = (t = this.destination) === null || t === void 0 ? void 0 : t.complete) === null || r === void 0 || r.call(t);
  }, e.prototype._subscribe = function(t) {
    var r, i;
    return (i = (r = this.source) === null || r === void 0 ? void 0 : r.subscribe(t)) !== null && i !== void 0 ? i : C0;
  }, e;
}(wo), Eh = function(n) {
  pn(e, n);
  function e(t) {
    var r = n.call(this) || this;
    return r._value = t, r;
  }
  return Object.defineProperty(e.prototype, "value", {
    get: function() {
      return this.getValue();
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype._subscribe = function(t) {
    var r = n.prototype._subscribe.call(this, t);
    return !r.closed && t.next(this._value), r;
  }, e.prototype.getValue = function() {
    var t = this, r = t.hasError, i = t.thrownError, s = t._value;
    if (r)
      throw i;
    return this._throwIfClosed(), s;
  }, e.prototype.next = function(t) {
    n.prototype.next.call(this, this._value = t);
  }, e;
}(wo), td = {
  now: function() {
    return (td.delegate || Date).now();
  },
  delegate: void 0
}, sP = function(n) {
  pn(e, n);
  function e(t, r, i) {
    t === void 0 && (t = 1 / 0), r === void 0 && (r = 1 / 0), i === void 0 && (i = td);
    var s = n.call(this) || this;
    return s._bufferSize = t, s._windowTime = r, s._timestampProvider = i, s._buffer = [], s._infiniteTimeWindow = !0, s._infiniteTimeWindow = r === 1 / 0, s._bufferSize = Math.max(1, t), s._windowTime = Math.max(1, r), s;
  }
  return e.prototype.next = function(t) {
    var r = this, i = r.isStopped, s = r._buffer, a = r._infiniteTimeWindow, o = r._timestampProvider, c = r._windowTime;
    i || (s.push(t), !a && s.push(o.now() + c)), this._trimBuffer(), n.prototype.next.call(this, t);
  }, e.prototype._subscribe = function(t) {
    this._throwIfClosed(), this._trimBuffer();
    for (var r = this._innerSubscribe(t), i = this, s = i._infiniteTimeWindow, a = i._buffer, o = a.slice(), c = 0; c < o.length && !t.closed; c += s ? 1 : 2)
      t.next(o[c]);
    return this._checkFinalizedStatuses(t), r;
  }, e.prototype._trimBuffer = function() {
    var t = this, r = t._bufferSize, i = t._timestampProvider, s = t._buffer, a = t._infiniteTimeWindow, o = (a ? 1 : 2) * r;
    if (r < 1 / 0 && o < s.length && s.splice(0, s.length - o), !a) {
      for (var c = i.now(), l = 0, u = 1; u < s.length && s[u] <= c; u += 2)
        l = u;
      l && s.splice(0, l + 1);
    }
  }, e;
}(wo), aP = function(n) {
  pn(e, n);
  function e(t, r) {
    return n.call(this) || this;
  }
  return e.prototype.schedule = function(t, r) {
    return this;
  }, e;
}(gr), za = {
  setInterval: function(n, e) {
    for (var t = [], r = 2; r < arguments.length; r++)
      t[r - 2] = arguments[r];
    var i = za.delegate;
    return i != null && i.setInterval ? i.setInterval.apply(i, $n([n, e], jr(t))) : setInterval.apply(void 0, $n([n, e], jr(t)));
  },
  clearInterval: function(n) {
    var e = za.delegate;
    return ((e == null ? void 0 : e.clearInterval) || clearInterval)(n);
  },
  delegate: void 0
}, oP = function(n) {
  pn(e, n);
  function e(t, r) {
    var i = n.call(this, t, r) || this;
    return i.scheduler = t, i.work = r, i.pending = !1, i;
  }
  return e.prototype.schedule = function(t, r) {
    var i;
    if (r === void 0 && (r = 0), this.closed)
      return this;
    this.state = t;
    var s = this.id, a = this.scheduler;
    return s != null && (this.id = this.recycleAsyncId(a, s, r)), this.pending = !0, this.delay = r, this.id = (i = this.id) !== null && i !== void 0 ? i : this.requestAsyncId(a, this.id, r), this;
  }, e.prototype.requestAsyncId = function(t, r, i) {
    return i === void 0 && (i = 0), za.setInterval(t.flush.bind(t, this), i);
  }, e.prototype.recycleAsyncId = function(t, r, i) {
    if (i === void 0 && (i = 0), i != null && this.delay === i && this.pending === !1)
      return r;
    r != null && za.clearInterval(r);
  }, e.prototype.execute = function(t, r) {
    if (this.closed)
      return new Error("executing a cancelled action");
    this.pending = !1;
    var i = this._execute(t, r);
    if (i)
      return i;
    this.pending === !1 && this.id != null && (this.id = this.recycleAsyncId(this.scheduler, this.id, null));
  }, e.prototype._execute = function(t, r) {
    var i = !1, s;
    try {
      this.work(t);
    } catch (a) {
      i = !0, s = a || new Error("Scheduled action threw falsy error");
    }
    if (i)
      return this.unsubscribe(), s;
  }, e.prototype.unsubscribe = function() {
    if (!this.closed) {
      var t = this, r = t.id, i = t.scheduler, s = i.actions;
      this.work = this.state = this.scheduler = null, this.pending = !1, Wa(s, this), r != null && (this.id = this.recycleAsyncId(i, r, null)), this.delay = null, n.prototype.unsubscribe.call(this);
    }
  }, e;
}(aP), cP = 1, Pc, Ul = {};
function Ch(n) {
  return n in Ul ? (delete Ul[n], !0) : !1;
}
var N0 = {
  setImmediate: function(n) {
    var e = cP++;
    return Ul[e] = !0, Pc || (Pc = Promise.resolve()), Pc.then(function() {
      return Ch(e) && n();
    }), e;
  },
  clearImmediate: function(n) {
    Ch(n);
  }
}, lP = N0.setImmediate, uP = N0.clearImmediate, Xa = {
  setImmediate: function() {
    for (var n = [], e = 0; e < arguments.length; e++)
      n[e] = arguments[e];
    var t = Xa.delegate;
    return ((t == null ? void 0 : t.setImmediate) || lP).apply(void 0, $n([], jr(n)));
  },
  clearImmediate: function(n) {
    var e = Xa.delegate;
    return ((e == null ? void 0 : e.clearImmediate) || uP)(n);
  },
  delegate: void 0
}, dP = function(n) {
  pn(e, n);
  function e(t, r) {
    var i = n.call(this, t, r) || this;
    return i.scheduler = t, i.work = r, i;
  }
  return e.prototype.requestAsyncId = function(t, r, i) {
    return i === void 0 && (i = 0), i !== null && i > 0 ? n.prototype.requestAsyncId.call(this, t, r, i) : (t.actions.push(this), t._scheduled || (t._scheduled = Xa.setImmediate(t.flush.bind(t, void 0))));
  }, e.prototype.recycleAsyncId = function(t, r, i) {
    var s;
    if (i === void 0 && (i = 0), i != null ? i > 0 : this.delay > 0)
      return n.prototype.recycleAsyncId.call(this, t, r, i);
    var a = t.actions;
    r != null && ((s = a[a.length - 1]) === null || s === void 0 ? void 0 : s.id) !== r && (Xa.clearImmediate(r), t._scheduled === r && (t._scheduled = void 0));
  }, e;
}(oP), Ah = function() {
  function n(e, t) {
    t === void 0 && (t = n.now), this.schedulerActionCtor = e, this.now = t;
  }
  return n.prototype.schedule = function(e, t, r) {
    return t === void 0 && (t = 0), new this.schedulerActionCtor(this, e).schedule(r, t);
  }, n.now = td.now, n;
}(), fP = function(n) {
  pn(e, n);
  function e(t, r) {
    r === void 0 && (r = Ah.now);
    var i = n.call(this, t, r) || this;
    return i.actions = [], i._active = !1, i;
  }
  return e.prototype.flush = function(t) {
    var r = this.actions;
    if (this._active) {
      r.push(t);
      return;
    }
    var i;
    this._active = !0;
    do
      if (i = t.execute(t.state, t.delay))
        break;
    while (t = r.shift());
    if (this._active = !1, i) {
      for (; t = r.shift(); )
        t.unsubscribe();
      throw i;
    }
  }, e;
}(Ah), hP = function(n) {
  pn(e, n);
  function e() {
    return n !== null && n.apply(this, arguments) || this;
  }
  return e.prototype.flush = function(t) {
    this._active = !0;
    var r = this._scheduled;
    this._scheduled = void 0;
    var i = this.actions, s;
    t = t || i.shift();
    do
      if (s = t.execute(t.state, t.delay))
        break;
    while ((t = i[0]) && t.id === r && i.shift());
    if (this._active = !1, s) {
      for (; (t = i[0]) && t.id === r && i.shift(); )
        t.unsubscribe();
      throw s;
    }
  }, e;
}(fP), pP = new hP(dP), R0 = new Nt(function(n) {
  return n.complete();
});
function mP(n) {
  return n && Le(n.schedule);
}
function I0(n) {
  return n[n.length - 1];
}
function gP(n) {
  return Le(I0(n)) ? n.pop() : void 0;
}
function xo(n) {
  return mP(I0(n)) ? n.pop() : void 0;
}
var O0 = function(n) {
  return n && typeof n.length == "number" && typeof n != "function";
};
function M0(n) {
  return Le(n == null ? void 0 : n.then);
}
function L0(n) {
  return Le(n[$u]);
}
function D0(n) {
  return Symbol.asyncIterator && Le(n == null ? void 0 : n[Symbol.asyncIterator]);
}
function U0(n) {
  return new TypeError("You provided " + (n !== null && typeof n == "object" ? "an invalid object" : "'" + n + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}
function yP() {
  return typeof Symbol != "function" || !Symbol.iterator ? "@@iterator" : Symbol.iterator;
}
var V0 = yP();
function B0(n) {
  return Le(n == null ? void 0 : n[V0]);
}
function H0(n) {
  return Fx(this, arguments, function() {
    var t, r, i, s;
    return Dn(this, function(a) {
      switch (a.label) {
        case 0:
          t = n.getReader(), a.label = 1;
        case 1:
          a.trys.push([1, , 9, 10]), a.label = 2;
        case 2:
          return [4, Ci(t.read())];
        case 3:
          return r = a.sent(), i = r.value, s = r.done, s ? [4, Ci(void 0)] : [3, 5];
        case 4:
          return [2, a.sent()];
        case 5:
          return [4, Ci(i)];
        case 6:
          return [4, a.sent()];
        case 7:
          return a.sent(), [3, 2];
        case 8:
          return [3, 10];
        case 9:
          return t.releaseLock(), [7];
        case 10:
          return [2];
      }
    });
  });
}
function F0(n) {
  return Le(n == null ? void 0 : n.getReader);
}
function Gr(n) {
  if (n instanceof Nt)
    return n;
  if (n != null) {
    if (L0(n))
      return _P(n);
    if (O0(n))
      return vP(n);
    if (M0(n))
      return bP(n);
    if (D0(n))
      return j0(n);
    if (B0(n))
      return wP(n);
    if (F0(n))
      return xP(n);
  }
  throw U0(n);
}
function _P(n) {
  return new Nt(function(e) {
    var t = n[$u]();
    if (Le(t.subscribe))
      return t.subscribe(e);
    throw new TypeError("Provided object does not correctly implement Symbol.observable");
  });
}
function vP(n) {
  return new Nt(function(e) {
    for (var t = 0; t < n.length && !e.closed; t++)
      e.next(n[t]);
    e.complete();
  });
}
function bP(n) {
  return new Nt(function(e) {
    n.then(function(t) {
      e.closed || (e.next(t), e.complete());
    }, function(t) {
      return e.error(t);
    }).then(null, k0);
  });
}
function wP(n) {
  return new Nt(function(e) {
    var t, r;
    try {
      for (var i = Di(n), s = i.next(); !s.done; s = i.next()) {
        var a = s.value;
        if (e.next(a), e.closed)
          return;
      }
    } catch (o) {
      t = { error: o };
    } finally {
      try {
        s && !s.done && (r = i.return) && r.call(i);
      } finally {
        if (t)
          throw t.error;
      }
    }
    e.complete();
  });
}
function j0(n) {
  return new Nt(function(e) {
    SP(n, e).catch(function(t) {
      return e.error(t);
    });
  });
}
function xP(n) {
  return j0(H0(n));
}
function SP(n, e) {
  var t, r, i, s;
  return nr(this, void 0, void 0, function() {
    var a, o;
    return Dn(this, function(c) {
      switch (c.label) {
        case 0:
          c.trys.push([0, 5, 6, 11]), t = jx(n), c.label = 1;
        case 1:
          return [4, t.next()];
        case 2:
          if (r = c.sent(), !!r.done)
            return [3, 4];
          if (a = r.value, e.next(a), e.closed)
            return [2];
          c.label = 3;
        case 3:
          return [3, 1];
        case 4:
          return [3, 11];
        case 5:
          return o = c.sent(), i = { error: o }, [3, 11];
        case 6:
          return c.trys.push([6, , 9, 10]), r && !r.done && (s = t.return) ? [4, s.call(t)] : [3, 8];
        case 7:
          c.sent(), c.label = 8;
        case 8:
          return [3, 10];
        case 9:
          if (i)
            throw i.error;
          return [7];
        case 10:
          return [7];
        case 11:
          return e.complete(), [2];
      }
    });
  });
}
function pr(n, e, t, r, i) {
  r === void 0 && (r = 0), i === void 0 && (i = !1);
  var s = e.schedule(function() {
    t(), i ? n.add(this.schedule(null, r)) : this.unsubscribe();
  }, r);
  if (n.add(s), !i)
    return s;
}
function W0(n, e) {
  return e === void 0 && (e = 0), Ht(function(t, r) {
    t.subscribe(Bt(r, function(i) {
      return pr(r, n, function() {
        return r.next(i);
      }, e);
    }, function() {
      return pr(r, n, function() {
        return r.complete();
      }, e);
    }, function(i) {
      return pr(r, n, function() {
        return r.error(i);
      }, e);
    }));
  });
}
function q0(n, e) {
  return e === void 0 && (e = 0), Ht(function(t, r) {
    r.add(n.schedule(function() {
      return t.subscribe(r);
    }, e));
  });
}
function EP(n, e) {
  return Gr(n).pipe(q0(e), W0(e));
}
function CP(n, e) {
  return Gr(n).pipe(q0(e), W0(e));
}
function AP(n, e) {
  return new Nt(function(t) {
    var r = 0;
    return e.schedule(function() {
      r === n.length ? t.complete() : (t.next(n[r++]), t.closed || this.schedule());
    });
  });
}
function PP(n, e) {
  return new Nt(function(t) {
    var r;
    return pr(t, e, function() {
      r = n[V0](), pr(t, e, function() {
        var i, s, a;
        try {
          i = r.next(), s = i.value, a = i.done;
        } catch (o) {
          t.error(o);
          return;
        }
        a ? t.complete() : t.next(s);
      }, 0, !0);
    }), function() {
      return Le(r == null ? void 0 : r.return) && r.return();
    };
  });
}
function z0(n, e) {
  if (!n)
    throw new Error("Iterable cannot be null");
  return new Nt(function(t) {
    pr(t, e, function() {
      var r = n[Symbol.asyncIterator]();
      pr(t, e, function() {
        r.next().then(function(i) {
          i.done ? t.complete() : t.next(i.value);
        });
      }, 0, !0);
    });
  });
}
function kP(n, e) {
  return z0(H0(n), e);
}
function TP(n, e) {
  if (n != null) {
    if (L0(n))
      return EP(n, e);
    if (O0(n))
      return AP(n, e);
    if (M0(n))
      return CP(n, e);
    if (D0(n))
      return z0(n, e);
    if (B0(n))
      return PP(n, e);
    if (F0(n))
      return kP(n, e);
  }
  throw U0(n);
}
function Xn(n, e) {
  return e ? TP(n, e) : Gr(n);
}
function fe() {
  for (var n = [], e = 0; e < arguments.length; e++)
    n[e] = arguments[e];
  var t = xo(n);
  return Xn(n, t);
}
var nd = Yu(function(n) {
  return function() {
    n(this), this.name = "EmptyError", this.message = "no elements in sequence";
  };
});
function tn(n, e) {
  var t = typeof e == "object";
  return new Promise(function(r, i) {
    var s = new qa({
      next: function(a) {
        r(a), s.unsubscribe();
      },
      error: i,
      complete: function() {
        t ? r(e.defaultValue) : i(new nd());
      }
    });
    n.subscribe(s);
  });
}
function oe(n, e) {
  return Ht(function(t, r) {
    var i = 0;
    t.subscribe(Bt(r, function(s) {
      r.next(n.call(e, s, i++));
    }));
  });
}
var NP = Array.isArray;
function RP(n, e) {
  return NP(e) ? n.apply(void 0, $n([], jr(e))) : n(e);
}
function IP(n) {
  return oe(function(e) {
    return RP(n, e);
  });
}
var OP = Array.isArray, MP = Object.getPrototypeOf, LP = Object.prototype, DP = Object.keys;
function UP(n) {
  if (n.length === 1) {
    var e = n[0];
    if (OP(e))
      return { args: e, keys: null };
    if (VP(e)) {
      var t = DP(e);
      return {
        args: t.map(function(r) {
          return e[r];
        }),
        keys: t
      };
    }
  }
  return { args: n, keys: null };
}
function VP(n) {
  return n && typeof n == "object" && MP(n) === LP;
}
function BP(n, e) {
  return n.reduce(function(t, r, i) {
    return t[r] = e[i], t;
  }, {});
}
function Oe() {
  for (var n = [], e = 0; e < arguments.length; e++)
    n[e] = arguments[e];
  var t = xo(n), r = gP(n), i = UP(n), s = i.args, a = i.keys;
  if (s.length === 0)
    return Xn([], t);
  var o = new Nt(HP(s, t, a ? function(c) {
    return BP(a, c);
  } : ci));
  return r ? o.pipe(IP(r)) : o;
}
function HP(n, e, t) {
  return t === void 0 && (t = ci), function(r) {
    Ph(e, function() {
      for (var i = n.length, s = new Array(i), a = i, o = i, c = function(u) {
        Ph(e, function() {
          var f = Xn(n[u], e), m = !1;
          f.subscribe(Bt(r, function(y) {
            s[u] = y, m || (m = !0, o--), o || r.next(t(s.slice()));
          }, function() {
            --a || r.complete();
          }));
        }, r);
      }, l = 0; l < i; l++)
        c(l);
    }, r);
  };
}
function Ph(n, e, t) {
  n ? pr(t, n, e) : e();
}
function FP(n, e, t, r, i, s, a, o) {
  var c = [], l = 0, u = 0, f = !1, m = function() {
    f && !c.length && !l && e.complete();
  }, y = function(v) {
    return l < r ? _(v) : c.push(v);
  }, _ = function(v) {
    s && e.next(v), l++;
    var C = !1;
    Gr(t(v, u++)).subscribe(Bt(e, function(A) {
      i == null || i(A), s ? y(A) : e.next(A);
    }, function() {
      C = !0;
    }, void 0, function() {
      if (C)
        try {
          l--;
          for (var A = function() {
            var R = c.shift();
            a ? pr(e, a, function() {
              return _(R);
            }) : _(R);
          }; c.length && l < r; )
            A();
          m();
        } catch (R) {
          e.error(R);
        }
    }));
  };
  return n.subscribe(Bt(e, y, function() {
    f = !0, m();
  })), function() {
    o == null || o();
  };
}
function So(n, e, t) {
  return t === void 0 && (t = 1 / 0), Le(e) ? So(function(r, i) {
    return oe(function(s, a) {
      return e(r, s, i, a);
    })(Gr(n(r, i)));
  }, t) : (typeof e == "number" && (t = e), Ht(function(r, i) {
    return FP(r, i, n, t);
  }));
}
function jP(n) {
  return n === void 0 && (n = 1 / 0), So(ci, n);
}
function WP() {
  return jP(1);
}
function kh() {
  for (var n = [], e = 0; e < arguments.length; e++)
    n[e] = arguments[e];
  return WP()(Xn(n, xo(n)));
}
function qP(n, e) {
  return Ht(function(t, r) {
    var i = 0;
    t.subscribe(Bt(r, function(s) {
      return n.call(e, s, i++) && r.next(s);
    }));
  });
}
function oi(n) {
  return Ht(function(e, t) {
    var r = null, i = !1, s;
    r = e.subscribe(Bt(t, void 0, void 0, function(a) {
      s = Gr(n(a, oi(n)(e))), r ? (r.unsubscribe(), r = null, s.subscribe(t)) : i = !0;
    })), i && (r.unsubscribe(), r = null, s.subscribe(t));
  });
}
function zP(n, e, t, r, i) {
  return function(s, a) {
    var o = t, c = e, l = 0;
    s.subscribe(Bt(a, function(u) {
      var f = l++;
      c = o ? n(c, u, f) : (o = !0, u), r && a.next(c);
    }, i && function() {
      o && a.next(c), a.complete();
    }));
  };
}
function XP(n, e) {
  return Ht(zP(n, e, arguments.length >= 2, !1, !0));
}
var GP = function(n, e) {
  return n.push(e), n;
};
function ZP() {
  return Ht(function(n, e) {
    XP(GP, [])(n).subscribe(e);
  });
}
function JP(n) {
  return new Nt(function(e) {
    return n.subscribe(e);
  });
}
var KP = {
  connector: function() {
    return new wo();
  }
};
function YP(n, e) {
  e === void 0 && (e = KP);
  var t = e.connector;
  return Ht(function(r, i) {
    var s = t();
    Gr(n(JP(s))).subscribe(i), i.add(r.subscribe(s));
  });
}
function QP(n) {
  return Ht(function(e, t) {
    var r = !1;
    e.subscribe(Bt(t, function(i) {
      r = !0, t.next(i);
    }, function() {
      r || t.next(n), t.complete();
    }));
  });
}
function $P(n) {
  return n <= 0 ? function() {
    return R0;
  } : Ht(function(e, t) {
    var r = 0;
    e.subscribe(Bt(t, function(i) {
      ++r <= n && (t.next(i), n <= r && t.complete());
    }));
  });
}
function ek(n, e) {
  return e === void 0 && (e = ci), n = n ?? tk, Ht(function(t, r) {
    var i, s = !0;
    t.subscribe(Bt(r, function(a) {
      var o = e(a);
      (s || !n(i, o)) && (s = !1, i = o, r.next(a));
    }));
  });
}
function tk(n, e) {
  return n === e;
}
function nk(n) {
  return n === void 0 && (n = rk), Ht(function(e, t) {
    var r = !1;
    e.subscribe(Bt(t, function(i) {
      r = !0, t.next(i);
    }, function() {
      return r ? t.complete() : t.error(n());
    }));
  });
}
function rk() {
  return new nd();
}
function Th(n, e) {
  var t = arguments.length >= 2;
  return function(r) {
    return r.pipe(n ? qP(function(i, s) {
      return n(i, s, r);
    }) : ci, $P(1), t ? QP(e) : nk(function() {
      return new nd();
    }));
  };
}
function ik(n, e) {
  var t = Le(n) ? n : function() {
    return n;
  };
  return Le(e) ? YP(e, {
    connector: t
  }) : function(r) {
    return new rP(r, t);
  };
}
function X0(n, e, t, r) {
  t && !Le(t) && (r = t);
  var i = Le(t) ? t : void 0;
  return function(s) {
    return ik(new sP(n, e, r), i)(s);
  };
}
function sk() {
  for (var n = [], e = 0; e < arguments.length; e++)
    n[e] = arguments[e];
  var t = xo(n);
  return Ht(function(r, i) {
    (t ? kh(n, r, t) : kh(n, r)).subscribe(i);
  });
}
function Ce(n, e) {
  return Ht(function(t, r) {
    var i = null, s = 0, a = !1, o = function() {
      return a && !i && r.complete();
    };
    t.subscribe(Bt(r, function(c) {
      i == null || i.unsubscribe();
      var l = 0, u = s++;
      Gr(n(c, u)).subscribe(i = Bt(r, function(f) {
        return r.next(e ? e(c, f, u, l++) : f);
      }, function() {
        i = null, o();
      }));
    }, function() {
      a = !0, o();
    }));
  });
}
function Ps(n, e, t) {
  var r = Le(n) || e || t ? { next: n, error: e, complete: t } : n;
  return r ? Ht(function(i, s) {
    var a;
    (a = r.subscribe) === null || a === void 0 || a.call(r);
    var o = !0;
    i.subscribe(Bt(s, function(c) {
      var l;
      (l = r.next) === null || l === void 0 || l.call(r, c), s.next(c);
    }, function() {
      var c;
      o = !1, (c = r.complete) === null || c === void 0 || c.call(r), s.complete();
    }, function(c) {
      var l;
      o = !1, (l = r.error) === null || l === void 0 || l.call(r, c), s.error(c);
    }, function() {
      var c, l;
      o && ((c = r.unsubscribe) === null || c === void 0 || c.call(r)), (l = r.finalize) === null || l === void 0 || l.call(r);
    }));
  }) : ci;
}
const ak = {
  Blake2_128: null,
  Blake2_256: null,
  Blake2_128Concat: null,
  Twox128: null,
  Twox256: null,
  Twox64Concat: null,
  // new in v11
  Identity: null
}, Nh = {
  metadata: {
    description: "Returns the metadata of a runtime",
    params: [],
    type: "OpaqueMetadata"
  }
}, ok = {
  Metadata: [
    {
      methods: {
        metadata_at_version: {
          description: "Returns the metadata at a given version.",
          params: [
            {
              name: "version",
              type: "u32"
            }
          ],
          type: "Option<OpaqueMetadata>"
        },
        metadata_versions: {
          description: "Returns the supported metadata versions.",
          params: [],
          type: "Vec<u32>"
        },
        ...Nh
      },
      version: 2
    },
    {
      methods: {
        ...Nh
      },
      version: 1
    }
  ]
}, ck = {
  // v9
  ErrorMetadataV9: {
    name: "Text",
    docs: "Vec<Text>"
  },
  EventMetadataV9: {
    name: "Text",
    args: "Vec<Type>",
    docs: "Vec<Text>"
  },
  FunctionArgumentMetadataV9: {
    name: "Text",
    type: "Type"
  },
  FunctionMetadataV9: {
    name: "Text",
    args: "Vec<FunctionArgumentMetadataV9>",
    docs: "Vec<Text>"
  },
  MetadataV9: {
    modules: "Vec<ModuleMetadataV9>"
  },
  ModuleConstantMetadataV9: {
    name: "Text",
    type: "Type",
    value: "Bytes",
    docs: "Vec<Text>"
  },
  ModuleMetadataV9: {
    name: "Text",
    storage: "Option<StorageMetadataV9>",
    calls: "Option<Vec<FunctionMetadataV9>>",
    events: "Option<Vec<EventMetadataV9>>",
    constants: "Vec<ModuleConstantMetadataV9>",
    errors: "Vec<ErrorMetadataV9>"
  },
  StorageEntryMetadataV9: {
    name: "Text",
    modifier: "StorageEntryModifierV9",
    type: "StorageEntryTypeV9",
    fallback: "Bytes",
    docs: "Vec<Text>"
  },
  StorageEntryModifierV9: {
    _enum: ["Optional", "Default", "Required"]
  },
  StorageEntryTypeV9: {
    _enum: {
      Plain: "Type",
      Map: {
        hasher: "StorageHasherV9",
        key: "Type",
        value: "Type",
        linked: "bool"
      },
      DoubleMap: {
        hasher: "StorageHasherV9",
        key1: "Type",
        key2: "Type",
        value: "Type",
        key2Hasher: "StorageHasherV9"
      }
    }
  },
  StorageHasherV9: {
    _enum: {
      Blake2_128: null,
      Blake2_256: null,
      Twox128: null,
      Twox256: null,
      Twox64Concat: null
    }
  },
  StorageMetadataV9: {
    prefix: "Text",
    items: "Vec<StorageEntryMetadataV9>"
  }
}, lk = {
  // v10
  ErrorMetadataV10: "ErrorMetadataV9",
  EventMetadataV10: "EventMetadataV9",
  FunctionArgumentMetadataV10: "FunctionArgumentMetadataV9",
  FunctionMetadataV10: "FunctionMetadataV9",
  MetadataV10: {
    modules: "Vec<ModuleMetadataV10>"
  },
  ModuleConstantMetadataV10: "ModuleConstantMetadataV9",
  ModuleMetadataV10: {
    name: "Text",
    storage: "Option<StorageMetadataV10>",
    calls: "Option<Vec<FunctionMetadataV10>>",
    events: "Option<Vec<EventMetadataV10>>",
    constants: "Vec<ModuleConstantMetadataV10>",
    errors: "Vec<ErrorMetadataV10>"
  },
  StorageEntryModifierV10: "StorageEntryModifierV9",
  StorageEntryMetadataV10: {
    name: "Text",
    modifier: "StorageEntryModifierV10",
    type: "StorageEntryTypeV10",
    fallback: "Bytes",
    docs: "Vec<Text>"
  },
  StorageEntryTypeV10: {
    _enum: {
      Plain: "Type",
      Map: {
        hasher: "StorageHasherV10",
        key: "Type",
        value: "Type",
        linked: "bool"
      },
      DoubleMap: {
        hasher: "StorageHasherV10",
        key1: "Type",
        key2: "Type",
        value: "Type",
        key2Hasher: "StorageHasherV10"
      }
    }
  },
  StorageMetadataV10: {
    prefix: "Text",
    items: "Vec<StorageEntryMetadataV10>"
  },
  StorageHasherV10: {
    _enum: {
      Blake2_128: null,
      Blake2_256: null,
      Blake2_128Concat: null,
      Twox128: null,
      Twox256: null,
      Twox64Concat: null
    }
  }
}, uk = {
  // v11
  ErrorMetadataV11: "ErrorMetadataV10",
  EventMetadataV11: "EventMetadataV10",
  ExtrinsicMetadataV11: {
    version: "u8",
    signedExtensions: "Vec<Text>"
  },
  FunctionArgumentMetadataV11: "FunctionArgumentMetadataV10",
  FunctionMetadataV11: "FunctionMetadataV10",
  MetadataV11: {
    modules: "Vec<ModuleMetadataV11>",
    extrinsic: "ExtrinsicMetadataV11"
  },
  ModuleConstantMetadataV11: "ModuleConstantMetadataV10",
  ModuleMetadataV11: {
    name: "Text",
    storage: "Option<StorageMetadataV11>",
    calls: "Option<Vec<FunctionMetadataV11>>",
    events: "Option<Vec<EventMetadataV11>>",
    constants: "Vec<ModuleConstantMetadataV11>",
    errors: "Vec<ErrorMetadataV11>"
  },
  StorageEntryModifierV11: "StorageEntryModifierV10",
  StorageEntryMetadataV11: {
    name: "Text",
    modifier: "StorageEntryModifierV11",
    type: "StorageEntryTypeV11",
    fallback: "Bytes",
    docs: "Vec<Text>"
  },
  StorageEntryTypeV11: {
    _enum: {
      Plain: "Type",
      Map: {
        hasher: "StorageHasherV11",
        key: "Type",
        value: "Type",
        linked: "bool"
      },
      DoubleMap: {
        hasher: "StorageHasherV11",
        key1: "Type",
        key2: "Type",
        value: "Type",
        key2Hasher: "StorageHasherV11"
      }
    }
  },
  StorageMetadataV11: {
    prefix: "Text",
    items: "Vec<StorageEntryMetadataV11>"
  },
  StorageHasherV11: {
    _enum: ak
  }
}, dk = {
  // v12
  ErrorMetadataV12: "ErrorMetadataV11",
  EventMetadataV12: "EventMetadataV11",
  ExtrinsicMetadataV12: "ExtrinsicMetadataV11",
  FunctionArgumentMetadataV12: "FunctionArgumentMetadataV11",
  FunctionMetadataV12: "FunctionMetadataV11",
  MetadataV12: {
    modules: "Vec<ModuleMetadataV12>",
    extrinsic: "ExtrinsicMetadataV12"
  },
  ModuleConstantMetadataV12: "ModuleConstantMetadataV11",
  ModuleMetadataV12: {
    name: "Text",
    storage: "Option<StorageMetadataV12>",
    calls: "Option<Vec<FunctionMetadataV12>>",
    events: "Option<Vec<EventMetadataV12>>",
    constants: "Vec<ModuleConstantMetadataV12>",
    errors: "Vec<ErrorMetadataV12>",
    index: "u8"
  },
  StorageEntryModifierV12: "StorageEntryModifierV11",
  StorageEntryMetadataV12: "StorageEntryMetadataV11",
  StorageEntryTypeV12: "StorageEntryTypeV11",
  StorageMetadataV12: "StorageMetadataV11",
  StorageHasherV12: "StorageHasherV11"
}, fk = {
  // v13
  ErrorMetadataV13: "ErrorMetadataV12",
  EventMetadataV13: "EventMetadataV12",
  ExtrinsicMetadataV13: "ExtrinsicMetadataV12",
  FunctionArgumentMetadataV13: "FunctionArgumentMetadataV12",
  FunctionMetadataV13: "FunctionMetadataV12",
  MetadataV13: {
    modules: "Vec<ModuleMetadataV13>",
    extrinsic: "ExtrinsicMetadataV13"
  },
  ModuleConstantMetadataV13: "ModuleConstantMetadataV12",
  ModuleMetadataV13: {
    name: "Text",
    storage: "Option<StorageMetadataV13>",
    calls: "Option<Vec<FunctionMetadataV13>>",
    events: "Option<Vec<EventMetadataV13>>",
    constants: "Vec<ModuleConstantMetadataV13>",
    errors: "Vec<ErrorMetadataV13>",
    index: "u8"
  },
  StorageEntryModifierV13: "StorageEntryModifierV12",
  StorageEntryMetadataV13: {
    name: "Text",
    modifier: "StorageEntryModifierV13",
    type: "StorageEntryTypeV13",
    fallback: "Bytes",
    docs: "Vec<Text>"
  },
  StorageEntryTypeV13: {
    _enum: {
      Plain: "Type",
      Map: {
        hasher: "StorageHasherV13",
        key: "Type",
        value: "Type",
        linked: "bool"
      },
      DoubleMap: {
        hasher: "StorageHasherV13",
        key1: "Type",
        key2: "Type",
        value: "Type",
        key2Hasher: "StorageHasherV13"
      },
      NMap: {
        keyVec: "Vec<Type>",
        hashers: "Vec<StorageHasherV13>",
        value: "Type"
      }
    }
  },
  StorageMetadataV13: {
    prefix: "Text",
    items: "Vec<StorageEntryMetadataV13>"
  },
  StorageHasherV13: "StorageHasherV12"
}, Ea = {
  name: "Text",
  fields: "Vec<Si1Field>",
  index: "u8",
  docs: "Vec<Text>"
}, hk = {
  Si1Field: {
    name: "Option<Text>",
    type: "Si1LookupTypeId",
    typeName: "Option<Text>",
    docs: "Vec<Text>"
  },
  Si1LookupTypeId: "Compact<u32>",
  Si1Path: "Si0Path",
  Si1Type: {
    path: "Si1Path",
    params: "Vec<Si1TypeParameter>",
    def: "Si1TypeDef",
    docs: "Vec<Text>"
  },
  Si1TypeDef: {
    _enum: {
      Composite: "Si1TypeDefComposite",
      Variant: "Si1TypeDefVariant",
      Sequence: "Si1TypeDefSequence",
      Array: "Si1TypeDefArray",
      Tuple: "Si1TypeDefTuple",
      Primitive: "Si1TypeDefPrimitive",
      Compact: "Si1TypeDefCompact",
      BitSequence: "Si1TypeDefBitSequence",
      // NOTE: This is specific to the implementation for pre-v14 metadata
      // compatibility (always keep this as the last entry in the enum)
      HistoricMetaCompat: "Type"
    }
  },
  Si1TypeDefArray: {
    len: "u32",
    type: "Si1LookupTypeId"
  },
  Si1TypeDefBitSequence: {
    bitStoreType: "Si1LookupTypeId",
    bitOrderType: "Si1LookupTypeId"
  },
  Si1TypeDefCompact: {
    type: "Si1LookupTypeId"
  },
  Si1TypeDefComposite: {
    fields: "Vec<Si1Field>"
  },
  Si1TypeDefPrimitive: "Si0TypeDefPrimitive",
  Si1TypeDefSequence: {
    type: "Si1LookupTypeId"
  },
  Si1TypeDefTuple: "Vec<Si1LookupTypeId>",
  Si1TypeParameter: {
    name: "Text",
    type: "Option<Si1LookupTypeId>"
  },
  Si1TypeDefVariant: {
    variants: "Vec<Si1Variant>"
  },
  Si1Variant: Ea
}, pk = {
  // registry
  PortableTypeV14: {
    id: "Si1LookupTypeId",
    type: "Si1Type"
  },
  // compatibility with earlier layouts, i.e. don't break previous users
  ErrorMetadataV14: {
    ...Ea,
    args: "Vec<Type>"
  },
  EventMetadataV14: {
    ...Ea,
    args: "Vec<Type>"
  },
  FunctionArgumentMetadataV14: {
    name: "Text",
    type: "Type",
    typeName: "Option<Type>"
  },
  FunctionMetadataV14: {
    ...Ea,
    args: "Vec<FunctionArgumentMetadataV14>"
  },
  // V14
  ExtrinsicMetadataV14: {
    type: "SiLookupTypeId",
    version: "u8",
    signedExtensions: "Vec<SignedExtensionMetadataV14>"
  },
  MetadataV14: {
    lookup: "PortableRegistry",
    pallets: "Vec<PalletMetadataV14>",
    extrinsic: "ExtrinsicMetadataV14",
    type: "SiLookupTypeId"
  },
  PalletCallMetadataV14: {
    type: "SiLookupTypeId"
  },
  PalletConstantMetadataV14: {
    name: "Text",
    type: "SiLookupTypeId",
    value: "Bytes",
    docs: "Vec<Text>"
  },
  PalletErrorMetadataV14: {
    type: "SiLookupTypeId"
  },
  PalletEventMetadataV14: {
    type: "SiLookupTypeId"
  },
  PalletMetadataV14: {
    name: "Text",
    storage: "Option<PalletStorageMetadataV14>",
    calls: "Option<PalletCallMetadataV14>",
    events: "Option<PalletEventMetadataV14>",
    constants: "Vec<PalletConstantMetadataV14>",
    errors: "Option<PalletErrorMetadataV14>",
    index: "u8"
  },
  PalletStorageMetadataV14: {
    prefix: "Text",
    // NOTE: Renamed from entries
    items: "Vec<StorageEntryMetadataV14>"
  },
  SignedExtensionMetadataV14: {
    identifier: "Text",
    type: "SiLookupTypeId",
    additionalSigned: "SiLookupTypeId"
  },
  StorageEntryMetadataV14: {
    name: "Text",
    modifier: "StorageEntryModifierV14",
    type: "StorageEntryTypeV14",
    fallback: "Bytes",
    docs: "Vec<Text>"
  },
  StorageEntryModifierV14: "StorageEntryModifierV13",
  StorageEntryTypeV14: {
    _enum: {
      Plain: "SiLookupTypeId",
      Map: {
        hashers: "Vec<StorageHasherV14>",
        key: "SiLookupTypeId",
        value: "SiLookupTypeId"
      }
    }
  },
  StorageHasherV14: "StorageHasherV13"
}, mk = {
  // new/adjusted in v15
  CustomMetadata15: {
    map: "BTreeMap<Text, CustomValueMetadata15>"
  },
  CustomValueMetadata15: {
    type: "SiLookupTypeId",
    value: "Bytes"
  },
  ExtrinsicMetadataV15: {
    version: "u8",
    addressType: "SiLookupTypeId",
    callType: "SiLookupTypeId",
    signatureType: "SiLookupTypeId",
    extraType: "SiLookupTypeId",
    signedExtensions: "Vec<SignedExtensionMetadataV14>"
  },
  OuterEnums15: {
    callType: "SiLookupTypeId",
    eventType: "SiLookupTypeId",
    errorType: "SiLookupTypeId"
  },
  PalletMetadataV15: {
    name: "Text",
    storage: "Option<PalletStorageMetadataV14>",
    calls: "Option<PalletCallMetadataV14>",
    events: "Option<PalletEventMetadataV14>",
    constants: "Vec<PalletConstantMetadataV14>",
    errors: "Option<PalletErrorMetadataV14>",
    index: "u8",
    docs: "Vec<Text>"
  },
  RuntimeApiMetadataV15: {
    name: "Text",
    methods: "Vec<RuntimeApiMethodMetadataV15>",
    docs: "Vec<Text>"
  },
  RuntimeApiMethodMetadataV15: {
    name: "Text",
    inputs: "Vec<RuntimeApiMethodParamMetadataV15>",
    output: "SiLookupTypeId",
    docs: "Vec<Text>"
  },
  RuntimeApiMethodParamMetadataV15: {
    name: "Text",
    type: "SiLookupTypeId"
  },
  // actual v15 definition
  MetadataV15: {
    lookup: "PortableRegistry",
    pallets: "Vec<PalletMetadataV15>",
    extrinsic: "ExtrinsicMetadataV15",
    type: "SiLookupTypeId",
    apis: "Vec<RuntimeApiMetadataV15>",
    outerEnums: "OuterEnums15",
    custom: "CustomMetadata15"
  }
}, gk = {
  rpc: {},
  runtime: ok,
  types: {
    // all known
    ...ck,
    ...lk,
    ...uk,
    ...dk,
    ...fk,
    ...pk,
    ...mk,
    // latest mappings
    // NOTE: For v15, we only added the runtime defintions,
    // hence latest for most pointing to the previous V14
    ErrorMetadataLatest: "ErrorMetadataV14",
    EventMetadataLatest: "EventMetadataV14",
    ExtrinsicMetadataLatest: "ExtrinsicMetadataV15",
    FunctionArgumentMetadataLatest: "FunctionArgumentMetadataV14",
    FunctionMetadataLatest: "FunctionMetadataV14",
    MetadataLatest: "MetadataV15",
    PalletCallMetadataLatest: "PalletCallMetadataV14",
    PalletConstantMetadataLatest: "PalletConstantMetadataV14",
    PalletErrorMetadataLatest: "PalletErrorMetadataV14",
    PalletEventMetadataLatest: "PalletEventMetadataV14",
    PalletMetadataLatest: "PalletMetadataV15",
    PalletStorageMetadataLatest: "PalletStorageMetadataV14",
    PortableType: "PortableTypeV14",
    RuntimeApiMetadataLatest: "RuntimeApiMetadataV15",
    SignedExtensionMetadataLatest: "SignedExtensionMetadataV14",
    StorageEntryMetadataLatest: "StorageEntryMetadataV14",
    StorageEntryModifierLatest: "StorageEntryModifierV14",
    StorageEntryTypeLatest: "StorageEntryTypeV14",
    StorageHasher: "StorageHasherV14",
    // additional types
    OpaqueMetadata: "Opaque<Bytes>",
    // the enum containing all the mappings
    MetadataAll: {
      _enum: {
        V0: "DoNotConstruct<MetadataV0>",
        V1: "DoNotConstruct<MetadataV1>",
        V2: "DoNotConstruct<MetadataV2>",
        V3: "DoNotConstruct<MetadataV3>",
        V4: "DoNotConstruct<MetadataV4>",
        V5: "DoNotConstruct<MetadataV5>",
        V6: "DoNotConstruct<MetadataV6>",
        V7: "DoNotConstruct<MetadataV7>",
        V8: "DoNotConstruct<MetadataV8>",
        // First version on Kusama in V9, dropping will be problematic
        V9: "MetadataV9",
        V10: "MetadataV10",
        V11: "MetadataV11",
        V12: "MetadataV12",
        V13: "MetadataV13",
        V14: "MetadataV14",
        V15: "MetadataV15"
      }
    }
  }
}, sa = {
  execute_block: {
    description: "Execute the given block.",
    params: [
      {
        name: "block",
        type: "Block"
      }
    ],
    type: "Null"
  }
}, Rh = {
  version: {
    description: "Returns the version of the runtime.",
    params: [],
    type: "RuntimeVersionPre3"
  }
}, kc = {
  initialize_block: {
    description: "Initialize a block with the given header.",
    params: [
      {
        name: "header",
        type: "Header"
      }
    ],
    type: "Null"
  }
}, yk = {
  Core: [
    {
      methods: {
        version: {
          description: "Returns the version of the runtime.",
          params: [],
          type: "RuntimeVersion"
        },
        ...sa,
        ...kc
      },
      version: 4
    },
    {
      methods: {
        version: {
          description: "Returns the version of the runtime.",
          params: [],
          type: "RuntimeVersionPre4"
        },
        ...sa,
        ...kc
      },
      version: 3
    },
    {
      methods: {
        ...Rh,
        ...sa,
        ...kc
      },
      version: 2
    },
    {
      methods: {
        initialise_block: {
          description: "Initialize a block with the given header.",
          params: [
            {
              name: "header",
              type: "Header"
            }
          ],
          type: "Null"
        },
        ...Rh,
        ...sa
      },
      version: 1
    }
  ]
}, _k = {
  Fixed64: "Int<64, Fixed64>",
  FixedI64: "Int<64, FixedI64>",
  FixedU64: "UInt<64, FixedU64>",
  Fixed128: "Int<128, Fixed128>",
  FixedI128: "Int<128, FixedI128>",
  FixedU128: "UInt<128, FixedU128>",
  I32F32: "Int<64, I32F32>",
  U32F32: "UInt<64, U32F32>",
  PerU16: "UInt<16, PerU16>",
  Perbill: "UInt<32, Perbill>",
  Percent: "UInt<8, Percent>",
  Permill: "UInt<32, Permill>",
  Perquintill: "UInt<64, Perquintill>"
}, vk = {
  //
  // (1) Defaults from Substrate
  //
  Council: "CollectiveOrigin",
  System: "SystemOrigin",
  TechnicalCommittee: "CollectiveOrigin",
  //
  // (2) Defaults from Polkadot
  //
  Xcm: "XcmOrigin",
  XcmPallet: "XcmOrigin",
  //
  // (3) Defaults from Acala
  //
  Authority: "AuthorityOrigin",
  GeneralCouncil: "CollectiveOrigin"
}, bk = {
  rpc: {},
  runtime: yk,
  types: {
    ..._k,
    AccountId: "AccountId32",
    AccountId20: "GenericEthereumAccountId",
    AccountId32: "GenericAccountId32",
    AccountId33: "GenericAccountId33",
    AccountIdOf: "AccountId",
    AccountIndex: "GenericAccountIndex",
    Address: "MultiAddress",
    AssetId: "u32",
    Balance: "UInt<128, Balance>",
    BalanceOf: "Balance",
    Block: "GenericBlock",
    BlockNumber: "u32",
    BlockNumberFor: "BlockNumber",
    BlockNumberOf: "BlockNumber",
    Call: "GenericCall",
    CallHash: "Hash",
    CallHashOf: "CallHash",
    ChangesTrieConfiguration: {
      digestInterval: "u32",
      digestLevels: "u32"
    },
    ChangesTrieSignal: {
      _enum: {
        NewConfiguration: "Option<ChangesTrieConfiguration>"
      }
    },
    ConsensusEngineId: "GenericConsensusEngineId",
    CodecHash: "Hash",
    CrateVersion: {
      major: "u16",
      minor: "u8",
      patch: "u8"
    },
    Digest: {
      logs: "Vec<DigestItem>"
    },
    DigestItem: {
      _enum: {
        Other: "Bytes",
        AuthoritiesChange: "Vec<AuthorityId>",
        ChangesTrieRoot: "Hash",
        SealV0: "SealV0",
        Consensus: "Consensus",
        Seal: "Seal",
        PreRuntime: "PreRuntime",
        ChangesTrieSignal: "ChangesTrieSignal",
        RuntimeEnvironmentUpdated: "Null"
        // 8
      }
    },
    ExtrinsicsWeight: {
      normal: "Weight",
      operational: "Weight"
    },
    H32: "[u8; 4; H32]",
    H64: "[u8; 8; H64]",
    H128: "[u8; 16; H128]",
    H160: "[u8; 20; H160]",
    H256: "[u8; 32; H256]",
    H512: "[u8; 64; H512]",
    H1024: "[u8; 128; H1024]",
    H2048: "[u8; 256; H2048]",
    Hash: "H256",
    Header: {
      parentHash: "Hash",
      number: "Compact<BlockNumber>",
      stateRoot: "Hash",
      extrinsicsRoot: "Hash",
      digest: "Digest"
    },
    HeaderPartial: {
      parentHash: "Hash",
      // since we only parse JSON with this, having non-compact works
      number: "BlockNumber"
    },
    IndicesLookupSource: "GenericLookupSource",
    Index: "u32",
    Justification: "(ConsensusEngineId, EncodedJustification)",
    EncodedJustification: "Bytes",
    Justifications: "Vec<Justification>",
    KeyValue: "(StorageKey, StorageData)",
    KeyTypeId: "u32",
    LockIdentifier: "[u8; 8]",
    LookupSource: "MultiAddress",
    LookupTarget: "AccountId",
    ModuleId: "LockIdentifier",
    MultiAddress: "GenericMultiAddress",
    MultiSigner: {
      _enum: {
        Ed25519: "[u8; 32]",
        Sr25519: "[u8; 32]",
        Ecdsa: "[u8; 33]"
      }
    },
    Moment: "UInt<64, Moment>",
    OpaqueCall: "Bytes",
    Origin: "DoNotConstruct<Origin>",
    OriginCaller: {
      _enum: {
        // this should be dynamically built from the actual modules, based on index
        System: "SystemOrigin"
      }
    },
    PalletId: "LockIdentifier",
    PalletsOrigin: "OriginCaller",
    PalletVersion: {
      major: "u16",
      minor: "u8",
      patch: "u8"
    },
    Pays: {
      _enum: ["Yes", "No"]
    },
    Phantom: "Null",
    PhantomData: "Null",
    Releases: {
      _enum: ["V1", "V2", "V3", "V4", "V5", "V6", "V7", "V8", "V9", "V10"]
    },
    RuntimeCall: "Call",
    RuntimeEvent: "Event",
    RuntimeDbWeight: {
      read: "Weight",
      write: "Weight"
    },
    SignedBlock: "SignedBlockWithJustifications",
    SignedBlockWithJustification: {
      block: "Block",
      justification: "Option<EncodedJustification>"
    },
    SignedBlockWithJustifications: {
      block: "Block",
      justifications: "Option<Justifications>"
    },
    Slot: "u64",
    SlotDuration: "u64",
    StorageData: "Bytes",
    StorageInfo: {
      palletName: "Bytes",
      storage_name: "Bytes",
      prefix: "Bytes",
      maxValues: "Option<u32>",
      maxSize: "Option<u32>"
    },
    StorageProof: {
      trieNodes: "Vec<Bytes>"
    },
    TransactionPriority: "u64",
    TransactionLongevity: "u64",
    TransactionTag: "Bytes",
    TransactionInfo: {
      _alias: {
        dataSize: "size"
      },
      chunkRoot: "H256",
      contentHash: "H256",
      dataSize: "u32",
      blockChunks: "u32"
    },
    TransactionStorageProof: {
      chunk: "Vec<u8>",
      proof: "Vec<Vec<u8>>"
    },
    ValidatorId: "AccountId",
    ValidatorIdOf: "ValidatorId",
    WeightV0: "u32",
    WeightV1: "u64",
    WeightV2: {
      refTime: "Compact<u64>",
      proofSize: "Compact<u64>"
    },
    Weight: "WeightV2",
    WeightMultiplier: "Fixed64",
    // digest
    PreRuntime: "(ConsensusEngineId, Bytes)",
    SealV0: "(u64, Signature)",
    Seal: "(ConsensusEngineId, Bytes)",
    Consensus: "(ConsensusEngineId, Bytes)"
  }
}, wk = {
  Si0Field: {
    name: "Option<Text>",
    type: "Si0LookupTypeId",
    typeName: "Option<Text>",
    docs: "Vec<Text>"
  },
  Si0LookupTypeId: "u32",
  Si0Path: "Vec<Text>",
  Si0Type: {
    path: "Si0Path",
    params: "Vec<Si0LookupTypeId>",
    def: "Si0TypeDef"
  },
  Si0TypeDef: {
    _enum: {
      Composite: "Si0TypeDefComposite",
      Variant: "Si0TypeDefVariant",
      Sequence: "Si0TypeDefSequence",
      Array: "Si0TypeDefArray",
      Tuple: "Si0TypeDefTuple",
      Primitive: "Si0TypeDefPrimitive",
      Compact: "Si0TypeDefCompact",
      Phantom: "Si0TypeDefPhantom",
      BitSequence: "Si0TypeDefBitSequence"
    }
  },
  Si0TypeDefArray: {
    len: "u32",
    type: "Si0LookupTypeId"
  },
  Si0TypeDefBitSequence: {
    bitStoreType: "Si0LookupTypeId",
    bitOrderType: "Si0LookupTypeId"
  },
  Si0TypeDefCompact: {
    type: "Si0LookupTypeId"
  },
  Si0TypeDefComposite: {
    fields: "Vec<Si0Field>"
  },
  Si0TypeDefPhantom: "Null",
  Si0TypeDefVariant: {
    variants: "Vec<Si0Variant>"
  },
  Si0TypeDefPrimitive: {
    _enum: ["Bool", "Char", "Str", "U8", "U16", "U32", "U64", "U128", "U256", "I8", "I16", "I32", "I64", "I128", "I256"]
  },
  Si0TypeDefSequence: {
    type: "Si0LookupTypeId"
  },
  Si0TypeDefTuple: "Vec<Si0LookupTypeId>",
  Si0TypeParameter: {
    name: "Text",
    type: "Option<Si0LookupTypeId>"
  },
  Si0Variant: {
    name: "Text",
    fields: "Vec<Si0Field>",
    index: "Option<u8>",
    discriminant: "Option<u64>",
    docs: "Vec<Text>"
  }
}, xk = {
  rpc: {},
  types: {
    ...wk,
    ...hk,
    // latest mappings
    SiField: "Si1Field",
    SiLookupTypeId: "Si1LookupTypeId",
    SiPath: "Si1Path",
    SiType: "Si1Type",
    SiTypeDef: "Si1TypeDef",
    SiTypeDefArray: "Si1TypeDefArray",
    SiTypeDefBitSequence: "Si1TypeDefBitSequence",
    SiTypeDefCompact: "Si1TypeDefCompact",
    SiTypeDefComposite: "Si1TypeDefComposite",
    SiTypeDefPrimitive: "Si1TypeDefPrimitive",
    SiTypeDefSequence: "Si1TypeDefSequence",
    SiTypeDefTuple: "Si1TypeDefTuple",
    SiTypeParameter: "Si1TypeParameter",
    SiTypeDefVariant: "Si1TypeDefVariant",
    SiVariant: "Si1Variant"
  }
}, ne = { types: {} }, Sk = {
  rpc: {},
  types: {
    AccountData: {
      free: "Balance",
      reserved: "Balance",
      miscFrozen: "Balance",
      feeFrozen: "Balance"
    },
    BalanceLockTo212: {
      id: "LockIdentifier",
      amount: "Balance",
      until: "BlockNumber",
      reasons: "WithdrawReasons"
    },
    BalanceLock: {
      id: "LockIdentifier",
      amount: "Balance",
      reasons: "Reasons"
    },
    BalanceStatus: {
      _enum: ["Free", "Reserved"]
    },
    Reasons: {
      _enum: ["Fee", "Misc", "All"]
    },
    ReserveData: {
      id: "ReserveIdentifier",
      amount: "Balance"
    },
    ReserveIdentifier: "[u8; 8]",
    VestingSchedule: {
      offset: "Balance",
      perBlock: "Balance",
      startingBlock: "BlockNumber"
    },
    WithdrawReasons: {
      _set: {
        TransactionPayment: 1,
        Transfer: 2,
        Reserve: 4,
        Fee: 8,
        Tip: 16
      }
    }
  }
}, Ek = {
  call: {
    deprecated: "Use the runtime interface `api.call.contractsApi.call` instead",
    description: "Executes a call to a contract",
    params: [
      {
        name: "callRequest",
        type: "ContractCallRequest"
      },
      {
        isHistoric: !0,
        isOptional: !0,
        name: "at",
        type: "BlockHash"
      }
    ],
    type: "ContractExecResult"
  },
  getStorage: {
    deprecated: "Use the runtime interface `api.call.contractsApi.getStorage` instead",
    description: "Returns the value under a specified storage key in a contract",
    params: [
      {
        name: "address",
        type: "AccountId"
      },
      {
        name: "key",
        type: "H256"
      },
      {
        isHistoric: !0,
        isOptional: !0,
        name: "at",
        type: "BlockHash"
      }
    ],
    type: "Option<Bytes>"
  },
  instantiate: {
    deprecated: "Use the runtime interface `api.call.contractsApi.instantiate` instead",
    description: "Instantiate a new contract",
    params: [
      {
        name: "request",
        type: "InstantiateRequestV1"
      },
      {
        isHistoric: !0,
        isOptional: !0,
        name: "at",
        type: "BlockHash"
      }
    ],
    type: "ContractInstantiateResult"
  },
  rentProjection: {
    deprecated: "Not available in newer versions of the contracts interfaces",
    description: "Returns the projected time a given contract will be able to sustain paying its rent",
    params: [
      {
        name: "address",
        type: "AccountId"
      },
      {
        isHistoric: !0,
        isOptional: !0,
        name: "at",
        type: "BlockHash"
      }
    ],
    type: "Option<BlockNumber>"
  },
  uploadCode: {
    deprecated: "Use the runtime interface `api.call.contractsApi.uploadCode` instead",
    description: "Upload new code without instantiating a contract from it",
    // The RPC here is terribly misnamed - somebody forgot how the RPCs
    // are actually done, ie. <module>_<camelCasedMethod>
    endpoint: "contracts_upload_code",
    params: [
      {
        name: "uploadRequest",
        type: "CodeUploadRequest"
      },
      {
        isHistoric: !0,
        isOptional: !0,
        name: "at",
        type: "BlockHash"
      }
    ],
    type: "CodeUploadResult"
  }
}, Ih = {
  get_storage: {
    description: "Query a given storage key in a given contract.",
    params: [
      {
        name: "address",
        type: "AccountId"
      },
      {
        name: "key",
        type: "Bytes"
      }
    ],
    type: "Option<Bytes>"
  },
  upload_code: {
    description: "Upload new code without instantiating a contract from it.",
    params: [
      {
        name: "origin",
        type: "AccountId"
      },
      {
        name: "code",
        type: "Bytes"
      },
      {
        name: "storageDepositLimit",
        type: "Option<Balance>"
      }
    ],
    type: "CodeUploadResult"
  }
}, Ck = {
  ContractsApi: [
    {
      methods: {
        call: {
          description: "Perform a call from a specified account to a given contract.",
          params: [
            {
              name: "origin",
              type: "AccountId"
            },
            {
              name: "dest",
              type: "AccountId"
            },
            {
              name: "value",
              type: "Balance"
            },
            {
              name: "gasLimit",
              type: "Option<WeightV2>"
            },
            {
              name: "storageDepositLimit",
              type: "Option<Balance>"
            },
            {
              name: "inputData",
              type: "Vec<u8>"
            }
          ],
          type: "ContractExecResult"
        },
        instantiate: {
          description: "Instantiate a new contract.",
          params: [
            {
              name: "origin",
              type: "AccountId"
            },
            {
              name: "value",
              type: "Balance"
            },
            {
              name: "gasLimit",
              type: "Option<WeightV2>"
            },
            {
              name: "storageDepositLimit",
              type: "Option<Balance>"
            },
            {
              name: "code",
              type: "CodeSource"
            },
            {
              name: "data",
              type: "Bytes"
            },
            {
              name: "salt",
              type: "Bytes"
            }
          ],
          type: "ContractInstantiateResult"
        },
        ...Ih
      },
      version: 2
    },
    {
      methods: {
        call: {
          description: "Perform a call from a specified account to a given contract.",
          params: [
            {
              name: "origin",
              type: "AccountId"
            },
            {
              name: "dest",
              type: "AccountId"
            },
            {
              name: "value",
              type: "Balance"
            },
            {
              name: "gasLimit",
              type: "u64"
            },
            {
              name: "storageDepositLimit",
              type: "Option<Balance>"
            },
            {
              name: "inputData",
              type: "Vec<u8>"
            }
          ],
          type: "ContractExecResultU64"
        },
        instantiate: {
          description: "Instantiate a new contract.",
          params: [
            {
              name: "origin",
              type: "AccountId"
            },
            {
              name: "value",
              type: "Balance"
            },
            {
              name: "gasLimit",
              type: "u64"
            },
            {
              name: "storageDepositLimit",
              type: "Option<Balance>"
            },
            {
              name: "code",
              type: "CodeSource"
            },
            {
              name: "data",
              type: "Bytes"
            },
            {
              name: "salt",
              type: "Bytes"
            }
          ],
          type: "ContractInstantiateResultU64"
        },
        ...Ih
      },
      version: 1
    }
  ]
}, Ak = {
  rpc: Ek,
  runtime: Ck,
  types: {
    AliveContractInfo: {
      trieId: "TrieId",
      storageSize: "u32",
      pairCount: "u32",
      codeHash: "CodeHash",
      rentAllowance: "Balance",
      rentPaid: "Balance",
      deductBlock: "BlockNumber",
      lastWrite: "Option<BlockNumber>",
      _reserved: "Option<Null>"
    },
    CodeHash: "Hash",
    CodeSource: {
      _enum: {
        Upload: "Bytes",
        Existing: "Hash"
      }
    },
    CodeUploadRequest: {
      origin: "AccountId",
      code: "Bytes",
      storageDepositLimit: "Option<Balance>"
    },
    CodeUploadResult: "Result<CodeUploadResultValue, DispatchError>",
    CodeUploadResultValue: {
      codeHash: "CodeHash",
      deposit: "Balance"
    },
    ContractCallRequest: {
      origin: "AccountId",
      dest: "AccountId",
      value: "Balance",
      gasLimit: "u64",
      storageDepositLimit: "Option<Balance>",
      inputData: "Bytes"
    },
    ContractExecResultSuccessTo255: {
      status: "u8",
      data: "Raw"
    },
    ContractExecResultTo255: {
      _enum: {
        Success: "ContractExecResultSuccessTo255",
        Error: "Null"
      }
    },
    ContractExecResultSuccessTo260: {
      flags: "ContractReturnFlags",
      data: "Bytes",
      gasConsumed: "u64"
    },
    ContractExecResultTo260: {
      _enum: {
        Success: "ContractExecResultSuccessTo260",
        Error: "Null"
      }
    },
    ContractExecResultOk: {
      flags: "ContractReturnFlags",
      data: "Bytes"
    },
    ContractExecResultResult: "Result<ContractExecResultOk, DispatchError>",
    ContractExecResultTo267: {
      gasConsumed: "u64",
      debugMessage: "Text",
      result: "ContractExecResultResult"
    },
    ContractExecResult: {
      gasConsumed: "Weight",
      gasRequired: "Weight",
      storageDeposit: "StorageDeposit",
      debugMessage: "Text",
      result: "ContractExecResultResult"
    },
    ContractExecResultU64: {
      gasConsumed: "u64",
      gasRequired: "u64",
      storageDeposit: "StorageDeposit",
      debugMessage: "Text",
      result: "ContractExecResultResult"
    },
    ContractInfo: {
      _enum: {
        Alive: "AliveContractInfo",
        Tombstone: "TombstoneContractInfo"
      }
    },
    ContractCallFlags: {
      _set: {
        _bitLength: 32,
        ForwardInput: 1,
        CloneInput: 2,
        TailCall: 4,
        AllowReentry: 8
      }
    },
    ContractReturnFlags: {
      _set: {
        _bitLength: 32,
        Revert: 1
      }
    },
    ContractStorageKey: "[u8; 32]",
    DeletedContract: {
      pairCount: "u32",
      trieId: "TrieId"
    },
    ExecReturnValue: {
      flags: "ContractReturnFlags",
      data: "Bytes"
    },
    Gas: "u64",
    HostFnWeightsTo264: {
      caller: "Weight",
      address: "Weight",
      gasLeft: "Weight",
      balance: "Weight",
      valueTransferred: "Weight",
      minimumBalance: "Weight",
      tombstoneDeposit: "Weight",
      rentAllowance: "Weight",
      blockNumber: "Weight",
      now: "Weight",
      weightToFee: "Weight",
      gas: "Weight",
      input: "Weight",
      inputPerByte: "Weight",
      return: "Weight",
      returnPerByte: "Weight",
      terminate: "Weight",
      restoreTo: "Weight",
      restoreToPerDelta: "Weight",
      random: "Weight",
      depositEvent: "Weight",
      depositEventPerTopic: "Weight",
      depositEventPerByte: "Weight",
      setRentAllowance: "Weight",
      setStorage: "Weight",
      setStoragePerByte: "Weight",
      clearStorage: "Weight",
      getStorage: "Weight",
      getStoragePerByte: "Weight",
      transfer: "Weight",
      call: "Weight",
      callTransferSurcharge: "Weight",
      callPerInputByte: "Weight",
      callPerOutputByte: "Weight",
      instantiate: "Weight",
      instantiatePerInputByte: "Weight",
      instantiatePerOutputByte: "Weight",
      hashSha2256: "Weight",
      hashSha2256PerByte: "Weight",
      hashKeccak256: "Weight",
      hashKeccak256PerByte: "Weight",
      hashBlake2256: "Weight",
      hashBlake2256PerByte: "Weight",
      hashBlake2128: "Weight",
      hashBlake2128PerByte: "Weight"
    },
    HostFnWeights: {
      caller: "Weight",
      address: "Weight",
      gasLeft: "Weight",
      balance: "Weight",
      valueTransferred: "Weight",
      minimumBalance: "Weight",
      tombstoneDeposit: "Weight",
      rentAllowance: "Weight",
      blockNumber: "Weight",
      now: "Weight",
      weightToFee: "Weight",
      gas: "Weight",
      input: "Weight",
      inputPerByte: "Weight",
      return: "Weight",
      returnPerByte: "Weight",
      terminate: "Weight",
      terminatePerCodeByte: "Weight",
      restoreTo: "Weight",
      restoreToPerCallerCodeByte: "Weight",
      restoreToPerTombstoneCodeByte: "Weight",
      restoreToPerDelta: "Weight",
      random: "Weight",
      depositEvent: "Weight",
      depositEventPerTopic: "Weight",
      depositEventPerByte: "Weight",
      setRentAllowance: "Weight",
      setStorage: "Weight",
      setStoragePerByte: "Weight",
      clearStorage: "Weight",
      getStorage: "Weight",
      getStoragePerByte: "Weight",
      transfer: "Weight",
      call: "Weight",
      callPerCodeByte: "Weight",
      callTransferSurcharge: "Weight",
      callPerInputByte: "Weight",
      callPerOutputByte: "Weight",
      instantiate: "Weight",
      instantiatePerCodeByte: "Weight",
      instantiatePerInputByte: "Weight",
      instantiatePerOutputByte: "Weight",
      instantiatePerSaltByte: "Weight",
      hashSha2256: "Weight",
      hashSha2256PerByte: "Weight",
      hashKeccak256: "Weight",
      hashKeccak256PerByte: "Weight",
      hashBlake2256: "Weight",
      hashBlake2256PerByte: "Weight",
      hashBlake2128: "Weight",
      hashBlake2128PerByte: "Weight",
      rentParams: "Weight"
    },
    InstantiateRequestV1: {
      origin: "AccountId",
      value: "Balance",
      gasLimit: "Gas",
      code: "Bytes",
      data: "Bytes",
      salt: "Bytes"
    },
    InstantiateRequestV2: {
      _fallback: "InstantiateRequestV1",
      origin: "AccountId",
      value: "Balance",
      gasLimit: "Gas",
      storageDepositLimit: "Option<Balance>",
      code: "Bytes",
      data: "Bytes",
      salt: "Bytes"
    },
    InstantiateRequest: {
      _fallback: "InstantiateRequestV2",
      origin: "AccountId",
      value: "Balance",
      gasLimit: "Gas",
      storageDepositLimit: "Option<Balance>",
      code: "CodeSource",
      data: "Bytes",
      salt: "Bytes"
    },
    ContractInstantiateResultTo267: "Result<InstantiateReturnValueTo267, Null>",
    ContractInstantiateResultTo299: "Result<InstantiateReturnValueOk, Null>",
    ContractInstantiateResult: {
      gasConsumed: "WeightV2",
      gasRequired: "WeightV2",
      storageDeposit: "StorageDeposit",
      debugMessage: "Text",
      result: "InstantiateReturnValue"
    },
    ContractInstantiateResultU64: {
      // only this one can fail, the current version (above) _should_ be correctly
      // versioned now, aka no more deprecated RPCs involved, only runtime calls
      _fallback: "ContractInstantiateResultTo299",
      gasConsumed: "u64",
      gasRequired: "u64",
      storageDeposit: "StorageDeposit",
      debugMessage: "Text",
      result: "InstantiateReturnValue"
    },
    InstantiateReturnValueTo267: {
      result: "ExecReturnValue",
      accountId: "AccountId",
      rentProjection: "Option<RentProjection>"
    },
    InstantiateReturnValueOk: {
      result: "ExecReturnValue",
      accountId: "AccountId"
    },
    InstantiateReturnValue: "Result<InstantiateReturnValueOk, DispatchError>",
    InstructionWeights: {
      i64const: "u32",
      i64load: "u32",
      i64store: "u32",
      select: "u32",
      rIf: "u32",
      br: "u32",
      brIf: "u32",
      brIable: "u32",
      brIablePerEntry: "u32",
      call: "u32",
      callIndirect: "u32",
      callIndirectPerParam: "u32",
      localGet: "u32",
      localSet: "u32",
      local_tee: "u32",
      globalGet: "u32",
      globalSet: "u32",
      memoryCurrent: "u32",
      memoryGrow: "u32",
      i64clz: "u32",
      i64ctz: "u32",
      i64popcnt: "u32",
      i64eqz: "u32",
      i64extendsi32: "u32",
      i64extendui32: "u32",
      i32wrapi64: "u32",
      i64eq: "u32",
      i64ne: "u32",
      i64lts: "u32",
      i64ltu: "u32",
      i64gts: "u32",
      i64gtu: "u32",
      i64les: "u32",
      i64leu: "u32",
      i64ges: "u32",
      i64geu: "u32",
      i64add: "u32",
      i64sub: "u32",
      i64mul: "u32",
      i64divs: "u32",
      i64divu: "u32",
      i64rems: "u32",
      i64remu: "u32",
      i64and: "u32",
      i64or: "u32",
      i64xor: "u32",
      i64shl: "u32",
      i64shrs: "u32",
      i64shru: "u32",
      i64rotl: "u32",
      i64rotr: "u32"
    },
    LimitsTo264: {
      eventTopics: "u32",
      stackHeight: "u32",
      globals: "u32",
      parameters: "u32",
      memoryPages: "u32",
      tableSize: "u32",
      brTableSize: "u32",
      subjectLen: "u32",
      codeSize: "u32"
    },
    Limits: {
      eventTopics: "u32",
      stackHeight: "u32",
      globals: "u32",
      parameters: "u32",
      memoryPages: "u32",
      tableSize: "u32",
      brTableSize: "u32",
      subjectLen: "u32"
    },
    PrefabWasmModule: {
      scheduleVersion: "Compact<u32>",
      initial: "Compact<u32>",
      maximum: "Compact<u32>",
      refcount: "Compact<u64>",
      _reserved: "Option<Null>",
      code: "Bytes",
      originalCodeLen: "u32"
    },
    RentProjection: {
      _enum: {
        EvictionAt: "BlockNumber",
        NoEviction: "Null"
      }
    },
    ScheduleTo212: {
      version: "u32",
      putCodePerByteCost: "Gas",
      growMemCost: "Gas",
      regularOpCost: "Gas",
      returnDataPerByteCost: "Gas",
      eventDataPerByteCost: "Gas",
      eventPerTopicCost: "Gas",
      eventBaseCost: "Gas",
      sandboxDataReadCost: "Gas",
      sandboxDataWriteCost: "Gas",
      maxEventTopics: "u32",
      maxStackHeight: "u32",
      maxMemoryPages: "u32",
      enablePrintln: "bool",
      maxSubjectLen: "u32"
    },
    ScheduleTo258: {
      version: "u32",
      putCodePerByteCost: "Gas",
      growMemCost: "Gas",
      regularOpCost: "Gas",
      returnDataPerByteCost: "Gas",
      eventDataPerByteCost: "Gas",
      eventPerTopicCost: "Gas",
      eventBaseCost: "Gas",
      sandboxDataReadCost: "Gas",
      sandboxDataWriteCost: "Gas",
      transferCost: "Gas",
      maxEventTopics: "u32",
      maxStackHeight: "u32",
      maxMemoryPages: "u32",
      enablePrintln: "bool",
      maxSubjectLen: "u32"
    },
    ScheduleTo264: {
      version: "u32",
      enablePrintln: "bool",
      limits: "LimitsTo264",
      instructionWeights: "InstructionWeights",
      hostFnWeights: "HostFnWeightsTo264"
    },
    Schedule: {
      version: "u32",
      enablePrintln: "bool",
      limits: "Limits",
      instructionWeights: "InstructionWeights",
      hostFnWeights: "HostFnWeights"
    },
    SeedOf: "Hash",
    StorageDeposit: {
      _enum: {
        Refund: "Balance",
        Charge: "Balance"
      }
    },
    TombstoneContractInfo: "Hash",
    TrieId: "Bytes"
  }
}, Pk = {
  rpc: {},
  types: {
    Extrinsic: "GenericExtrinsic",
    ExtrinsicEra: "GenericExtrinsicEra",
    ExtrinsicPayload: "GenericExtrinsicPayload",
    ExtrinsicSignature: "MultiSignature",
    ExtrinsicV4: "GenericExtrinsicV4",
    ExtrinsicPayloadV4: "GenericExtrinsicPayloadV4",
    ExtrinsicSignatureV4: "GenericExtrinsicSignatureV4",
    ExtrinsicUnknown: "GenericExtrinsicUnknown",
    ExtrinsicPayloadUnknown: "GenericExtrinsicPayloadUnknown",
    // eras
    Era: "ExtrinsicEra",
    ImmortalEra: "GenericImmortalEra",
    MortalEra: "GenericMortalEra",
    // signatures & signer
    AnySignature: "H512",
    MultiSignature: {
      _enum: {
        Ed25519: "Ed25519Signature",
        Sr25519: "Sr25519Signature",
        Ecdsa: "EcdsaSignature"
      }
    },
    Signature: "H512",
    SignerPayload: "GenericSignerPayload",
    EcdsaSignature: "[u8; 65]",
    Ed25519Signature: "H512",
    Sr25519Signature: "H512"
  }
}, kk = {
  accountNextIndex: {
    alias: ["account_nextIndex"],
    description: "Retrieves the next accountIndex as available on the node",
    params: [
      {
        name: "accountId",
        type: "AccountId"
      }
    ],
    type: "Index"
  },
  addLogFilter: {
    description: "Adds the supplied directives to the current log filter",
    isUnsafe: !0,
    params: [
      {
        name: "directives",
        type: "Text"
      }
    ],
    type: "Null"
  },
  addReservedPeer: {
    description: "Adds a reserved peer",
    isUnsafe: !0,
    params: [
      {
        name: "peer",
        type: "Text"
      }
    ],
    type: "Text"
  },
  chain: {
    description: "Retrieves the chain",
    params: [],
    type: "Text"
  },
  chainType: {
    description: "Retrieves the chain type",
    params: [],
    type: "ChainType"
  },
  dryRun: {
    alias: ["system_dryRunAt"],
    description: "Dry run an extrinsic at a given block",
    isUnsafe: !0,
    params: [
      {
        name: "extrinsic",
        type: "Bytes"
      },
      {
        isHistoric: !0,
        isOptional: !0,
        name: "at",
        type: "BlockHash"
      }
    ],
    type: "ApplyExtrinsicResult"
  },
  health: {
    description: "Return health status of the node",
    noErrorLog: !0,
    params: [],
    type: "Health"
  },
  localListenAddresses: {
    description: "The addresses include a trailing /p2p/ with the local PeerId, and are thus suitable to be passed to addReservedPeer or as a bootnode address for example",
    params: [],
    type: "Vec<Text>"
  },
  localPeerId: {
    description: "Returns the base58-encoded PeerId of the node",
    params: [],
    type: "Text"
  },
  name: {
    description: "Retrieves the node name",
    params: [],
    type: "Text"
  },
  networkState: {
    alias: ["system_unstable_networkState"],
    description: "Returns current state of the network",
    isUnsafe: !0,
    params: [],
    type: "NetworkState"
  },
  nodeRoles: {
    description: "Returns the roles the node is running as",
    params: [],
    type: "Vec<NodeRole>"
  },
  peers: {
    description: "Returns the currently connected peers",
    isUnsafe: !0,
    params: [],
    type: "Vec<PeerInfo>"
  },
  properties: {
    description: "Get a custom set of properties as a JSON object, defined in the chain spec",
    params: [],
    type: "ChainProperties"
  },
  removeReservedPeer: {
    description: "Remove a reserved peer",
    isUnsafe: !0,
    params: [
      {
        name: "peerId",
        type: "Text"
      }
    ],
    type: "Text"
  },
  reservedPeers: {
    description: "Returns the list of reserved peers",
    params: [],
    type: "Vec<Text>"
  },
  resetLogFilter: {
    description: "Resets the log filter to Substrate defaults",
    isUnsafe: !0,
    params: [],
    type: "Null"
  },
  syncState: {
    description: "Returns the state of the syncing of the node",
    params: [],
    type: "SyncState"
  },
  version: {
    description: "Retrieves the version of the node",
    params: [],
    type: "Text"
  }
}, Tk = {
  AccountNonceApi: [
    {
      methods: {
        account_nonce: {
          description: "The API to query account nonce (aka transaction index)",
          params: [
            {
              name: "accountId",
              type: "AccountId"
            }
          ],
          type: "Index"
        }
      },
      version: 1
    }
  ]
}, Nk = {
  rpc: kk,
  runtime: Tk,
  types: {
    AccountInfo: "AccountInfoWithTripleRefCount",
    AccountInfoWithRefCountU8: {
      nonce: "Index",
      refcount: "u8",
      data: "AccountData"
    },
    AccountInfoWithRefCount: {
      _fallback: "AccountInfoWithRefCountU8",
      nonce: "Index",
      refcount: "RefCount",
      data: "AccountData"
    },
    AccountInfoWithDualRefCount: {
      _fallback: "AccountInfoWithRefCount",
      nonce: "Index",
      consumers: "RefCount",
      providers: "RefCount",
      data: "AccountData"
    },
    // original naming
    AccountInfoWithProviders: "AccountInfoWithDualRefCount",
    AccountInfoWithTripleRefCount: {
      _fallback: "AccountInfoWithDualRefCount",
      nonce: "Index",
      consumers: "RefCount",
      providers: "RefCount",
      sufficients: "RefCount",
      data: "AccountData"
    },
    ApplyExtrinsicResult: "Result<DispatchOutcome, TransactionValidityError>",
    ApplyExtrinsicResultPre6: "Result<DispatchOutcomePre6, TransactionValidityError>",
    ArithmeticError: {
      _enum: [
        "Underflow",
        "Overflow",
        "DivisionByZero"
      ]
    },
    BlockLength: {
      max: "PerDispatchClassU32"
    },
    BlockWeights: {
      baseBlock: "Weight",
      maxBlock: "Weight",
      perClass: "PerDispatchClassWeightsPerClass"
    },
    ChainProperties: "GenericChainProperties",
    ChainType: {
      _enum: {
        Development: "Null",
        Local: "Null",
        Live: "Null",
        Custom: "Text"
      }
    },
    ConsumedWeight: "PerDispatchClassWeight",
    DigestOf: "Digest",
    DispatchClass: {
      _enum: ["Normal", "Operational", "Mandatory"]
    },
    DispatchError: {
      _enum: {
        Other: "Null",
        CannotLookup: "Null",
        BadOrigin: "Null",
        Module: "DispatchErrorModule",
        ConsumerRemaining: "Null",
        NoProviders: "Null",
        TooManyConsumers: "Null",
        Token: "TokenError",
        Arithmetic: "ArithmeticError",
        Transactional: "TransactionalError",
        Exhausted: "Null",
        Corruption: "Null",
        Unavailable: "Null"
      }
    },
    DispatchErrorPre6: {
      _enum: {
        Other: "Null",
        CannotLookup: "Null",
        BadOrigin: "Null",
        Module: "DispatchErrorModulePre6",
        ConsumerRemaining: "Null",
        NoProviders: "Null",
        TooManyConsumers: "Null",
        Token: "TokenError",
        Arithmetic: "ArithmeticError",
        Transactional: "TransactionalError"
      }
    },
    DispatchErrorPre6First: {
      // The enum was modified mid-flight, affecting asset chains -
      // https://github.com/paritytech/substrate/pull/10382/files#diff-e4e016b33a82268b6208dc974eea841bad47597865a749fee2f937eb6fdf67b4R498
      _enum: {
        Other: "Null",
        CannotLookup: "Null",
        BadOrigin: "Null",
        Module: "DispatchErrorModulePre6",
        ConsumerRemaining: "Null",
        NoProviders: "Null",
        Token: "TokenError",
        Arithmetic: "ArithmeticError",
        Transactional: "TransactionalError"
      }
    },
    DispatchErrorModuleU8: {
      index: "u8",
      error: "u8"
    },
    DispatchErrorModuleU8a: {
      index: "u8",
      error: "[u8; 4]"
    },
    DispatchErrorModule: "DispatchErrorModuleU8a",
    DispatchErrorModulePre6: "DispatchErrorModuleU8",
    DispatchErrorTo198: {
      module: "Option<u8>",
      error: "u8"
    },
    DispatchInfo: {
      weight: "Weight",
      class: "DispatchClass",
      paysFee: "Pays"
    },
    DispatchInfoTo190: {
      weight: "Weight",
      class: "DispatchClass"
    },
    DispatchInfoTo244: {
      weight: "Weight",
      class: "DispatchClass",
      paysFee: "bool"
    },
    DispatchOutcome: "Result<(), DispatchError>",
    DispatchOutcomePre6: "Result<(), DispatchErrorPre6>",
    DispatchResult: "Result<(), DispatchError>",
    DispatchResultOf: "DispatchResult",
    DispatchResultTo198: "Result<(), Text>",
    Event: "GenericEvent",
    EventId: "[u8; 2]",
    EventIndex: "u32",
    EventRecord: {
      phase: "Phase",
      event: "Event",
      topics: "Vec<Hash>"
    },
    Health: {
      peers: "u64",
      isSyncing: "bool",
      shouldHavePeers: "bool"
    },
    InvalidTransaction: {
      _enum: {
        Call: "Null",
        Payment: "Null",
        Future: "Null",
        Stale: "Null",
        BadProof: "Null",
        AncientBirthBlock: "Null",
        ExhaustsResources: "Null",
        Custom: "u8",
        BadMandatory: "Null",
        MandatoryDispatch: "Null",
        BadSigner: "Null"
      }
    },
    Key: "Bytes",
    LastRuntimeUpgradeInfo: {
      specVersion: "Compact<u32>",
      specName: "Text"
    },
    NetworkState: {
      peerId: "Text",
      listenedAddresses: "Vec<Text>",
      externalAddresses: "Vec<Text>",
      connectedPeers: "HashMap<Text, Peer>",
      notConnectedPeers: "HashMap<Text, NotConnectedPeer>",
      averageDownloadPerSec: "u64",
      averageUploadPerSec: "u64",
      peerset: "NetworkStatePeerset"
    },
    NetworkStatePeerset: {
      messageQueue: "u64",
      nodes: "HashMap<Text, NetworkStatePeersetInfo>"
    },
    NetworkStatePeersetInfo: {
      connected: "bool",
      reputation: "i32"
    },
    NodeRole: {
      _enum: {
        Full: "Null",
        LightClient: "Null",
        Authority: "Null",
        UnknownRole: "u8"
      }
    },
    NotConnectedPeer: {
      knownAddresses: "Vec<Text>",
      latestPingTime: "Option<PeerPing>",
      versionString: "Option<Text>"
    },
    Peer: {
      enabled: "bool",
      endpoint: "PeerEndpoint",
      knownAddresses: "Vec<Text>",
      latestPingTime: "PeerPing",
      open: "bool",
      versionString: "Text"
    },
    PeerEndpoint: {
      listening: "PeerEndpointAddr"
    },
    PeerEndpointAddr: {
      _alias: {
        localAddr: "local_addr",
        sendBackAddr: "send_back_addr"
      },
      localAddr: "Text",
      sendBackAddr: "Text"
    },
    PeerPing: {
      nanos: "u64",
      secs: "u64"
    },
    PeerInfo: {
      peerId: "Text",
      roles: "Text",
      protocolVersion: "u32",
      bestHash: "Hash",
      bestNumber: "BlockNumber"
    },
    PerDispatchClassU32: {
      normal: "u32",
      operational: "u32",
      mandatory: "u32"
    },
    PerDispatchClassWeight: {
      normal: "Weight",
      operational: "Weight",
      mandatory: "Weight"
    },
    PerDispatchClassWeightsPerClass: {
      normal: "WeightPerClass",
      operational: "WeightPerClass",
      mandatory: "WeightPerClass"
    },
    Phase: {
      _enum: {
        ApplyExtrinsic: "u32",
        Finalization: "Null",
        Initialization: "Null"
      }
    },
    RawOrigin: {
      _enum: {
        Root: "Null",
        Signed: "AccountId",
        None: "Null"
      }
    },
    RefCount: "u32",
    RefCountTo259: "u8",
    SyncState: {
      startingBlock: "BlockNumber",
      currentBlock: "BlockNumber",
      highestBlock: "Option<BlockNumber>"
    },
    SystemOrigin: "RawOrigin",
    TokenError: {
      _enum: [
        "NoFunds",
        "WouldDie",
        "BelowMinimum",
        "CannotCreate",
        "UnknownAsset",
        "Frozen",
        "Unsupported",
        // these are dropped, but still in older versions
        // (if this adjusts, will need to take a re-look)
        "Underflow",
        "Overflow"
      ]
    },
    TransactionValidityError: {
      _enum: {
        Invalid: "InvalidTransaction",
        Unknown: "UnknownTransaction"
      }
    },
    TransactionalError: {
      _enum: [
        "LimitReached",
        "NoLayer"
      ]
    },
    UnknownTransaction: {
      _enum: {
        CannotLookup: "Null",
        NoUnsignedValidator: "Null",
        Custom: "u8"
      }
    },
    WeightPerClass: {
      baseExtrinsic: "Weight",
      maxExtrinsic: "Option<Weight>",
      maxTotal: "Option<Weight>",
      reserved: "Option<Weight>"
    }
  }
}, Rk = {
  rpc: {},
  types: {
    Multisig: {
      when: "Timepoint",
      deposit: "Balance",
      depositor: "AccountId",
      approvals: "Vec<AccountId>"
    },
    Timepoint: {
      height: "BlockNumber",
      index: "u32"
    }
  }
}, Ik = {
  ContractCryptoHasher: {
    _enum: ["Blake2x256", "Sha2x256", "Keccak256"]
  },
  ContractDiscriminant: "u32",
  ContractLayoutArray: {
    offset: "ContractLayoutKey",
    len: "u32",
    cellsPerElem: "u64",
    layout: "ContractStorageLayout"
  },
  ContractLayoutCell: {
    key: "ContractLayoutKey",
    ty: "SiLookupTypeId"
  },
  ContractLayoutEnum: {
    dispatchKey: "ContractLayoutKey",
    variants: "BTreeMap<ContractDiscriminant, ContractLayoutStruct>"
  },
  ContractLayoutHash: {
    offset: "ContractLayoutKey",
    strategy: "ContractLayoutHashingStrategy",
    layout: "ContractStorageLayout"
  },
  ContractLayoutHashingStrategy: {
    hasher: "ContractCryptoHasher",
    postfix: "Vec<u8>",
    prefix: "Vec<u8>"
  },
  ContractLayoutKey: "[u8; 32]",
  ContractLayoutStruct: {
    fields: "Vec<ContractLayoutStructField>"
  },
  ContractLayoutStructField: {
    layout: "ContractStorageLayout",
    name: "Text"
  },
  ContractStorageLayout: {
    _enum: {
      Cell: "ContractLayoutCell",
      Hash: "ContractLayoutHash",
      Array: "ContractLayoutArray",
      Struct: "ContractLayoutStruct",
      Enum: "ContractLayoutEnum"
    }
  }
}, Ok = {
  ContractConstructorSpecV0: {
    name: "Text",
    selector: "ContractSelector",
    args: "Vec<ContractMessageParamSpecV0>",
    docs: "Vec<Text>"
  },
  ContractConstructorSpecV1: {
    name: "Vec<Text>",
    selector: "ContractSelector",
    args: "Vec<ContractMessageParamSpecV0>",
    docs: "Vec<Text>"
  },
  ContractConstructorSpecV2: {
    label: "Text",
    selector: "ContractSelector",
    args: "Vec<ContractMessageParamSpecV2>",
    docs: "Vec<Text>"
  },
  ContractConstructorSpecV3: {
    label: "Text",
    selector: "ContractSelector",
    payable: "bool",
    args: "Vec<ContractMessageParamSpecV2>",
    docs: "Vec<Text>"
  },
  ContractConstructorSpecV4: {
    label: "Text",
    selector: "ContractSelector",
    payable: "bool",
    args: "Vec<ContractMessageParamSpecV2>",
    docs: "Vec<Text>",
    default: "bool",
    returnType: "Option<ContractTypeSpec>"
  },
  ContractContractSpecV0: {
    constructors: "Vec<ContractConstructorSpecV0>",
    messages: "Vec<ContractMessageSpecV0>",
    events: "Vec<ContractEventSpecV0>",
    docs: "Vec<Text>"
  },
  ContractContractSpecV1: {
    constructors: "Vec<ContractConstructorSpecV1>",
    messages: "Vec<ContractMessageSpecV1>",
    events: "Vec<ContractEventSpecV1>",
    docs: "Vec<Text>"
  },
  ContractContractSpecV2: {
    constructors: "Vec<ContractConstructorSpecV2>",
    messages: "Vec<ContractMessageSpecV2>",
    events: "Vec<ContractEventSpecV2>",
    docs: "Vec<Text>"
  },
  ContractContractSpecV3: {
    constructors: "Vec<ContractConstructorSpecV3>",
    messages: "Vec<ContractMessageSpecV2>",
    events: "Vec<ContractEventSpecV2>",
    docs: "Vec<Text>"
  },
  ContractContractSpecV4: {
    constructors: "Vec<ContractConstructorSpecV4>",
    messages: "Vec<ContractMessageSpecV3>",
    events: "Vec<ContractEventSpecV2>",
    docs: "Vec<Text>",
    environment: "ContractEnvironmentV4"
  },
  ContractDisplayName: "SiPath",
  ContractEventParamSpecV0: {
    name: "Text",
    indexed: "bool",
    type: "ContractTypeSpec",
    docs: "Vec<Text>"
  },
  ContractEventParamSpecV2: {
    label: "Text",
    indexed: "bool",
    type: "ContractTypeSpec",
    docs: "Vec<Text>"
  },
  ContractEventSpecV0: {
    name: "Text",
    args: "Vec<ContractEventParamSpecV0>",
    docs: "Vec<Text>"
  },
  ContractEventSpecV1: {
    name: "Text",
    args: "Vec<ContractEventParamSpecV0>",
    docs: "Vec<Text>"
  },
  ContractEventSpecV2: {
    label: "Text",
    args: "Vec<ContractEventParamSpecV2>",
    docs: "Vec<Text>"
  },
  ContractMessageParamSpecV0: {
    name: "Text",
    type: "ContractTypeSpec"
  },
  ContractMessageParamSpecV2: {
    label: "Text",
    type: "ContractTypeSpec"
  },
  ContractMessageSpecV0: {
    name: "Text",
    selector: "ContractSelector",
    mutates: "bool",
    payable: "bool",
    args: "Vec<ContractMessageParamSpecV0>",
    returnType: "Option<ContractTypeSpec>",
    docs: "Vec<Text>"
  },
  ContractMessageSpecV1: {
    name: "Vec<Text>",
    selector: "ContractSelector",
    mutates: "bool",
    payable: "bool",
    args: "Vec<ContractMessageParamSpecV0>",
    returnType: "Option<ContractTypeSpec>",
    docs: "Vec<Text>"
  },
  ContractMessageSpecV2: {
    label: "Text",
    selector: "ContractSelector",
    mutates: "bool",
    payable: "bool",
    args: "Vec<ContractMessageParamSpecV2>",
    returnType: "Option<ContractTypeSpec>",
    docs: "Vec<Text>"
  },
  ContractMessageSpecV3: {
    label: "Text",
    selector: "ContractSelector",
    mutates: "bool",
    payable: "bool",
    args: "Vec<ContractMessageParamSpecV2>",
    returnType: "Option<ContractTypeSpec>",
    docs: "Vec<Text>",
    default: "bool"
  },
  ContractSelector: "[u8; 4]",
  ContractTypeSpec: {
    type: "SiLookupTypeId",
    displayName: "ContractDisplayName"
  }
}, Mk = {
  ContractConstructorSpecLatest: "ContractConstructorSpecV4",
  ContractEventSpecLatest: "ContractEventSpecV2",
  ContractEventParamSpecLatest: "ContractEventParamSpecV2",
  ContractMessageParamSpecLatest: "ContractMessageParamSpecV2",
  ContractMessageSpecLatest: "ContractMessageSpecV3",
  ContractMetadataLatest: "ContractMetadataV4"
}, Lk = {
  rpc: {},
  types: {
    ...Ik,
    ...Ok,
    ...Mk,
    ContractProjectInfo: {
      source: "ContractProjectSource",
      contract: "ContractProjectContract"
    },
    ContractMetadataV0: {
      metadataVersion: "Text",
      types: "Vec<Si0Type>",
      spec: "ContractContractSpecV0"
    },
    ContractMetadataV1: {
      types: "Vec<PortableType>",
      spec: "ContractContractSpecV1"
    },
    ContractMetadataV2: {
      types: "Vec<PortableType>",
      spec: "ContractContractSpecV2"
    },
    ContractMetadataV3: {
      types: "Vec<PortableType>",
      spec: "ContractContractSpecV3"
    },
    ContractMetadataV4: {
      types: "Vec<PortableType>",
      spec: "ContractContractSpecV4"
    },
    ContractMetadata: {
      _enum: {
        V0: "ContractMetadataV0",
        V1: "ContractMetadataV1",
        V2: "ContractMetadataV2",
        V3: "ContractMetadataV3",
        V4: "ContractMetadataV4"
      }
    },
    ContractProjectV0: {
      metadataVersion: "Text",
      source: "ContractProjectSource",
      contract: "ContractProjectContract",
      types: "Vec<Si0Type>",
      spec: "ContractContractSpecV0"
    },
    ContractProject: "(ContractProjectInfo, ContractMetadata)",
    ContractProjectContract: {
      _alias: {
        docs: "documentation"
      },
      name: "Text",
      version: "Text",
      authors: "Vec<Text>",
      description: "Option<Text>",
      docs: "Option<Text>",
      repository: "Option<Text>",
      homepage: "Option<Text>",
      license: "Option<Text>"
    },
    ContractProjectSource: {
      _alias: {
        wasmHash: "hash"
      },
      wasmHash: "[u8; 32]",
      language: "Text",
      compiler: "Text",
      wasm: "Raw"
    },
    ContractEnvironmentV4: {
      _alias: {
        hashType: "hash"
      },
      // NOTE These are not marked optional in the Rust code, however since we
      // convert from older versions to newer, we may not have these fields.
      // The Option<...> works since our inputs are always JSON, so it will
      // be None when not specified.
      //
      // Additionally we don't mark the full structure as Option, rather we
      // do it on a per-field basis since fields may be added as the versions
      // progress.
      accountId: "Option<ContractTypeSpec>",
      balance: "Option<ContractTypeSpec>",
      blockNumber: "Option<ContractTypeSpec>",
      hashType: "Option<ContractTypeSpec>",
      timestamp: "Option<ContractTypeSpec>",
      maxEventTopics: "Option<u32>"
    }
  }
}, Dk = {
  methods: {
    description: "Retrieves the list of RPC methods that are exposed by the node",
    params: [],
    type: "RpcMethods"
  }
}, Uk = {
  rpc: Dk,
  types: {
    RpcMethods: {
      version: "u32",
      methods: "Vec<Text>"
    }
  }
}, Vk = {
  getBlock: {
    description: "Get header and body of a relay chain block",
    params: [
      {
        isHistoric: !0,
        isOptional: !0,
        name: "hash",
        type: "BlockHash"
      }
    ],
    type: "SignedBlock"
  },
  getBlockHash: {
    description: "Get the block hash for a specific block",
    params: [
      {
        isOptional: !0,
        name: "blockNumber",
        type: "BlockNumber"
      }
    ],
    type: "BlockHash"
  },
  getFinalizedHead: {
    alias: ["chain_getFinalisedHead"],
    description: "Get hash of the last finalized block in the canon chain",
    params: [],
    type: "BlockHash"
  },
  getHeader: {
    alias: ["chain_getHead"],
    description: "Retrieves the header for a specific block",
    params: [
      {
        isHistoric: !0,
        isOptional: !0,
        name: "hash",
        type: "BlockHash"
      }
    ],
    type: "Header"
  },
  subscribeAllHeads: {
    description: "Retrieves the newest header via subscription",
    params: [],
    pubsub: [
      "allHead",
      "subscribeAllHeads",
      "unsubscribeAllHeads"
    ],
    type: "Header"
  },
  subscribeFinalizedHeads: {
    alias: ["chain_subscribeFinalisedHeads", "chain_unsubscribeFinalisedHeads"],
    description: "Retrieves the best finalized header via subscription",
    params: [],
    pubsub: [
      "finalizedHead",
      "subscribeFinalizedHeads",
      "unsubscribeFinalizedHeads"
    ],
    type: "Header"
  },
  subscribeNewHeads: {
    alias: ["chain_unsubscribeNewHeads", "subscribe_newHead", "unsubscribe_newHead"],
    description: "Retrieves the best header via subscription",
    params: [],
    // NOTE These still has the aliassed version, compatible with 1.x
    pubsub: [
      "newHead",
      "subscribeNewHead",
      "unsubscribeNewHead"
    ],
    type: "Header"
  }
}, Bk = {
  rpc: Vk,
  types: {
    BlockHash: "Hash"
  }
}, Hk = {
  call: {
    alias: ["state_callAt"],
    description: "Perform a call to a builtin on the chain",
    params: [
      {
        name: "method",
        type: "Text"
      },
      {
        name: "data",
        type: "Bytes"
      },
      {
        isHistoric: !0,
        isOptional: !0,
        name: "at",
        type: "BlockHash"
      }
    ],
    type: "Bytes"
  },
  getChildKeys: {
    description: "Retrieves the keys with prefix of a specific child storage",
    params: [
      {
        name: "childStorageKey",
        type: "StorageKey"
      },
      {
        name: "childDefinition",
        type: "StorageKey"
      },
      {
        name: "childType",
        type: "u32"
      },
      {
        name: "key",
        type: "StorageKey"
      },
      {
        isHistoric: !0,
        isOptional: !0,
        name: "at",
        type: "BlockHash"
      }
    ],
    type: "Vec<StorageKey>"
  },
  getChildReadProof: {
    description: "Returns proof of storage for child key entries at a specific block state.",
    params: [
      {
        name: "childStorageKey",
        type: "PrefixedStorageKey"
      },
      {
        name: "keys",
        type: "Vec<StorageKey>"
      },
      {
        isHistoric: !0,
        isOptional: !0,
        name: "at",
        type: "BlockHash"
      }
    ],
    type: "ReadProof"
  },
  getChildStorage: {
    description: "Retrieves the child storage for a key",
    params: [
      {
        name: "childStorageKey",
        type: "StorageKey"
      },
      {
        name: "childDefinition",
        type: "StorageKey"
      },
      {
        name: "childType",
        type: "u32"
      },
      {
        name: "key",
        type: "StorageKey"
      },
      {
        isHistoric: !0,
        isOptional: !0,
        name: "at",
        type: "BlockHash"
      }
    ],
    type: "StorageData"
  },
  getChildStorageHash: {
    description: "Retrieves the child storage hash",
    params: [
      {
        name: "childStorageKey",
        type: "StorageKey"
      },
      {
        name: "childDefinition",
        type: "StorageKey"
      },
      {
        name: "childType",
        type: "u32"
      },
      {
        name: "key",
        type: "StorageKey"
      },
      {
        isHistoric: !0,
        isOptional: !0,
        name: "at",
        type: "BlockHash"
      }
    ],
    type: "Hash"
  },
  getChildStorageSize: {
    description: "Retrieves the child storage size",
    params: [
      {
        name: "childStorageKey",
        type: "StorageKey"
      },
      {
        name: "childDefinition",
        type: "StorageKey"
      },
      {
        name: "childType",
        type: "u32"
      },
      {
        name: "key",
        type: "StorageKey"
      },
      {
        isHistoric: !0,
        isOptional: !0,
        name: "at",
        type: "BlockHash"
      }
    ],
    type: "u64"
  },
  getKeys: {
    deprecated: "Use `api.rpc.state.getKeysPaged` to retrieve keys",
    description: "Retrieves the keys with a certain prefix",
    params: [
      {
        name: "key",
        type: "StorageKey"
      },
      {
        isHistoric: !0,
        isOptional: !0,
        name: "at",
        type: "BlockHash"
      }
    ],
    type: "Vec<StorageKey>"
  },
  getKeysPaged: {
    alias: ["state_getKeysPagedAt"],
    description: "Returns the keys with prefix with pagination support.",
    params: [
      {
        name: "key",
        type: "StorageKey"
      },
      {
        name: "count",
        type: "u32"
      },
      {
        isOptional: !0,
        name: "startKey",
        type: "StorageKey"
      },
      {
        isHistoric: !0,
        isOptional: !0,
        name: "at",
        type: "BlockHash"
      }
    ],
    type: "Vec<StorageKey>"
  },
  getMetadata: {
    description: "Returns the runtime metadata",
    params: [
      {
        isHistoric: !0,
        isOptional: !0,
        name: "at",
        type: "BlockHash"
      }
    ],
    type: "Metadata"
  },
  getPairs: {
    deprecated: "Use `api.rpc.state.getKeysPaged` to retrieve keys",
    description: "Returns the keys with prefix, leave empty to get all the keys (deprecated: Use getKeysPaged)",
    isUnsafe: !0,
    params: [
      {
        name: "prefix",
        type: "StorageKey"
      },
      {
        isHistoric: !0,
        isOptional: !0,
        name: "at",
        type: "BlockHash"
      }
    ],
    type: "Vec<KeyValue>"
  },
  getReadProof: {
    description: "Returns proof of storage entries at a specific block state",
    params: [
      {
        name: "keys",
        type: "Vec<StorageKey>"
      },
      {
        isHistoric: !0,
        isOptional: !0,
        name: "at",
        type: "BlockHash"
      }
    ],
    type: "ReadProof"
  },
  getRuntimeVersion: {
    alias: ["chain_getRuntimeVersion"],
    description: "Get the runtime version",
    params: [
      {
        isHistoric: !0,
        isOptional: !0,
        name: "at",
        type: "BlockHash"
      }
    ],
    type: "RuntimeVersion"
  },
  getStorage: {
    alias: ["state_getStorageAt"],
    description: "Retrieves the storage for a key",
    params: [
      {
        name: "key",
        type: "StorageKey"
      },
      {
        isHistoric: !0,
        isOptional: !0,
        name: "at",
        type: "BlockHash"
      }
    ],
    type: "StorageData"
  },
  getStorageHash: {
    alias: ["state_getStorageHashAt"],
    description: "Retrieves the storage hash",
    params: [
      {
        name: "key",
        type: "StorageKey"
      },
      {
        isHistoric: !0,
        isOptional: !0,
        name: "at",
        type: "BlockHash"
      }
    ],
    type: "Hash"
  },
  getStorageSize: {
    alias: ["state_getStorageSizeAt"],
    description: "Retrieves the storage size",
    params: [
      {
        name: "key",
        type: "StorageKey"
      },
      {
        isHistoric: !0,
        isOptional: !0,
        name: "at",
        type: "BlockHash"
      }
    ],
    type: "u64"
  },
  queryStorage: {
    description: "Query historical storage entries (by key) starting from a start block",
    isUnsafe: !0,
    params: [
      {
        name: "keys",
        type: "Vec<StorageKey>"
      },
      {
        name: "fromBlock",
        type: "Hash"
      },
      {
        isOptional: !0,
        name: "toBlock",
        type: "BlockHash"
      }
    ],
    type: "Vec<StorageChangeSet>"
  },
  queryStorageAt: {
    description: "Query storage entries (by key) starting at block hash given as the second parameter",
    params: [
      {
        name: "keys",
        type: "Vec<StorageKey>"
      },
      {
        isHistoric: !0,
        isOptional: !0,
        name: "at",
        type: "BlockHash"
      }
    ],
    type: "Vec<StorageChangeSet>"
  },
  subscribeRuntimeVersion: {
    alias: ["chain_subscribeRuntimeVersion", "chain_unsubscribeRuntimeVersion"],
    description: "Retrieves the runtime version via subscription",
    params: [],
    pubsub: [
      "runtimeVersion",
      "subscribeRuntimeVersion",
      "unsubscribeRuntimeVersion"
    ],
    type: "RuntimeVersion"
  },
  subscribeStorage: {
    description: "Subscribes to storage changes for the provided keys",
    // NOTE Just marking it here to follow the logic - this is unsafe when no
    // keys are provided (i.e. subscribing to all), generally this is used
    // extensively with normal subscriptions
    // isUnsafe: true,
    params: [
      {
        isOptional: !0,
        name: "keys",
        type: "Vec<StorageKey>"
      }
    ],
    pubsub: [
      "storage",
      "subscribeStorage",
      "unsubscribeStorage"
    ],
    type: "StorageChangeSet"
  },
  traceBlock: {
    description: "Provides a way to trace the re-execution of a single block",
    isUnsafe: !0,
    params: [
      {
        name: "block",
        type: "Hash"
      },
      {
        name: "targets",
        type: "Option<Text>"
      },
      {
        name: "storageKeys",
        type: "Option<Text>"
      },
      {
        name: "methods",
        type: "Option<Text>"
      }
    ],
    type: "TraceBlockResponse"
  },
  trieMigrationStatus: {
    description: "Check current migration state",
    isUnsafe: !0,
    params: [
      {
        isHistoric: !0,
        isOptional: !0,
        name: "at",
        type: "BlockHash"
      }
    ],
    type: "MigrationStatusResult"
  }
}, Fk = {
  rpc: Hk,
  types: {
    ApiId: "[u8; 8]",
    BlockTrace: {
      blockHash: "Text",
      parentHash: "Text",
      tracingTargets: "Text",
      storageKeys: "Text",
      spans: "Vec<BlockTraceSpan>",
      events: "Vec<BlockTraceEvent>"
    },
    BlockTraceEvent: {
      target: "Text",
      data: "BlockTraceEventData",
      parentId: "Option<u64>"
    },
    BlockTraceEventData: {
      stringValues: "HashMap<Text, Text>"
    },
    BlockTraceSpan: {
      id: "u64",
      parentId: "Option<u64>",
      name: "Text",
      target: "Text",
      wasm: "bool"
    },
    KeyValueOption: "(StorageKey, Option<StorageData>)",
    MigrationStatusResult: {
      topRemainingToMigrate: "u64",
      childRemainingToMigrate: "u64"
    },
    ReadProof: {
      at: "Hash",
      proof: "Vec<Bytes>"
    },
    RuntimeVersionApi: "(ApiId, u32)",
    RuntimeVersion: {
      specName: "Text",
      implName: "Text",
      authoringVersion: "u32",
      specVersion: "u32",
      implVersion: "u32",
      apis: "Vec<RuntimeVersionApi>",
      transactionVersion: "u32",
      stateVersion: "u8"
    },
    RuntimeVersionPre4: {
      specName: "Text",
      implName: "Text",
      authoringVersion: "u32",
      specVersion: "u32",
      implVersion: "u32",
      apis: "Vec<RuntimeVersionApi>",
      transactionVersion: "u32"
    },
    RuntimeVersionPre3: {
      specName: "Text",
      implName: "Text",
      authoringVersion: "u32",
      specVersion: "u32",
      implVersion: "u32",
      apis: "Vec<RuntimeVersionApi>"
    },
    RuntimeVersionPartial: {
      specName: "Text",
      specVersion: "u32",
      apis: "Vec<RuntimeVersionApi>"
    },
    SpecVersion: "u32",
    StorageChangeSet: {
      block: "Hash",
      changes: "Vec<KeyValueOption>"
    },
    TraceBlockResponse: {
      _enum: {
        TraceError: "TraceError",
        BlockTrace: "BlockTrace"
      }
    },
    TraceError: {
      error: "Text"
    }
  }
}, Ga = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  assetConversion: ne,
  assets: ne,
  attestations: ne,
  aura: ne,
  author: ne,
  authorship: ne,
  babe: ne,
  balances: Sk,
  beefy: ne,
  benchmark: ne,
  blockbuilder: ne,
  bridges: ne,
  chain: Bk,
  childstate: ne,
  claims: ne,
  collective: ne,
  consensus: ne,
  contracts: Ak,
  contractsAbi: Lk,
  crowdloan: ne,
  cumulus: ne,
  democracy: ne,
  dev: ne,
  discovery: ne,
  elections: ne,
  engine: ne,
  eth: ne,
  evm: ne,
  extrinsics: Pk,
  finality: ne,
  fungibles: ne,
  genericAsset: ne,
  gilt: ne,
  grandpa: ne,
  identity: ne,
  imOnline: ne,
  lottery: ne,
  metadata: gk,
  mmr: ne,
  nfts: ne,
  nimbus: ne,
  nompools: ne,
  offchain: ne,
  offences: ne,
  ormlOracle: ne,
  ormlTokens: ne,
  parachains: ne,
  payment: ne,
  poll: ne,
  pow: ne,
  proxy: ne,
  purchase: ne,
  recovery: ne,
  rpc: Uk,
  runtime: bk,
  scaleInfo: xk,
  scheduler: ne,
  session: ne,
  society: ne,
  staking: ne,
  state: Fk,
  support: ne,
  syncstate: ne,
  system: Nk,
  treasury: ne,
  txpayment: ne,
  txqueue: ne,
  uniques: ne,
  utility: Rk,
  vesting: ne,
  xcm: ne
}, Symbol.toStringTag, { value: "Module" })), Ca = {};
Object.keys(Ga).forEach((n) => Object.entries(Ga[n].rpc || {}).forEach(([e, t]) => {
  const r = t.aliasSection || n;
  Ca[r] || (Ca[r] = {}), Ca[r][e] = J({}, t, {
    isSubscription: !!t.pubsub,
    jsonrpc: `${r}_${e}`,
    method: e,
    section: r
  });
}));
const Oh = Ca;
var M;
(function(n) {
  n[n.BTreeMap = 0] = "BTreeMap", n[n.BTreeSet = 1] = "BTreeSet", n[n.Compact = 2] = "Compact", n[n.DoNotConstruct = 3] = "DoNotConstruct", n[n.Enum = 4] = "Enum", n[n.HashMap = 5] = "HashMap", n[n.Int = 6] = "Int", n[n.Linkage = 7] = "Linkage", n[n.Null = 8] = "Null", n[n.Option = 9] = "Option", n[n.Plain = 10] = "Plain", n[n.Range = 11] = "Range", n[n.RangeInclusive = 12] = "RangeInclusive", n[n.Result = 13] = "Result", n[n.Set = 14] = "Set", n[n.Si = 15] = "Si", n[n.Struct = 16] = "Struct", n[n.Tuple = 17] = "Tuple", n[n.UInt = 18] = "UInt", n[n.Vec = 19] = "Vec", n[n.VecFixed = 20] = "VecFixed", n[n.WrapperKeepOpaque = 21] = "WrapperKeepOpaque", n[n.WrapperOpaque = 22] = "WrapperOpaque";
})(M || (M = {}));
class Eo extends Array {
  constructor(t, r) {
    super(r);
    b(this, "registry");
    b(this, "createdAtHash");
    b(this, "initialU8aLength");
    b(this, "isStorageFallback");
    this.registry = t;
  }
  /**
   * @description This ensures that operators such as clice, filter, map, etc. return
   * new Array instances (without this we need to apply overrides)
   */
  static get [Symbol.species]() {
    return Array;
  }
  /**
   * @description The length of the value when encoded as a Uint8Array
   */
  get encodedLength() {
    const t = this.length;
    let r = nt(t).length;
    for (let i = 0; i < t; i++)
      r += this[i].encodedLength;
    return r;
  }
  /**
   * @description returns a hash of the contents
   */
  get hash() {
    return this.registry.hash(this.toU8a());
  }
  /**
   * @description Checks if the value is an empty value
   */
  get isEmpty() {
    return this.length === 0;
  }
  /**
   * @description The length of the value
   */
  get length() {
    return super.length;
  }
  /**
   * @description Compares the value of the input to see if there is a match
   */
  eq(t) {
    return vg(this, t);
  }
  /**
   * @description Returns a breakdown of the hex encoding for this Codec
   */
  inspect() {
    return {
      inner: this.inspectInner(),
      outer: [nt(this.length)]
    };
  }
  /**
   * @internal
   * @description Internal per-item inspection of internal values
   */
  inspectInner() {
    const t = this.length, r = new Array(t);
    for (let i = 0; i < t; i++)
      r[i] = this[i].inspect();
    return r;
  }
  /**
   * @description Converts the Object to an standard JavaScript Array
   */
  toArray() {
    return Array.from(this);
  }
  /**
   * @description Returns a hex string representation of the value
   */
  toHex() {
    return pe(this.toU8a());
  }
  /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */
  toHuman(t) {
    const r = this.length, i = new Array(r);
    for (let s = 0; s < r; s++)
      i[s] = this[s] && this[s].toHuman(t);
    return i;
  }
  /**
   * @description Converts the Object to JSON, typically used for RPC transfers
   */
  toJSON() {
    const t = this.length, r = new Array(t);
    for (let i = 0; i < t; i++)
      r[i] = this[i] && this[i].toJSON();
    return r;
  }
  /**
   * @description Converts the value in a best-fit primitive form
   */
  toPrimitive() {
    const t = this.length, r = new Array(t);
    for (let i = 0; i < t; i++)
      r[i] = this[i] && this[i].toPrimitive();
    return r;
  }
  /**
   * @description Returns the string representation of the value
   */
  toString() {
    const t = this.length, r = new Array(t);
    for (let i = 0; i < t; i++)
      r[i] = this[i].toString();
    return `[${r.join(", ")}]`;
  }
  /**
   * @description Encodes the value as a Uint8Array as per the SCALE specifications
   * @param isBare true when the value has none of the type-specific prefixes (internal)
   */
  toU8a(t) {
    const r = this.toU8aInner();
    return Wt(t ? r : [nt(this.length), ...r]);
  }
  /**
   * @internal
   * @description Internal per-item SCALE encoding of contained values
   * @param isBare true when the value has none of the type-specific prefixes (internal)
   */
  toU8aInner(t) {
    const r = this.length, i = new Array(r);
    for (let s = 0; s < r; s++)
      i[s] = this[s].toU8a(t);
    return i;
  }
}
class Co {
  constructor(e, t, r) {
    b(this, "registry");
    b(this, "createdAtHash");
    b(this, "initialU8aLength");
    b(this, "isStorageFallback");
    b(this, "__internal__raw");
    this.initialU8aLength = r, this.__internal__raw = t, this.registry = e;
  }
  /**
   * @description The length of the value when encoded as a Uint8Array
   */
  get encodedLength() {
    return this.toU8a().length;
  }
  /**
   * @description returns a hash of the contents
   */
  get hash() {
    return this.registry.hash(this.toU8a());
  }
  /**
   * @description returns the inner (wrapped value)
   */
  get inner() {
    return this.__internal__raw;
  }
  /**
   * @description Checks if the value is an empty value
   */
  get isEmpty() {
    return this.__internal__raw.isEmpty;
  }
  /**
   * @description Compares the value of the input to see if there is a match
   */
  eq(e) {
    return this.__internal__raw.eq(e);
  }
  /**
   * @description Returns a breakdown of the hex encoding for this Codec
   */
  inspect() {
    return this.__internal__raw.inspect();
  }
  /**
   * @description Returns a hex string representation of the value. isLe returns a LE (number-only) representation
   */
  toHex(e) {
    return this.__internal__raw.toHex(e);
  }
  /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */
  toHuman(e) {
    return this.__internal__raw.toHuman(e);
  }
  /**
   * @description Converts the Object to JSON, typically used for RPC transfers
   */
  toJSON() {
    return this.__internal__raw.toJSON();
  }
  /**
   * @description Converts the value in a best-fit primitive form
   */
  toPrimitive() {
    return this.__internal__raw.toPrimitive();
  }
  /**
   * @description Returns the string representation of the value
   */
  toString() {
    return this.__internal__raw.toString();
  }
  /**
   * @description Encodes the value as a Uint8Array as per the SCALE specifications
   * @param isBare true when the value has none of the type-specific prefixes (internal)
   */
  toU8a(e) {
    return this.__internal__raw.toU8a(e);
  }
  /**
   * @description Returns the inner wrapped value (equivalent to valueOf)
   */
  unwrap() {
    return this.__internal__raw;
  }
  /**
   * @description Returns the inner wrapped value
   */
  valueOf() {
    return this.__internal__raw;
  }
}
const jk = 64, Mh = 52, Wk = new Z(1e4), qk = [
  ["Perquintill", Km],
  ["Perbill", Ia],
  ["Permill", $r],
  ["Percent", mu]
];
function zk(n) {
  return ue(n.toBn);
}
function Xk(n, e) {
  return `${(n.mul(Wk).div(e).toNumber() / 100).toFixed(2)}%`;
}
function G0(n, e) {
  if (xe(n)) {
    if (!Number.isInteger(n) || n > Number.MAX_SAFE_INTEGER || n < Number.MIN_SAFE_INTEGER)
      throw new Error("Number needs to be an integer <= Number.MAX_SAFE_INTEGER, i.e. 2 ^ 53 - 1");
    return n;
  } else if (Pe(n)) {
    if (ye(n, -1, !0))
      return Ni(n, { isLe: !1, isNegative: e }).toString();
    if (n.includes(".") || n.includes(",") || n.includes("e"))
      throw new Error("String should not contain decimal points or scientific notation");
    return n;
  } else {
    if (Yt(n) || vr(n))
      return n.toString();
    if (qt(n)) {
      if (zk(n))
        return n.toBn().toString();
      const t = Object.keys(n);
      if (t.length !== 1)
        throw new Error("Unable to construct number from multi-key object");
      return G0(n[t[0]], e);
    } else if (!n)
      return 0;
  }
  throw new Error(`Unable to create BN from unknown type ${typeof n}`);
}
class Z0 extends Z {
  constructor(t, r = 0, i = jk, s = !1) {
    super(
      // shortcut isU8a as used in SCALE decoding
      te(r) ? i <= 48 ? Xm(r.subarray(0, i / 8), { isNegative: s }) : fn(r.subarray(0, i / 8), { isLe: !0, isNegative: s }).toString() : G0(r, s)
    );
    b(this, "registry");
    b(this, "encodedLength");
    b(this, "isUnsigned");
    b(this, "createdAtHash");
    b(this, "initialU8aLength");
    b(this, "isStorageFallback");
    b(this, "__internal__bitLength");
    this.registry = t, this.__internal__bitLength = i, this.encodedLength = this.__internal__bitLength / 8, this.initialU8aLength = this.__internal__bitLength / 8, this.isUnsigned = !s;
    const a = this.isNeg(), o = i - (s && !a ? 1 : 0);
    if (a && !s)
      throw new Error(`${this.toRawType()}: Negative number passed to unsigned type`);
    if (super.bitLength() > o)
      throw new Error(`${this.toRawType()}: Input too large. Found input with ${super.bitLength()} bits, expected ${o}`);
  }
  /**
   * @description returns a hash of the contents
   */
  get hash() {
    return this.registry.hash(this.toU8a());
  }
  /**
   * @description Checks if the value is a zero value (align elsewhere)
   */
  get isEmpty() {
    return this.isZero();
  }
  /**
   * @description Returns the number of bits in the value
   */
  bitLength() {
    return this.__internal__bitLength;
  }
  /**
   * @description Compares the value of the input to see if there is a match
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  eq(t) {
    return super.eq(ye(t) ? Ni(t.toString(), { isLe: !1, isNegative: !this.isUnsigned }) : Tt(t));
  }
  /**
   * @description Returns a breakdown of the hex encoding for this Codec
   */
  inspect() {
    return {
      outer: [this.toU8a()]
    };
  }
  /**
   * @description True if this value is the max of the type
   */
  isMax() {
    return this.toU8a().filter((r) => r === 255).length === this.__internal__bitLength / 8;
  }
  /**
   * @description Returns a BigInt representation of the number
   */
  toBigInt() {
    return BigInt(this.toString());
  }
  /**
   * @description Returns the BN representation of the number. (Compatibility)
   */
  toBn() {
    return this;
  }
  /**
   * @description Returns a hex string representation of the value
   */
  toHex(t = !1) {
    return $m(this, {
      bitLength: this.bitLength(),
      isLe: t,
      isNegative: !this.isUnsigned
    });
  }
  /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */
  toHuman(t) {
    const r = this.toRawType();
    if (r === "Balance")
      return this.isMax() ? "everything" : zr(this, { decimals: this.registry.chainDecimals[0], withSi: !0, withUnit: this.registry.chainTokens[0] });
    const [, i] = qk.find(([s]) => s === r) || [];
    return i ? Xk(this, i) : Oa(this);
  }
  /**
   * @description Converts the Object to JSON, typically used for RPC transfers
   */
  toJSON(t = !1) {
    return t || this.__internal__bitLength > 128 || super.bitLength() > Mh ? this.toHex() : this.toNumber();
  }
  /**
   * @description Returns the value in a primitive form, either number when <= 52 bits, or string otherwise
   */
  toPrimitive() {
    return super.bitLength() > Mh ? this.toString() : this.toNumber();
  }
  /**
   * @description Returns the base runtime type name for this instance
   */
  toRawType() {
    return this instanceof this.registry.createClassUnsafe("Balance") ? "Balance" : `${this.isUnsigned ? "u" : "i"}${this.bitLength()}`;
  }
  /**
   * @description Returns the string representation of the value
   * @param base The base to use for the conversion
   */
  toString(t) {
    return super.toString(t);
  }
  /**
   * @description Encodes the value as a Uint8Array as per the SCALE specifications
   */
  toU8a(t) {
    return Lt(this, {
      bitLength: this.bitLength(),
      isLe: !0,
      isNegative: !this.isUnsigned
    });
  }
}
function Gk(n, e, t) {
  if (te(t)) {
    const [r, i] = (t[0] & 3) < 3 ? qr(t) : co(t);
    return [new e(n, i), r];
  } else if (t instanceof ks) {
    const r = t.unwrap();
    return r instanceof e ? [r, 0] : [new e(n, r), 0];
  } else if (t instanceof e)
    return [t, 0];
  return [new e(n, t), 0];
}
class ks {
  constructor(e, t, r = 0, { definition: i, setDefinition: s = Xr } = {}) {
    b(this, "registry");
    b(this, "createdAtHash");
    b(this, "initialU8aLength");
    b(this, "isStorageFallback");
    b(this, "__internal__Type");
    b(this, "__internal__raw");
    this.registry = e, this.__internal__Type = i || s(Mn(e, t));
    const [a, o] = Gk(e, this.__internal__Type, r);
    this.initialU8aLength = o, this.__internal__raw = a;
  }
  static with(e) {
    let t;
    const r = (i) => t = i;
    return class extends ks {
      constructor(i, s) {
        super(i, e, s, { definition: t, setDefinition: r });
      }
    };
  }
  /**
   * @description The length of the value when encoded as a Uint8Array
   */
  get encodedLength() {
    return this.toU8a().length;
  }
  /**
   * @description returns a hash of the contents
   */
  get hash() {
    return this.registry.hash(this.toU8a());
  }
  /**
   * @description Checks if the value is an empty value
   */
  get isEmpty() {
    return this.__internal__raw.isEmpty;
  }
  /**
   * @description Returns the number of bits in the value
   */
  bitLength() {
    return this.__internal__raw.bitLength();
  }
  /**
   * @description Compares the value of the input to see if there is a match
   */
  eq(e) {
    return this.__internal__raw.eq(e instanceof ks ? e.__internal__raw : e);
  }
  /**
   * @description Returns a breakdown of the hex encoding for this Codec
   */
  inspect() {
    return {
      outer: [this.toU8a()]
    };
  }
  /**
   * @description Returns a BigInt representation of the number
   */
  toBigInt() {
    return this.__internal__raw.toBigInt();
  }
  /**
   * @description Returns the BN representation of the number
   */
  toBn() {
    return this.__internal__raw.toBn();
  }
  /**
   * @description Returns a hex string representation of the value. isLe returns a LE (number-only) representation
   */
  toHex(e) {
    return this.__internal__raw.toHex(e);
  }
  /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */
  toHuman(e) {
    return this.__internal__raw.toHuman(e);
  }
  /**
   * @description Converts the Object to JSON, typically used for RPC transfers
   */
  toJSON() {
    return this.__internal__raw.toJSON();
  }
  /**
   * @description Returns the number representation for the value
   */
  toNumber() {
    return this.__internal__raw.toNumber();
  }
  /**
   * @description Converts the value in a best-fit primitive form
   */
  toPrimitive() {
    return this.__internal__raw.toPrimitive();
  }
  /**
   * @description Returns the base runtime type name for this instance
   */
  toRawType() {
    return `Compact<${this.registry.getClassName(this.__internal__Type) || this.__internal__raw.toRawType()}>`;
  }
  /**
   * @description Returns the string representation of the value
   */
  toString() {
    return this.__internal__raw.toString();
  }
  /**
   * @description Encodes the value as a Uint8Array as per the SCALE specifications
   */
  toU8a(e) {
    return nt(this.__internal__raw.toBn());
  }
  /**
   * @description Returns the embedded [[UInt]] or [[Moment]] value
   */
  unwrap() {
    return this.__internal__raw;
  }
}
class Ao {
  constructor(e, t = "DoNotConstruct") {
    b(this, "registry");
    b(this, "createdAtHash");
    b(this, "isStorageFallback");
    b(this, "__internal__neverError");
    throw this.registry = e, this.__internal__neverError = new Error(`DoNotConstruct: Cannot construct unknown type ${t}`), this.__internal__neverError;
  }
  static with(e) {
    return class extends Ao {
      constructor(t) {
        super(t, e);
      }
    };
  }
  /**
   * @description The length of the value when encoded as a Uint8Array
   */
  get encodedLength() {
    throw this.__internal__neverError;
  }
  /**
   * @description returns a hash of the contents
   */
  get hash() {
    throw this.__internal__neverError;
  }
  /**
   * @description Checks if the value is an empty value (always true)
   */
  get isEmpty() {
    throw this.__internal__neverError;
  }
  /**
   * @description Unimplemented
   */
  eq() {
    throw this.__internal__neverError;
  }
  /**
   * @description Unimplemented
   */
  inspect() {
    throw this.__internal__neverError;
  }
  /**
   * @description Unimplemented
   */
  toHex() {
    throw this.__internal__neverError;
  }
  /**
   * @description Unimplemented
   */
  toHuman() {
    throw this.__internal__neverError;
  }
  /**
   * @description Unimplemented
   */
  toJSON() {
    throw this.__internal__neverError;
  }
  /**
   * @description Unimplemented
   */
  toPrimitive() {
    throw this.__internal__neverError;
  }
  /**
   * @description Unimplemented
   */
  toRawType() {
    throw this.__internal__neverError;
  }
  /**
   * @description Unimplemented
   */
  toString() {
    throw this.__internal__neverError;
  }
  /**
   * @description Unimplemented
   */
  toU8a() {
    throw this.__internal__neverError;
  }
}
class Yn {
  constructor(e) {
    b(this, "encodedLength", 0);
    b(this, "isEmpty", !0);
    b(this, "registry");
    b(this, "createdAtHash");
    b(this, "initialU8aLength", 0);
    b(this, "isStorageFallback");
    this.registry = e;
  }
  /**
   * @description returns a hash of the contents
   */
  get hash() {
    throw new Error(".hash is not implemented on Null");
  }
  /**
   * @description Compares the value of the input to see if there is a match
   */
  eq(e) {
    return e instanceof Yn || Mr(e);
  }
  /**
   * @description Returns a breakdown of the hex encoding for this Codec
   */
  inspect() {
    return {};
  }
  /**
   * @description Returns a hex string representation of the value
   */
  toHex() {
    return "0x";
  }
  /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */
  toHuman() {
    return this.toJSON();
  }
  /**
   * @description Converts the Object to JSON, typically used for RPC transfers
   */
  toJSON() {
    return null;
  }
  /**
   * @description Converts the value in a best-fit primitive form
   */
  toPrimitive() {
    return null;
  }
  /**
   * @description Returns the base runtime type name for this instance
   */
  toRawType() {
    return "Null";
  }
  /**
   * @description Returns the string representation of the value
   */
  toString() {
    return "";
  }
  /**
   * @description Encodes the value as a Uint8Array as per the SCALE specifications
   */
  toU8a(e) {
    return new Uint8Array();
  }
}
function Zk(n) {
  const e = Object.values(n);
  if (e.some((t) => xe(t))) {
    if (!e.every((t) => xe(t) && t >= 0 && t <= 255))
      throw new Error("Invalid number-indexed enum definition");
    return !1;
  }
  return !0;
}
function Jk(n, e) {
  const t = {};
  let r, i;
  if (Array.isArray(e)) {
    for (let s = 0, a = e.length; s < a; s++)
      t[e[s]] = { Type: Yn, index: s };
    r = !0, i = !1;
  } else if (Zk(e)) {
    const [s, a] = Pu(n, e);
    for (let o = 0, c = a.length; o < c; o++)
      t[a[o]] = { Type: s[o], index: o };
    r = !Object.values(t).some(({ Type: o }) => o !== Yn), i = !1;
  } else {
    const s = Object.entries(e);
    for (let a = 0, o = s.length; a < o; a++) {
      const [c, l] = s[a];
      t[c] = { Type: Yn, index: l };
    }
    r = !0, i = !0;
  }
  return {
    def: t,
    isBasic: r,
    isIndexed: i
  };
}
function J0(n, e) {
  const t = Object.values(n);
  for (let r = 0, i = t.length; r < i; r++) {
    const { Type: s, index: a } = t[r];
    if (a === e)
      return s;
  }
  throw new Error(`Unable to create Enum via index ${e}, in ${Object.keys(n).join(", ")}`);
}
function K0(n, e, t, r) {
  const i = J0(e, t);
  return {
    index: t,
    value: new i(n, r)
  };
}
function fs(n, e, t = 0, r) {
  const i = J0(e, t);
  return {
    index: t,
    value: r instanceof i ? r : new i(n, r)
  };
}
function Lh(n, e, t, r) {
  const i = Object.keys(e).map((o) => o.toLowerCase()), s = t.toLowerCase(), a = i.indexOf(s);
  if (a === -1)
    throw new Error(`Cannot map Enum JSON, unable to find '${t}' in ${i.join(", ")}`);
  try {
    return fs(n, e, Object.values(e)[a].index, r);
  } catch (o) {
    throw new Error(`Enum(${t}):: ${o.message}`);
  }
}
function Kk(n, e, t, r) {
  if (xe(r))
    return fs(n, e, r, t);
  if (te(t) || ye(t)) {
    const i = j(t);
    if (i.length)
      return K0(n, e, i[0], i.subarray(1));
  } else {
    if (t instanceof Ln)
      return fs(n, e, t.index, t.value);
    if (xe(t))
      return fs(n, e, t);
    if (Pe(t))
      return Lh(n, e, t.toString());
    if (qt(t)) {
      const i = Object.keys(t)[0];
      return Lh(n, e, i, t[i]);
    }
  }
  return fs(n, e, Object.values(e)[0].index);
}
class Ln {
  constructor(e, t, r, i, { definition: s, setDefinition: a = Xr } = {}) {
    b(this, "registry");
    b(this, "createdAtHash");
    b(this, "initialU8aLength");
    b(this, "isStorageFallback");
    b(this, "__internal__def");
    b(this, "__internal__entryIndex");
    b(this, "__internal__indexes");
    b(this, "__internal__isBasic");
    b(this, "__internal__isIndexed");
    b(this, "__internal__raw");
    const { def: o, isBasic: c, isIndexed: l } = s || a(Jk(e, t)), u = te(r) && r.length && !xe(i) ? K0(e, o, r[0], r.subarray(1)) : Kk(e, o, r, i);
    this.registry = e, this.__internal__def = o, this.__internal__isBasic = c, this.__internal__isIndexed = l, this.__internal__indexes = Object.values(o).map(({ index: f }) => f), this.__internal__entryIndex = this.__internal__indexes.indexOf(u.index), this.__internal__raw = u.value, this.__internal__raw.initialU8aLength && (this.initialU8aLength = 1 + this.__internal__raw.initialU8aLength);
  }
  static with(e) {
    var i;
    let t;
    const r = (s) => t = s;
    return i = class extends Ln {
      constructor(a, o, c) {
        super(a, e, o, c, { definition: t, setDefinition: r });
      }
    }, (() => {
      const a = Array.isArray(e) ? e : Object.keys(e), o = a.length, c = new Array(o), l = new Array(o);
      for (let u = 0; u < o; u++) {
        const f = fo(a[u]);
        c[u] = `as${f}`, l[u] = `is${f}`;
      }
      Hr(i.prototype, l, (u, f, m) => m.type === a[f]), Hr(i.prototype, c, (u, f, m) => {
        if (m.type !== a[f])
          throw new Error(`Cannot convert '${m.type}' via ${u}`);
        return m.value;
      });
    })(), i;
  }
  /**
   * @description The length of the value when encoded as a Uint8Array
   */
  get encodedLength() {
    return 1 + this.__internal__raw.encodedLength;
  }
  /**
   * @description returns a hash of the contents
   */
  get hash() {
    return this.registry.hash(this.toU8a());
  }
  /**
   * @description The index of the enum value
   */
  get index() {
    return this.__internal__indexes[this.__internal__entryIndex];
  }
  /**
   * @description The value of the enum
   */
  get inner() {
    return this.__internal__raw;
  }
  /**
   * @description true if this is a basic enum (no values)
   */
  get isBasic() {
    return this.__internal__isBasic;
  }
  /**
   * @description Checks if the value is an empty value
   */
  get isEmpty() {
    return this.__internal__raw.isEmpty;
  }
  /**
   * @description Checks if the Enum points to a [[Null]] type
   */
  get isNone() {
    return this.__internal__raw instanceof Yn;
  }
  /**
   * @description The available keys for this enum
   */
  get defIndexes() {
    return this.__internal__indexes;
  }
  /**
   * @description The available keys for this enum
   */
  get defKeys() {
    return Object.keys(this.__internal__def);
  }
  /**
   * @description The name of the type this enum value represents
   */
  get type() {
    return this.defKeys[this.__internal__entryIndex];
  }
  /**
   * @description The value of the enum
   */
  get value() {
    return this.__internal__raw;
  }
  /**
   * @description Compares the value of the input to see if there is a match
   */
  eq(e) {
    return te(e) ? !this.toU8a().some((t, r) => t !== e[r]) : xe(e) ? this.toNumber() === e : this.__internal__isBasic && Pe(e) ? this.type === e : ye(e) ? this.toHex() === e : e instanceof Ln ? this.index === e.index && this.value.eq(e.value) : qt(e) ? this.value.eq(e[this.type]) : this.value.eq(e);
  }
  /**
   * @description Returns a breakdown of the hex encoding for this Codec
   */
  inspect() {
    if (this.__internal__isBasic)
      return { outer: [new Uint8Array([this.index])] };
    const { inner: e, outer: t = [] } = this.__internal__raw.inspect();
    return {
      inner: e,
      outer: [new Uint8Array([this.index]), ...t]
    };
  }
  /**
   * @description Returns a hex string representation of the value
   */
  toHex() {
    return pe(this.toU8a());
  }
  /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */
  toHuman(e) {
    return this.__internal__isBasic || this.isNone ? this.type : { [this.type]: this.__internal__raw.toHuman(e) };
  }
  /**
   * @description Converts the Object to JSON, typically used for RPC transfers
   */
  toJSON() {
    return this.__internal__isBasic ? this.type : { [Ee(this.type)]: this.__internal__raw.toJSON() };
  }
  /**
   * @description Returns the number representation for the value
   */
  toNumber() {
    return this.index;
  }
  /**
   * @description Converts the value in a best-fit primitive form
   */
  toPrimitive() {
    return this.__internal__isBasic ? this.type : { [Ee(this.type)]: this.__internal__raw.toPrimitive() };
  }
  /**
   * @description Returns a raw struct representation of the enum types
   */
  _toRawStruct() {
    if (this.__internal__isBasic)
      return this.__internal__isIndexed ? this.defKeys.reduce((t, r, i) => (t[r] = this.__internal__indexes[i], t), {}) : this.defKeys;
    const e = Object.entries(this.__internal__def);
    return bg(this.registry, e.reduce((t, [r, { Type: i }], s) => (t[0][s] = i, t[1][s] = r, t), [new Array(e.length), new Array(e.length)]));
  }
  /**
   * @description Returns the base runtime type name for this instance
   */
  toRawType() {
    return _e({ _enum: this._toRawStruct() });
  }
  /**
   * @description Returns the string representation of the value
   */
  toString() {
    return this.isNone ? this.type : _e(this.toJSON());
  }
  /**
   * @description Encodes the value as a Uint8Array as per the SCALE specifications
   * @param isBare true when the value has none of the type-specific prefixes (internal)
   */
  toU8a(e) {
    return e ? this.__internal__raw.toU8a(e) : Wt([
      new Uint8Array([this.index]),
      this.__internal__raw.toU8a(e)
    ]);
  }
}
class br extends Z0 {
  constructor(e, t = 0, r) {
    super(e, t, r, !0);
  }
  static with(e, t) {
    return class extends br {
      constructor(r, i) {
        super(r, i, e);
      }
      toRawType() {
        return t || super.toRawType();
      }
    };
  }
}
class xi extends Yn {
  /**
   * @description Returns the base runtime type name for this instance
   */
  toRawType() {
    return "None";
  }
}
function Yk(n, e, t) {
  return t instanceof e ? t : t instanceof yr ? t.value instanceof e ? t.value : t.isNone ? new xi(n) : new e(n, t.value) : Mr(t) || Ne(t) || t === "0x" || t instanceof xi ? new xi(n) : te(t) ? !t.length || t[0] === 0 ? new xi(n) : new e(n, t.subarray(1)) : new e(n, t);
}
class yr {
  constructor(e, t, r, { definition: i, setDefinition: s = Xr } = {}) {
    b(this, "registry");
    b(this, "createdAtHash");
    b(this, "initialU8aLength");
    b(this, "isStorageFallback");
    b(this, "__internal__Type");
    b(this, "__internal__raw");
    const a = i || s(Mn(e, t)), o = te(r) && r.length && !Jn(r) ? r[0] === 0 ? new xi(e) : new a(e, r.subarray(1)) : Yk(e, a, r);
    this.registry = e, this.__internal__Type = a, this.__internal__raw = o, o != null && o.initialU8aLength && (this.initialU8aLength = 1 + o.initialU8aLength);
  }
  static with(e) {
    let t;
    const r = (i) => (t = i, i);
    return class extends yr {
      constructor(i, s) {
        super(i, e, s, { definition: t, setDefinition: r });
      }
    };
  }
  /**
   * @description The length of the value when encoded as a Uint8Array
   */
  get encodedLength() {
    return 1 + this.__internal__raw.encodedLength;
  }
  /**
   * @description returns a hash of the contents
   */
  get hash() {
    return this.registry.hash(this.toU8a());
  }
  /**
   * @description Checks if the Option has no value
   */
  get isEmpty() {
    return this.isNone;
  }
  /**
   * @description Checks if the Option has no value
   */
  get isNone() {
    return this.__internal__raw instanceof xi;
  }
  /**
   * @description Checks if the Option has a value
   */
  get isSome() {
    return !this.isNone;
  }
  /**
   * @description The actual value for the Option
   */
  get value() {
    return this.__internal__raw;
  }
  /**
   * @description Compares the value of the input to see if there is a match
   */
  eq(e) {
    return e instanceof yr ? this.isSome === e.isSome && this.value.eq(e.value) : this.value.eq(e);
  }
  /**
   * @description Returns a breakdown of the hex encoding for this Codec
   */
  inspect() {
    if (this.isNone)
      return { outer: [new Uint8Array([0])] };
    const { inner: e, outer: t = [] } = this.__internal__raw.inspect();
    return {
      inner: e,
      outer: [new Uint8Array([1]), ...t]
    };
  }
  /**
   * @description Returns a hex string representation of the value
   */
  toHex() {
    return this.isNone ? "0x" : pe(this.toU8a().subarray(1));
  }
  /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */
  toHuman(e) {
    return this.__internal__raw.toHuman(e);
  }
  /**
   * @description Converts the Object to JSON, typically used for RPC transfers
   */
  toJSON() {
    return this.isNone ? null : this.__internal__raw.toJSON();
  }
  /**
   * @description Converts the value in a best-fit primitive form
   */
  toPrimitive() {
    return this.isNone ? null : this.__internal__raw.toPrimitive();
  }
  /**
   * @description Returns the base runtime type name for this instance
   */
  toRawType(e) {
    const t = this.registry.getClassName(this.__internal__Type) || new this.__internal__Type(this.registry).toRawType();
    return e ? t : `Option<${t}>`;
  }
  /**
   * @description Returns the string representation of the value
   */
  toString() {
    return this.__internal__raw.toString();
  }
  /**
   * @description Encodes the value as a Uint8Array as per the SCALE specifications
   * @param isBare true when the value has none of the type-specific prefixes (internal)
   */
  toU8a(e) {
    if (e)
      return this.__internal__raw.toU8a(!0);
    const t = new Uint8Array(this.encodedLength);
    return this.isSome && (t.set([1]), t.set(this.__internal__raw.toU8a(), 1)), t;
  }
  /**
   * @description Returns the value that the Option represents (if available), throws if null
   */
  unwrap() {
    if (this.isNone)
      throw new Error("Option: unwrapping a None value");
    return this.__internal__raw;
  }
  /**
   * @description Returns the value that the Option represents (if available) or defaultValue if none
   * @param defaultValue The value to return if the option isNone
   */
  unwrapOr(e) {
    return this.isSome ? this.unwrap() : e;
  }
  /**
   * @description Returns the value that the Option represents (if available) or defaultValue if none
   * @param defaultValue The value to return if the option isNone
   */
  unwrapOrDefault() {
    return this.isSome ? this.unwrap() : new this.__internal__Type(this.registry);
  }
}
let Qk = class Y0 extends Ln {
  constructor(e, t, r, i) {
    super(e, { Ok: t, Err: r }, i);
  }
  static with(e) {
    return class extends Y0 {
      constructor(t, r) {
        super(t, e.Ok, e.Err, r);
      }
    };
  }
  /**
   * @description Returns the wrapper Err value (if isErr)
   */
  get asErr() {
    if (!this.isErr)
      throw new Error("Cannot extract Err value from Ok result, check isErr first");
    return this.value;
  }
  /**
   * @description Returns the wrapper Ok value (if isOk)
   */
  get asOk() {
    if (!this.isOk)
      throw new Error("Cannot extract Ok value from Err result, check isOk first");
    return this.value;
  }
  /**
   * @description Checks if the Result has no value
   */
  get isEmpty() {
    return this.isOk && this.value.isEmpty;
  }
  /**
   * @description Checks if the Result wraps an Err value
   */
  get isErr() {
    return !this.isOk;
  }
  /**
   * @description Checks if the Result wraps an Ok value
   */
  get isOk() {
    return this.index === 0;
  }
  /**
   * @description Returns the base runtime type name for this instance
   */
  toRawType() {
    const e = this._toRawStruct();
    return `Result<${e.Ok},${e.Err}>`;
  }
};
function $k(n, e, t, r) {
  if (Array.isArray(t)) {
    const i = r[0];
    for (let s = 0, a = i.length; s < a; s++)
      try {
        const o = t == null ? void 0 : t[s];
        e[s] = o instanceof i[s] ? o : new i[s](n, o);
      } catch (o) {
        throw new Error(`Tuple: failed on ${s}:: ${o.message}`);
      }
    return [e, 0];
  } else {
    if (ye(t))
      return Eu(n, e, j(t), r);
    if (!t || !e.length) {
      const i = r[0];
      for (let s = 0, a = i.length; s < a; s++)
        e[s] = new i[s](n);
      return [e, 0];
    }
  }
  throw new Error(`Expected array input to Tuple decoding, found ${typeof t}: ${_e(t)}`);
}
class qi extends Eo {
  constructor(t, r, i, { definition: s, setDefinition: a = Xr } = {}) {
    const o = s || a(Array.isArray(r) ? [dw(t, r), []] : ue(r) || Pe(r) ? [[Mn(t, r)], []] : Pu(t, r));
    super(t, o[0].length);
    b(this, "__internal__Types");
    this.initialU8aLength = (te(i) ? Eu(t, this, i, o) : $k(t, this, i, o))[1], this.__internal__Types = o;
  }
  static with(t) {
    let r;
    const i = (s) => r = s;
    return class extends qi {
      constructor(s, a) {
        super(s, t, a, { definition: r, setDefinition: i });
      }
    };
  }
  /**
   * @description The length of the value when encoded as a Uint8Array
   */
  get encodedLength() {
    let t = 0;
    for (let r = 0, i = this.length; r < i; r++)
      t += this[r].encodedLength;
    return t;
  }
  /**
   * @description The types definition of the tuple
   */
  get Types() {
    return this.__internal__Types[1].length ? this.__internal__Types[1] : this.__internal__Types[0].map((t) => new t(this.registry).toRawType());
  }
  /**
   * @description Returns a breakdown of the hex encoding for this Codec
   */
  inspect() {
    return {
      inner: this.inspectInner()
    };
  }
  /**
   * @description Returns the base runtime type name for this instance
   */
  toRawType() {
    return `(${this.__internal__Types[0].map((r) => this.registry.getClassName(r) || new r(this.registry).toRawType()).join(",")})`;
  }
  /**
   * @description Returns the string representation of the value
   */
  toString() {
    return _e(this.toJSON());
  }
  /**
   * @description Encodes the value as a Uint8Array as per the SCALE specifications
   * @param isBare true when the value has none of the type-specific prefixes (internal)
   */
  toU8a(t) {
    return Wt(this.toU8aInner(t));
  }
}
class wr extends Z0 {
  static with(e, t) {
    return class extends wr {
      constructor(r, i) {
        super(r, i, e);
      }
      toRawType() {
        return t || super.toRawType();
      }
    };
  }
}
const Dh = 64 * 1024, eT = Qt("Vec");
function tT(n) {
  if (Array.isArray(n))
    return [n, n.length, 0];
  if (te(n) || ye(n)) {
    const e = j(n), [t, r] = qr(e);
    if (r > Dh)
      throw new Error(`Vec length ${r.toString()} exceeds ${Dh}`);
    return [e, r, t];
  } else if (!n)
    return [null, 0, 0];
  throw new Error(`Expected array/hex input to Vec<*> decoding, found ${typeof n}: ${_e(n)}`);
}
function Q0(n, e, t, r, i) {
  if (Array.isArray(t)) {
    const s = e.length;
    for (let a = 0; a < s; a++) {
      const o = t[a];
      try {
        e[a] = o instanceof i ? o : new i(n, o);
      } catch (c) {
        throw eT.error(`Unable to decode on index ${a}`, c.message), c;
      }
    }
    return [0, 0];
  } else if (!t)
    return [0, 0];
  return po(n, e, j(t), r, i);
}
class rd extends Eo {
  constructor(t, r, i = [], { definition: s, setDefinition: a = Xr } = {}) {
    const [o, c, l] = tT(i);
    super(t, c);
    b(this, "__internal__Type");
    this.__internal__Type = s || a(Mn(t, r)), this.initialU8aLength = (te(o) ? po(t, this, o, l, this.__internal__Type) : Q0(t, this, o, l, this.__internal__Type))[0];
  }
  static with(t) {
    let r;
    const i = (s) => r = s;
    return class extends rd {
      constructor(s, a) {
        super(s, t, a, { definition: r, setDefinition: i });
      }
    };
  }
  /**
   * @description The type for the items
   */
  get Type() {
    return this.__internal__Type.name;
  }
  /**
   * @description Finds the index of the value in the array
   */
  indexOf(t) {
    const r = t instanceof this.__internal__Type ? t : new this.__internal__Type(this.registry, t);
    for (let i = 0, s = this.length; i < s; i++)
      if (r.eq(this[i]))
        return i;
    return -1;
  }
  /**
   * @description Returns the base runtime type name for this instance
   */
  toRawType() {
    return `Vec<${this.registry.getClassName(this.__internal__Type) || new this.__internal__Type(this.registry).toRawType()}>`;
  }
}
class id extends Eo {
  constructor(t, r, i, s = [], { definition: a, setDefinition: o = Xr } = {}) {
    super(t, i);
    b(this, "__internal__Type");
    this.__internal__Type = a || o(Mn(t, r)), this.initialU8aLength = (te(s) ? po(t, this, s, 0, this.__internal__Type) : Q0(t, this, s, 0, this.__internal__Type))[1];
  }
  static with(t, r) {
    let i;
    const s = (a) => i = a;
    return class extends id {
      constructor(a, o) {
        super(a, t, r, o, { definition: i, setDefinition: s });
      }
    };
  }
  /**
   * @description The type for the items
   */
  get Type() {
    return new this.__internal__Type(this.registry).toRawType();
  }
  /**
   * @description The length of the value when encoded as a Uint8Array
   */
  get encodedLength() {
    let t = 0;
    for (let r = 0, i = this.length; r < i; r++)
      t += this[r].encodedLength;
    return t;
  }
  /**
   * @description Returns a breakdown of the hex encoding for this Codec
   */
  inspect() {
    return {
      inner: this.inspectInner()
    };
  }
  toU8a() {
    const t = this.toU8aInner();
    return t.length ? Wt(t) : new Uint8Array([]);
  }
  /**
   * @description Returns the base runtime type name for this instance
   */
  toRawType() {
    return `[${this.Type};${this.length}]`;
  }
}
function nT(n) {
  if (!(n != null && n.length))
    return [0, new Uint8Array()];
  const [e, t] = qr(n), r = e + Math.ceil(t / 8);
  if (r > n.length)
    throw new Error(`BitVec: required length less than remainder, expected at least ${r}, found ${n.length}`);
  return [t, n.subarray(e, r)];
}
function rT(n) {
  if (Array.isArray(n) || Pe(n)) {
    const e = j(n);
    return [e.length / 8, e];
  }
  return nT(n);
}
class iT extends bn {
  // In lieu of having the Msb/Lsb identifiers passed through, we default to assuming
  // we are dealing with Lsb, which is the default (as of writing) BitVec format used
  // in the Polkadot code (this only affects the toHuman displays)
  constructor(t, r, i = !1) {
    const [s, a] = rT(r);
    super(t, a);
    b(this, "__internal__decodedLength");
    b(this, "__internal__isMsb");
    this.__internal__decodedLength = s, this.__internal__isMsb = i;
  }
  /**
   * @description The length of the value when encoded as a Uint8Array
   */
  get encodedLength() {
    return this.length + nt(this.__internal__decodedLength).length;
  }
  /**
   * @description Returns a breakdown of the hex encoding for this Codec
   */
  inspect() {
    return {
      outer: [nt(this.__internal__decodedLength), super.toU8a()]
    };
  }
  /**
   * @description Creates a boolean array of the bit values
   */
  toBoolArray() {
    const t = [...this.toU8a(!0)].map((s) => [
      !!(s & 128),
      !!(s & 64),
      !!(s & 32),
      !!(s & 16),
      !!(s & 8),
      !!(s & 4),
      !!(s & 2),
      !!(s & 1)
    ]), r = t.length, i = new Array(8 * r);
    for (let s = 0; s < r; s++) {
      const a = s * 8, o = t[s];
      for (let c = 0; c < 8; c++)
        i[a + c] = this.__internal__isMsb ? o[c] : o[7 - c];
    }
    return i;
  }
  /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */
  toHuman() {
    return `0b${[...this.toU8a(!0)].map((t) => `00000000${t.toString(2)}`.slice(-8)).map((t) => this.__internal__isMsb ? t : t.split("").reverse().join("")).join("_")}`;
  }
  /**
   * @description Returns the base runtime type name for this instance
   */
  toRawType() {
    return "BitVec";
  }
  /**
   * @description Encodes the value as a Uint8Array as per the SCALE specifications
   * @param isBare true when the value has none of the type-specific prefixes (internal)
   */
  toU8a(t) {
    const r = super.toU8a(t);
    return t ? r : Wt([nt(this.__internal__decodedLength), r]);
  }
}
const sT = Qt("Map");
function aT(n, e, t, r) {
  const i = /* @__PURE__ */ new Map(), [s, a] = qr(r), o = [];
  for (let u = 0; u < a; u++)
    o.push(e, t);
  const [c, l] = Eu(n, new Array(o.length), r.subarray(s), [o, []]);
  for (let u = 0, f = c.length; u < f; u += 2)
    i.set(c[u], c[u + 1]);
  return [e, t, i, s + l];
}
function Uh(n, e, t, r) {
  const i = /* @__PURE__ */ new Map();
  for (const [s, a] of r.entries()) {
    const o = e.prototype instanceof Eo || e.prototype instanceof Dt || e.prototype instanceof Ln;
    try {
      i.set(s instanceof e ? s : new e(n, o && typeof s == "string" ? JSON.parse(s) : s), a instanceof t ? a : new t(n, a));
    } catch (c) {
      throw sT.error("Failed to decode key or value:", c.message), c;
    }
  }
  return [e, t, i, 0];
}
function oT(n, e, t, r) {
  const i = Mn(n, e), s = Mn(n, t);
  if (r) {
    if (te(r) || ye(r))
      return aT(n, i, s, j(r));
    if (r instanceof Map)
      return Uh(n, i, s, r);
    if (qt(r))
      return Uh(n, i, s, new Map(Object.entries(r)));
  } else
    return [i, s, /* @__PURE__ */ new Map(), 0];
  throw new Error("Map: cannot decode type");
}
class $0 extends Map {
  constructor(t, r, i, s, a = "HashMap") {
    const [o, c, l, u] = oT(t, r, i, s);
    super(a === "BTreeMap" ? uw(l) : l);
    b(this, "registry");
    b(this, "createdAtHash");
    b(this, "initialU8aLength");
    b(this, "isStorageFallback");
    b(this, "__internal__KeyClass");
    b(this, "__internal__ValClass");
    b(this, "__internal__type");
    this.registry = t, this.initialU8aLength = u, this.__internal__KeyClass = o, this.__internal__ValClass = c, this.__internal__type = a;
  }
  /**
   * @description The length of the value when encoded as a Uint8Array
   */
  get encodedLength() {
    let t = nt(this.size).length;
    for (const [r, i] of this.entries())
      t += r.encodedLength + i.encodedLength;
    return t;
  }
  /**
   * @description Returns a hash of the value
   */
  get hash() {
    return this.registry.hash(this.toU8a());
  }
  /**
   * @description Checks if the value is an empty value
   */
  get isEmpty() {
    return this.size === 0;
  }
  /**
   * @description Compares the value of the input to see if there is a match
   */
  eq(t) {
    return xu(this, t);
  }
  /**
   * @description Returns a breakdown of the hex encoding for this Codec
   */
  inspect() {
    const t = [];
    for (const [r, i] of this.entries())
      t.push(r.inspect()), t.push(i.inspect());
    return {
      inner: t,
      outer: [nt(this.size)]
    };
  }
  /**
   * @description Returns a hex string representation of the value. isLe returns a LE (number-only) representation
   */
  toHex() {
    return pe(this.toU8a());
  }
  /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */
  toHuman(t) {
    const r = {};
    for (const [i, s] of this.entries())
      r[i instanceof bn && i.isAscii ? i.toUtf8() : i.toString()] = s.toHuman(t);
    return r;
  }
  /**
   * @description Converts the Object to JSON, typically used for RPC transfers
   */
  toJSON() {
    const t = {};
    for (const [r, i] of this.entries())
      t[r.toString()] = i.toJSON();
    return t;
  }
  /**
   * @description Converts the value in a best-fit primitive form
   */
  toPrimitive() {
    const t = {};
    for (const [r, i] of this.entries())
      t[r instanceof bn && r.isAscii ? r.toUtf8() : r.toString()] = i.toPrimitive();
    return t;
  }
  /**
   * @description Returns the base runtime type name for this instance
   */
  toRawType() {
    return `${this.__internal__type}<${this.registry.getClassName(this.__internal__KeyClass) || new this.__internal__KeyClass(this.registry).toRawType()},${this.registry.getClassName(this.__internal__ValClass) || new this.__internal__ValClass(this.registry).toRawType()}>`;
  }
  /**
   * @description Returns the string representation of the value
   */
  toString() {
    return _e(this.toJSON());
  }
  /**
   * @description Encodes the value as a Uint8Array as per the SCALE specifications
   * @param isBare true when the value has none of the type-specific prefixes (internal)
   */
  toU8a(t) {
    const r = [];
    t || r.push(nt(this.size));
    for (const [i, s] of this.entries())
      r.push(i.toU8a(t), s.toU8a(t));
    return Wt(r);
  }
}
class sd extends $0 {
  static with(e, t) {
    return class extends sd {
      constructor(r, i) {
        super(r, e, t, i, "BTreeMap");
      }
    };
  }
}
const cT = Qt("BTreeSet");
function lT(n, e, t) {
  const r = /* @__PURE__ */ new Set(), [i, s] = qr(t), a = new Array(s), [o] = po(n, a, t, i, e);
  for (let c = 0; c < s; c++)
    r.add(a[c]);
  return [e, r, o];
}
function uT(n, e, t) {
  const r = /* @__PURE__ */ new Set();
  return t.forEach((i) => {
    try {
      r.add(i instanceof e ? i : new e(n, i));
    } catch (s) {
      throw cT.error("Failed to decode key or value:", s.message), s;
    }
  }), [e, r, 0];
}
function dT(n, e, t) {
  const r = Mn(n, e);
  if (t) {
    if (te(t) || ye(t))
      return lT(n, r, j(t));
    if (Array.isArray(t) || t instanceof Set)
      return uT(n, r, t);
  } else
    return [r, /* @__PURE__ */ new Set(), 0];
  throw new Error("BTreeSet: cannot decode type");
}
class ad extends Set {
  constructor(t, r, i) {
    const [s, a, o] = dT(t, r, i);
    super(lw(a));
    b(this, "registry");
    b(this, "createdAtHash");
    b(this, "initialU8aLength");
    b(this, "isStorageFallback");
    b(this, "__internal__ValClass");
    this.registry = t, this.initialU8aLength = o, this.__internal__ValClass = s;
  }
  static with(t) {
    return class extends ad {
      constructor(r, i) {
        super(r, t, i);
      }
    };
  }
  /**
   * @description The length of the value when encoded as a Uint8Array
   */
  get encodedLength() {
    let t = nt(this.size).length;
    for (const r of this.values())
      t += r.encodedLength;
    return t;
  }
  /**
   * @description Returns a hash of the value
   */
  get hash() {
    return this.registry.hash(this.toU8a());
  }
  /**
   * @description Checks if the value is an empty value
   */
  get isEmpty() {
    return this.size === 0;
  }
  /**
   * @description The actual set values as a string[]
   */
  get strings() {
    return [...super.values()].map((t) => t.toString());
  }
  /**
   * @description Compares the value of the input to see if there is a match
   */
  eq(t) {
    return Yb(this, t);
  }
  /**
   * @description Returns a breakdown of the hex encoding for this Codec
   */
  inspect() {
    const t = [];
    for (const r of this.values())
      t.push(r.inspect());
    return {
      inner: t,
      outer: [nt(this.size)]
    };
  }
  /**
   * @description Returns a hex string representation of the value. isLe returns a LE (number-only) representation
   */
  toHex() {
    return pe(this.toU8a());
  }
  /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */
  toHuman(t) {
    const r = [];
    for (const i of this.values())
      r.push(i.toHuman(t));
    return r;
  }
  /**
   * @description Converts the Object to JSON, typically used for RPC transfers
   */
  toJSON() {
    const t = [];
    for (const r of this.values())
      t.push(r.toJSON());
    return t;
  }
  /**
   * @description Returns the base runtime type name for this instance
   */
  toRawType() {
    return `BTreeSet<${this.registry.getClassName(this.__internal__ValClass) || new this.__internal__ValClass(this.registry).toRawType()}>`;
  }
  /**
   * @description Converts the value in a best-fit primitive form
   */
  toPrimitive() {
    const t = [];
    for (const r of this.values())
      t.push(r.toPrimitive());
    return t;
  }
  /**
   * @description Returns the string representation of the value
   */
  toString() {
    return _e(this.toJSON());
  }
  /**
   * @description Encodes the value as a Uint8Array as per the SCALE specifications
   * @param isBare true when the value has none of the type-specific prefixes (internal)
   */
  toU8a(t) {
    const r = [];
    t || r.push(nt(this.size));
    for (const i of this.values())
      r.push(i.toU8a(t));
    return Wt(r);
  }
}
const Vh = 10 * 1024 * 1024;
function fT(n) {
  if (!n.length)
    return [new Uint8Array(), 0];
  const [e, t] = qr(n), r = e + t;
  if (t > Vh)
    throw new Error(`Bytes length ${t.toString()} exceeds ${Vh}`);
  if (r > n.length)
    throw new Error(`Bytes: required length less than remainder, expected at least ${r}, found ${n.length}`);
  return [n.subarray(e, r), r];
}
class Xs extends bn {
  constructor(e, t) {
    const [r, i] = te(t) && !(t instanceof bn) ? fT(t) : Array.isArray(t) || Pe(t) ? [j(t), 0] : [t, 0];
    super(e, r, i);
  }
  /**
   * @description The length of the value when encoded as a Uint8Array
   */
  get encodedLength() {
    return this.length + nt(this.length).length;
  }
  /**
   * @description Returns a breakdown of the hex encoding for this Codec
   */
  inspect(e) {
    const t = nt(this.length);
    return {
      outer: e ? [super.toU8a()] : this.length ? [t, super.toU8a()] : [t]
    };
  }
  /**
   * @description Returns the base runtime type name for this instance
   */
  toRawType() {
    return "Bytes";
  }
  /**
   * @description Encodes the value as a Uint8Array as per the SCALE specifications
   * @param isBare true when the value has none of the type-specific prefixes (internal)
   */
  toU8a(e) {
    return e ? super.toU8a(e) : wn(this);
  }
}
class od extends $0 {
  static with(e, t) {
    return class extends od {
      constructor(r, i) {
        super(r, e, t, i);
      }
    };
  }
}
function hT(n, e) {
  return e[0] === 0 ? null : new Mi(n, e[0] === 1);
}
class pT extends yr {
  constructor(e, t) {
    super(e, Mi, te(t) || ye(t) ? hT(e, j(t)) : t), this.initialU8aLength = 1;
  }
  /**
   * @description The length of the value when encoded as a Uint8Array
   */
  get encodedLength() {
    return 1;
  }
  /**
   * @description Checks if the value is an empty value (always false)
   */
  get isFalse() {
    return this.isSome ? !this.value.valueOf() : !1;
  }
  /**
   * @description Checks if the value is an empty value (always false)
   */
  get isTrue() {
    return this.isSome ? this.value.valueOf() : !1;
  }
  /**
   * @description Returns a breakdown of the hex encoding for this Codec
   */
  inspect() {
    return { outer: [this.toU8a()] };
  }
  /**
   * @description Returns the base runtime type name for this instance
   */
  toRawType(e) {
    return e ? "bool" : "Option<bool>";
  }
  /**
   * @description Encodes the value as a Uint8Array as per the SCALE specifications
   * @param isBare true when the value has none of the type-specific prefixes (internal)
   */
  toU8a(e) {
    return e ? super.toU8a(!0) : this.isSome ? new Uint8Array([this.isTrue ? 1 : 2]) : new Uint8Array([0]);
  }
}
class Po extends qi {
  constructor(t, r, i, { rangeName: s = "Range" } = {}) {
    super(t, [r, r], i);
    b(this, "__internal__rangeName");
    this.__internal__rangeName = s;
  }
  static with(t) {
    return class extends Po {
      constructor(r, i) {
        super(r, t, i);
      }
    };
  }
  /**
   * @description Returns the starting range value
   */
  get start() {
    return this[0];
  }
  /**
   * @description Returns the ending range value
   */
  get end() {
    return this[1];
  }
  /**
   * @description Returns the base runtime type name for this instance
   */
  toRawType() {
    return `${this.__internal__rangeName}<${this.start.toRawType()}>`;
  }
}
class cd extends Po {
  constructor(e, t, r) {
    super(e, t, r, { rangeName: "RangeInclusive" });
  }
  static with(e) {
    return class extends cd {
      constructor(t, r) {
        super(t, e, r);
      }
    };
  }
}
class mT extends Tu {
  constructor(e, t = "") {
    super(e, t), this.setOverride(La(this.toString()));
  }
  /**
   * @description Returns the base runtime type name for this instance
   */
  toRawType() {
    return "Type";
  }
}
function gT(n, e) {
  const t = j(n), r = e / 8;
  if (!t.length)
    return [new Uint8Array(r), 0];
  if (te(n) ? t.length < r : t.length !== r)
    throw new Error(`Expected input with ${r} bytes (${e} bits), found ${t.length} bytes`);
  return [t.subarray(0, r), r];
}
class Zr extends bn {
  constructor(e, t = new Uint8Array(), r = 256) {
    const [i, s] = gT(t, r);
    super(e, i, s);
  }
  static with(e, t) {
    return class extends Zr {
      constructor(r, i) {
        super(r, i, e);
      }
      toRawType() {
        return t || super.toRawType();
      }
    };
  }
  /**
   * @description Returns the base runtime type name for this instance
   */
  toRawType() {
    return `[u8;${this.length}]`;
  }
}
function yT(n, e, t) {
  const r = Mn(n, e);
  if (te(t) || ye(t))
    try {
      const [, s] = ye(t) ? [0, j(t)] : t instanceof bn ? [0, t.subarray()] : Ri(t);
      return [r, new r(n, s), t];
    } catch {
      return [r, null, t];
    }
  const i = new r(n, t);
  return [r, i, wn(i.toU8a())];
}
class ko extends Xs {
  constructor(t, r, i, { opaqueName: s = "WrapperKeepOpaque" } = {}) {
    const [a, o, c] = yT(t, r, i);
    super(t, c);
    b(this, "__internal__Type");
    b(this, "__internal__decoded");
    b(this, "__internal__opaqueName");
    this.__internal__Type = a, this.__internal__decoded = o, this.__internal__opaqueName = s;
  }
  static with(t) {
    return class extends ko {
      constructor(r, i) {
        super(r, t, i);
      }
    };
  }
  /**
   * @description Checks if the wrapper is decodable
   */
  get isDecoded() {
    return !!this.__internal__decoded;
  }
  /**
   * @description Returns a breakdown of the hex encoding for this Codec
   */
  inspect() {
    return this.__internal__decoded ? {
      inner: [this.__internal__decoded.inspect()],
      outer: [nt(this.length)]
    } : {
      outer: [nt(this.length), this.toU8a(!0)]
    };
  }
  /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */
  toHuman(t) {
    return this.__internal__decoded ? this.__internal__decoded.toHuman(t) : super.toHuman();
  }
  /**
   * @description Converts the value in a best-fit primitive form
   */
  toPrimitive() {
    return this.__internal__decoded ? this.__internal__decoded.toPrimitive() : super.toPrimitive();
  }
  /**
   * @description Returns the base runtime type name for this instance
   */
  toRawType() {
    return `${this.__internal__opaqueName}<${this.registry.getClassName(this.__internal__Type) || (this.__internal__decoded ? this.__internal__decoded.toRawType() : new this.__internal__Type(this.registry).toRawType())}>`;
  }
  /**
   * @description Converts the Object to to a string (either decoded or bytes)
   */
  toString() {
    return this.__internal__decoded ? this.__internal__decoded.toString() : super.toString();
  }
  /**
   * @description Returns the decoded that the WrapperKeepOpaque represents (if available), throws if non-decodable
   */
  unwrap() {
    if (!this.__internal__decoded)
      throw new Error(`${this.__internal__opaqueName}: unwrapping an undecodable value`);
    return this.__internal__decoded;
  }
}
class ld extends ko {
  constructor(e, t, r) {
    super(e, t, r, { opaqueName: "WrapperOpaque" });
  }
  static with(e) {
    return class extends ld {
      constructor(t, r) {
        super(t, e, r);
      }
    };
  }
  /**
   * @description The inner value for this wrapper, in all cases it _should_ be decodable (unlike KeepOpaque)
   */
  get inner() {
    return this.unwrap();
  }
}
class Bh extends ho.with(32) {
  constructor() {
    super(...arguments);
    // NOTE without this, we cannot properly determine extensions
    b(this, "__FloatType", "f32");
  }
}
class Hh extends ho.with(64) {
  constructor() {
    super(...arguments);
    // NOTE without this, we cannot properly determine extensions
    b(this, "__FloatType", "f64");
  }
}
class Fh extends br.with(8) {
  constructor() {
    super(...arguments);
    // NOTE without this, we cannot properly determine extensions
    b(this, "__IntType", "i8");
  }
}
class jh extends br.with(16) {
  constructor() {
    super(...arguments);
    // NOTE without this, we cannot properly determine extensions
    b(this, "__IntType", "i16");
  }
}
class Vl extends br.with(32) {
  constructor() {
    super(...arguments);
    // NOTE without this, we cannot properly determine extensions
    b(this, "__IntType", "i32");
  }
}
class Wh extends br.with(64) {
  constructor() {
    super(...arguments);
    // NOTE without this, we cannot properly determine extensions
    b(this, "__IntType", "i64");
  }
}
class qh extends br.with(128) {
  constructor() {
    super(...arguments);
    // NOTE without this, we cannot properly determine extensions
    b(this, "__IntType", "i128");
  }
}
class zh extends br.with(256) {
  constructor() {
    super(...arguments);
    // NOTE without this, we cannot properly determine extensions
    b(this, "__IntType", "i256");
  }
}
class Xh extends Vl {
  constructor(e, t) {
    throw super(e, t), new Error("The `isize` type should not be used. Since it is platform-specific, it creates incompatibilities between native (generally i64) and WASM (always i32) code. Use one of the `i32` or `i64` types explicitly.");
  }
}
class Gh extends wr.with(8) {
  constructor() {
    super(...arguments);
    // NOTE without this, we cannot properly determine extensions
    b(this, "__UIntType", "u8");
  }
}
class Zh extends wr.with(16) {
  constructor() {
    super(...arguments);
    // NOTE without this, we cannot properly determine extensions
    b(this, "__UIntType", "u16");
  }
}
class Ts extends wr.with(32) {
  constructor() {
    super(...arguments);
    // NOTE without this, we cannot properly determine extensions
    b(this, "__UIntType", "u32");
  }
}
class vn extends wr.with(64) {
  constructor() {
    super(...arguments);
    // NOTE without this, we cannot properly determine extensions
    b(this, "__UIntType", "u64");
  }
}
class Jh extends wr.with(128) {
  constructor() {
    super(...arguments);
    // NOTE without this, we cannot properly determine extensions
    b(this, "__UIntType", "u128");
  }
}
class Kh extends wr.with(256) {
  constructor() {
    super(...arguments);
    // NOTE without this, we cannot properly determine extensions
    b(this, "__UIntType", "u256");
  }
}
class Yh extends Ts {
  constructor(e, t) {
    throw super(e, t), new Error("The `usize` type should not be used. Since it is platform-specific, it creates incompatibilities between native (generally u64) and WASM (always u32) code. Use one of the `u32` or `u64` types explicitly.");
  }
}
function _T(n) {
  const e = [];
  let t = 0, r = 0, i = 0, s = 0, a = 0;
  for (let o = 0, c = n.length; o < c; o++)
    switch (n[o]) {
      case ",": {
        t || r || i || s || (e.push(n.substring(a, o).trim()), a = o + 1);
        break;
      }
      case "<":
        t++;
        break;
      case ">":
        t--;
        break;
      case "[":
        r++;
        break;
      case "]":
        r--;
        break;
      case "{":
        i++;
        break;
      case "}":
        i--;
        break;
      case "(":
        s++;
        break;
      case ")":
        s--;
        break;
    }
  if (t || r || i || s)
    throw new Error(`Invalid definition (missing terminators) found in ${n}`);
  return e.push(n.substring(a, n.length).trim()), e;
}
const vT = ["_alias", "_fallback"];
function e_(n) {
  return Pe(n) ? n.toString() : _e(n);
}
function bT(n) {
  const e = Object.values(n);
  if (e.some((t) => xe(t))) {
    if (!e.every((t) => xe(t) && t >= 0 && t <= 255))
      throw new Error("Invalid number-indexed enum definition");
    return !1;
  }
  return !0;
}
function wT(n, e, t, r) {
  return n.info = M.Enum, n.fallbackType = r, Array.isArray(e) ? n.sub = e.map((i, s) => ({
    index: s,
    info: M.Plain,
    name: i,
    type: "Null"
  })) : bT(e) ? n.sub = Object.entries(e).map(([i, s], a) => J({}, Jr(e_(s || "Null"), { name: i }, t), { index: a })) : n.sub = Object.entries(e).map(([i, s]) => ({
    index: s,
    info: M.Plain,
    name: i,
    type: "Null"
  })), n;
}
function xT(n, e, t) {
  return n.info = M.Set, n.fallbackType = t, n.length = e._bitLength, n.sub = Object.entries(e).filter(([r]) => !r.startsWith("_")).map(([r, i]) => ({
    index: i,
    info: M.Plain,
    name: r,
    type: "Null"
  })), n;
}
function ST(n, e, t, r) {
  const i = JSON.parse(e), s = Object.keys(i);
  return i._enum ? wT(n, i._enum, r, i._fallback) : i._set ? xT(n, i._set, i._fallback) : (n.alias = i._alias ? new Map(Object.entries(i._alias)) : void 0, n.fallbackType = i._fallback, n.sub = s.filter((a) => !vT.includes(a)).map((a) => Jr(e_(i[a]), { name: a }, r)), n);
}
function ET(n, e, t, r) {
  const i = e.length - 1;
  let s = -1, a = 0;
  for (let f = 1; f < i && s === -1; f++)
    switch (e[f]) {
      case ";": {
        a === 0 && (s = f);
        break;
      }
      case "[":
      case "(":
      case "<":
        a++;
        break;
      case "]":
      case ")":
      case ">":
        a--;
        break;
    }
  if (s === -1)
    throw new Error(`${e}: Unable to extract location of ';'`);
  const o = e.substring(1, s), [c, l] = e.substring(s + 1, i).split(";"), u = parseInt(c.trim(), 10);
  if (u > 2048)
    throw new Error(`${e}: Only support for [Type; <length>], where length <= 2048`);
  return n.displayName = l, n.length = u, n.sub = Jr(o, {}, r), n;
}
function aa(n, e, t, r) {
  return n.sub = t.length === 0 ? [] : _T(t).map((i) => Jr(i, {}, r)), n;
}
function t_(n, e, t, r) {
  const [i, s] = e.substring(r.length + 1, e.length - 1).split(","), a = parseInt(i.trim(), 10);
  if (a > 8192 || a % 8)
    throw new Error(`${e}: Only support for ${r}<bitLength>, where length <= 8192 and a power of 8, found ${a}`);
  return n.displayName = s, n.length = a, n;
}
function CT(n, e, t) {
  return t_(n, e, t, "Int");
}
function AT(n, e, t) {
  return t_(n, e, t, "UInt");
}
function PT(n, e, t) {
  return n.displayName = e.substring(14 + 1, e.length - 1), n;
}
function Qh(n, [e, t]) {
  return n.startsWith(e) && n.slice(-1 * t.length) === t;
}
const kT = [
  ["[", "]", M.VecFixed, ET],
  ["{", "}", M.Struct, ST],
  ["(", ")", M.Tuple, aa],
  // the inner for these are the same as tuple, multiple values
  ["BTreeMap<", ">", M.BTreeMap, aa],
  ["HashMap<", ">", M.HashMap, aa],
  ["Int<", ">", M.Int, CT],
  ["Result<", ">", M.Result, aa],
  ["UInt<", ">", M.UInt, AT],
  ["DoNotConstruct<", ">", M.DoNotConstruct, PT]
], TT = [
  ["BTreeSet<", ">", M.BTreeSet],
  ["Compact<", ">", M.Compact],
  ["Linkage<", ">", M.Linkage],
  ["Opaque<", ">", M.WrapperOpaque],
  ["Option<", ">", M.Option],
  ["Range<", ">", M.Range],
  ["RangeInclusive<", ">", M.RangeInclusive],
  ["Vec<", ">", M.Vec],
  ["WrapperKeepOpaque<", ">", M.WrapperKeepOpaque],
  ["WrapperOpaque<", ">", M.WrapperOpaque]
];
function $h(n, [e, t]) {
  return n.substring(e.length, n.length - t.length);
}
function Jr(n, { displayName: e, name: t } = {}, r = 0) {
  const i = La(n), s = { displayName: e, info: M.Plain, name: t, type: i };
  if (++r > 64)
    throw new Error("getTypeDef: Maximum nested limit reached");
  const a = kT.find((c) => Qh(i, c));
  if (a)
    return s.info = a[2], a[3](s, i, $h(i, a), r);
  const o = TT.find((c) => Qh(i, c));
  return o && (s.info = o[2], s.sub = Jr($h(i, o), {}, r)), s;
}
function Ns({ lookupName: n, type: e }) {
  return n || e;
}
function Za(n) {
  if (!Array.isArray(n.sub))
    throw new Error(`Expected subtype as TypeDef[] in ${_e(n)}`);
  return n.sub;
}
function NT(n) {
  if (!n.sub || Array.isArray(n.sub))
    throw new Error(`Expected subtype as TypeDef in ${_e(n)}`);
  return n.sub;
}
function n_(n) {
  return Ns(NT(n));
}
function ep(n) {
  const e = Za(n), t = {};
  for (let r = 0, i = e.length; r < i; r++) {
    const s = e[r];
    if (!s.name)
      throw new Error(`No name found in definition ${_e(s)}`);
    t[s.name] = Ns(s);
  }
  return t;
}
function Bl(n) {
  return Za(n).map(Ns);
}
function tp(n, { displayName: e, length: t }) {
  if (!xe(t))
    throw new Error(`Expected bitLength information for ${e || n.constructor.name}<bitLength>`);
  return n.with(t, e);
}
function np(n, e) {
  const [t, r] = Bl(e);
  return n.with(t, r);
}
function Kr(n, e) {
  return n.with(n_(e));
}
const RT = {
  [M.BTreeMap]: (n, e) => np(sd, e),
  [M.BTreeSet]: (n, e) => Kr(ad, e),
  [M.Compact]: (n, e) => Kr(ks, e),
  [M.DoNotConstruct]: (n, e) => Ao.with(e.displayName || e.type),
  [M.Enum]: (n, e) => {
    const t = Za(e);
    return Ln.with(t.every(({ type: r }) => r === "Null") ? t.reduce((r, { index: i, name: s }, a) => {
      if (!s)
        throw new Error("No name found in sub definition");
      return r[s] = i || a, r;
    }, {}) : ep(e));
  },
  [M.HashMap]: (n, e) => np(od, e),
  [M.Int]: (n, e) => tp(br, e),
  // We have circular deps between Linkage & Struct
  [M.Linkage]: (n, e) => {
    const t = `Option<${n_(e)}>`, r = Dt.with({ previous: t, next: t });
    return r.prototype.toRawType = function() {
      return `Linkage<${this.next.toRawType(!0)}>`;
    }, r;
  },
  [M.Null]: (n, e) => Yn,
  [M.Option]: (n, e) => {
    if (!e.sub || Array.isArray(e.sub))
      throw new Error("Expected type information for Option");
    return Kr(yr, e);
  },
  [M.Plain]: (n, e) => n.getOrUnknown(e.type),
  [M.Range]: (n, e) => Kr(Po, e),
  [M.RangeInclusive]: (n, e) => Kr(cd, e),
  [M.Result]: (n, e) => {
    const [t, r] = Bl(e);
    return Qk.with({ Err: r, Ok: t });
  },
  [M.Set]: (n, e) => ku.with(Za(e).reduce((t, { index: r, name: i }) => {
    if (!i || !xe(r))
      throw new Error("No name found in sub definition");
    return t[i] = r, t;
  }, {}), e.length),
  [M.Si]: (n, e) => r_(n, n.lookup.getTypeDef(e.type)),
  [M.Struct]: (n, e) => Dt.with(ep(e), e.alias),
  [M.Tuple]: (n, e) => qi.with(Bl(e)),
  [M.UInt]: (n, e) => tp(wr, e),
  [M.Vec]: (n, { sub: e }) => {
    if (!e || Array.isArray(e))
      throw new Error("Expected type information for vector");
    return e.type === "u8" ? Xs : rd.with(Ns(e));
  },
  [M.VecFixed]: (n, { displayName: e, length: t, sub: r }) => {
    if (!xe(t) || !r || Array.isArray(r))
      throw new Error("Expected length & type information for fixed vector");
    return r.type === "u8" ? Zr.with(t * 8, e) : id.with(Ns(r), t);
  },
  [M.WrapperKeepOpaque]: (n, e) => Kr(ko, e),
  [M.WrapperOpaque]: (n, e) => Kr(ld, e)
};
function IT(n, e) {
  try {
    const t = RT[e.info](n, e);
    if (!t)
      throw new Error("No class created");
    return !t.__fallbackType && e.fallbackType && (t.__fallbackType = e.fallbackType), t;
  } catch (t) {
    throw new Error(`Unable to construct class from ${_e(e)}: ${t.message}`);
  }
}
function r_(n, e) {
  return n.getUnsafe(e.type, !1, e);
}
function ys(n, e) {
  return (
    // just retrieve via name, no creation via typeDef
    n.getUnsafe(e) || // we don't have an existing type, create the class via typeDef
    r_(n, n.isLookupType(e) ? n.lookup.getTypeDef(e) : Jr(e))
  );
}
function rp(n, e) {
  const t = n.toU8a(), r = n.toRawType();
  if (!// full match, all ok
  (jt(t, e) || // on a length-prefixed type, just check the actual length
  ["Bytes", "Text", "Type"].includes(r) && e.length === n.length || // when the created is empty and matcher is also empty, let it slide...
  n.isEmpty && e.every((s) => !s)))
    throw new Error(`${r}:: Decoded input doesn't match input, received ${pe(e, 512)} (${e.length} bytes), created ${pe(t, 512)} (${t.length} bytes)`);
}
function OT(n, [e]) {
  te(e) ? rp(n, e) : ye(e) && rp(n, j(e));
}
function ip(n, e, t = [], { blockHash: r, isFallback: i, isOptional: s, isPedantic: a } = {}) {
  const o = new (s ? yr.with(e) : e)(n, ...t);
  return a && OT(o, t), r && (o.createdAtHash = Hl(n, "BlockHash", [r])), i && (o.isStorageFallback = !0), o;
}
function Hl(n, e, t = [], r = {}) {
  let i = null, s = null;
  try {
    return i = ys(n, e), ip(n, i, t, r);
  } catch (a) {
    s = new Error(`createType(${e}):: ${a.message}`);
  }
  if (i != null && i.__fallbackType)
    try {
      return i = ys(n, i.__fallbackType), ip(n, i, t, r);
    } catch {
    }
  throw s;
}
const MT = (n) => n.toString(), LT = ["BTreeMap", "BTreeSet", "Compact", "HashMap", "Option", "Result", "Vec"];
function DT(n, e, t = MT) {
  return `${n}${e ? `<${(Array.isArray(e) ? e : [e]).map(t).join(", ")}>` : ""}`;
}
function mn(n, e, t) {
  const { info: r, sub: i } = e;
  switch (r) {
    case M.BTreeMap:
    case M.BTreeSet:
    case M.Compact:
    case M.HashMap:
    case M.Linkage:
    case M.Option:
    case M.Range:
    case M.RangeInclusive:
    case M.Result:
    case M.Vec:
    case M.WrapperKeepOpaque:
    case M.WrapperOpaque:
      return DT(t, i, (s) => ud(n, s));
  }
  throw new Error(`Unable to encode ${_e(e)} with params`);
}
function sp(n, e, t, r) {
  const i = e.map(({ name: a }) => a);
  if (!i.every((a) => !!a))
    throw new Error(`Subtypes does not have consistent names, ${i.join(", ")}`);
  const s = J({}, r);
  for (let a = 0, o = e.length; a < o; a++) {
    const c = e[a];
    if (!c.name)
      throw new Error(`No name found in ${_e(c)}`);
    s[c.name] = ud(n, c);
  }
  return _e(t ? { _enum: s } : s);
}
const UT = {
  [M.BTreeMap]: (n, e) => mn(n, e, "BTreeMap"),
  [M.BTreeSet]: (n, e) => mn(n, e, "BTreeSet"),
  [M.Compact]: (n, e) => mn(n, e, "Compact"),
  [M.DoNotConstruct]: (n, { displayName: e, lookupIndex: t, lookupName: r }) => `DoNotConstruct<${r || e || (Ne(t) ? "Unknown" : n.createLookupType(t))}>`,
  [M.Enum]: (n, { sub: e }) => {
    if (!Array.isArray(e))
      throw new Error("Unable to encode Enum type");
    return e.every(({ type: t }) => t === "Null") ? _e({ _enum: e.map(({ name: t }, r) => `${t || `Empty${r}`}`) }) : sp(n, e, !0);
  },
  [M.HashMap]: (n, e) => mn(n, e, "HashMap"),
  [M.Int]: (n, { length: e = 32 }) => `Int<${e}>`,
  [M.Linkage]: (n, e) => mn(n, e, "Linkage"),
  [M.Null]: (n, e) => "Null",
  [M.Option]: (n, e) => mn(n, e, "Option"),
  [M.Plain]: (n, { displayName: e, type: t }) => e || t,
  [M.Range]: (n, e) => mn(n, e, "Range"),
  [M.RangeInclusive]: (n, e) => mn(n, e, "RangeInclusive"),
  [M.Result]: (n, e) => mn(n, e, "Result"),
  [M.Set]: (n, { length: e = 8, sub: t }) => {
    if (!Array.isArray(t))
      throw new Error("Unable to encode Set type");
    return _e({
      _set: t.reduce((r, { index: i, name: s }, a) => J(r, { [`${s || `Unknown${i || a}`}`]: i || a }), { _bitLength: e || 8 })
    });
  },
  [M.Si]: (n, { lookupName: e, type: t }) => e || t,
  [M.Struct]: (n, { alias: e, sub: t }) => {
    if (!Array.isArray(t))
      throw new Error("Unable to encode Struct type");
    return sp(n, t, !1, e ? {
      _alias: [...e.entries()].reduce((r, [i, s]) => J(r, { [i]: s }), {})
    } : {});
  },
  [M.Tuple]: (n, { sub: e }) => {
    if (!Array.isArray(e))
      throw new Error("Unable to encode Tuple type");
    return `(${e.map((t) => ud(n, t)).join(",")})`;
  },
  [M.UInt]: (n, { length: e = 32 }) => `UInt<${e}>`,
  [M.Vec]: (n, e) => mn(n, e, "Vec"),
  [M.VecFixed]: (n, { length: e, sub: t }) => {
    if (!xe(e) || !t || Array.isArray(t))
      throw new Error("Unable to encode VecFixed type");
    return `[${t.type};${e}]`;
  },
  [M.WrapperKeepOpaque]: (n, e) => mn(n, e, "WrapperKeepOpaque"),
  [M.WrapperOpaque]: (n, e) => mn(n, e, "WrapperOpaque")
};
function i_(n, e, t = !0) {
  return t && e.lookupName ? e.lookupName : UT[e.info](n, e);
}
function ud(n, e) {
  return e.displayName && !LT.some((t) => e.displayName === t) ? e.displayName : i_(n, e);
}
function an(n, e) {
  return J({}, e, {
    type: i_(n, e, !1)
  });
}
const VT = ["AssetInstance", "Fungibility", "Junction", "Junctions", "MultiAsset", "MultiAssetFilter", "MultiLocation", "Response", "WildFungibility", "WildMultiAsset", "Xcm", "XcmError", "XcmOrder"];
function Fi(n) {
  return VT.reduce((e, t) => J(e, { [t]: `${t}${n}` }), {});
}
const ap = Qt("PortableRegistry"), op = { toNumber: () => -1 }, BT = {
  Char: "u32",
  Str: "Text"
}, HT = a_([
  // full matching on exact names...
  // these are well-known types with additional encoding
  "sp_core::crypto::AccountId32",
  "sp_runtime::generic::era::Era",
  "sp_runtime::multiaddress::MultiAddress",
  // ethereum overrides (Frontier, Moonbeam, Polkadot claims)
  "fp_account::AccountId20",
  "account::AccountId20",
  "polkadot_runtime_common::claims::EthereumAddress",
  // weights 2 is a structure, however for 1.5. with a single field it
  // should be flatenned (can appear in Compact<Weight> extrinsics)
  "frame_support::weights::weight_v2::Weight",
  "sp_weights::weight_v2::Weight",
  // wildcard matching in place...
  // these have a specific encoding or logic, use a wildcard for {pallet, darwinia}_democracy
  "*_democracy::vote::Vote",
  "*_conviction_voting::vote::Vote",
  "*_identity::types::Data",
  // these are opaque Vec<u8> wrappers
  "sp_core::OpaqueMetadata",
  "sp_core::OpaquePeerId",
  "sp_core::offchain::OpaqueMultiaddr",
  // shorten some well-known types
  "primitive_types::*",
  "sp_arithmetic::per_things::*",
  // runtime
  "*_runtime::RuntimeCall",
  "*_runtime::RuntimeEvent",
  // ink!
  "ink::env::types::*",
  "ink::primitives::types::*",
  "ink_env::types::*",
  "ink_primitives::types::*",
  // noir
  "np_runtime::accountname::AccountName",
  "np_runtime::universaladdress::UniversalAddress"
]), FT = a_([
  "pallet_identity::types::BitFlags"
]), s_ = ["bitvec::order::Lsb0", "BitOrderLsb0"], jT = ["bitvec::order::Msb0", "BitOrderMsb0"], cp = [...s_, ...jT], WT = ["BoundedBTreeMap", "BoundedBTreeSet", "BoundedVec", "Box", "BTreeMap", "BTreeSet", "Cow", "Option", "Range", "RangeInclusive", "Result", "WeakBoundedVec", "WrapperKeepOpaque", "WrapperOpaque"], qT = [
  // JS reserved words
  "entries",
  "keys",
  "new",
  "size",
  // exposed by all Codec objects
  "hash",
  "registry"
], zT = ["generic", "misc", "pallet", "traits", "types"];
function lp(n) {
  const e = n.length, t = new Array(e);
  for (let r = 0; r < e; r++)
    t[r] = n[r].toString();
  return t;
}
function a_(n) {
  const e = n.length, t = new Array(e);
  for (let r = 0; r < e; r++)
    t[r] = n[r].split("::");
  return t;
}
function dd(n, e) {
  return n.length === e.length && n.every((t, r) => {
    const i = e[r].toString();
    if (t === "*" || t === i)
      return !0;
    if (t.includes("*") && t.includes("_") && i.includes("_")) {
      let s = t.split("_"), a = i.split("_");
      if (s[0] === "*") {
        const o = a.indexOf(s[1]);
        o !== -1 && (s = s.slice(1), a = a.slice(o));
      }
      return s.length === 2 && s[1] === "*" && s[0] === a[0] ? !0 : dd(s, a);
    }
    return !1;
  });
}
function XT({ def: n, path: e }) {
  return ["frame_support::weights::weight_v2::Weight", "sp_weights::weight_v2::Weight"].includes(e.join("::")) ? !n.isComposite || n.asComposite.fields.length === 1 ? "WeightV1" : null : e.length && HT.some((t) => dd(t, e)) ? e[e.length - 1].toString() : null;
}
function o_(n, e, t, r, i = !1) {
  const s = r.length;
  if (s === 0 || WT.includes(r[s - 1].toString()))
    return null;
  const a = new Array(s), o = new Array(s);
  for (let l = 0; l < s; l++) {
    const u = fo(i ? r[l].replace("pallet_", "") : r[l]), f = u.toLowerCase();
    a[l] = u, o[l] = f;
  }
  let c = "";
  for (let l = 0; l < s; l++) {
    const u = o[l];
    (l !== 1 || !zT.includes(u)) && u !== o[l + 1] && (c += a[l]);
  }
  if (a[1] === "RawOrigin" && s === 2 && t.length === 2 && t[1].type.isSome) {
    const l = n[t[1].type.unwrap().toNumber()];
    l.type.path.length === 2 && (c = `${c}${l.type.path[1].toString()}`);
  }
  return { lookupIndex: e, name: c, params: t };
}
function GT(n, e, { type: { params: t, path: r } }) {
  return o_(n, e, t, r);
}
function ZT(n, e, t) {
  const r = [t[e]];
  for (let i = e + 1, s = t.length; i < s; i++) {
    const a = t[i];
    a.name === n && r.push(a);
  }
  return r;
}
function up(n, e) {
  const t = n.length;
  for (let r = 0; r < t; r++) {
    const i = n[r];
    for (let s = r + 1; s < t; s++) {
      const a = n[s];
      if (i.lookupIndex !== a.lookupIndex && i.name === a.name)
        return !1;
    }
  }
  for (let r = 0; r < t; r++) {
    const i = n[r];
    e[i.lookupIndex] = i.name;
  }
  return !0;
}
function JT(n, e, t) {
  const r = {};
  return t.map((i, s) => {
    const { lookupIndex: a, name: o, params: c } = i;
    if (o) {
      if (r[a])
        return i;
    } else
      return null;
    const l = ZT(o, s, t);
    if (l.length === 1 || !l.some((_) => c.length !== _.params.length || c.some((v, C) => !v.name.eq(_.params[C].name) || v.type.unwrapOr(op).toNumber() !== _.params[C].type.unwrapOr(op).toNumber())))
      return i;
    const f = c.findIndex(({ type: _ }, v) => l.every(({ params: C }, A) => C[v].type.isSome && (A === 0 || !C[v].type.eq(_))));
    if (f === -1)
      return i;
    const m = l.length, y = new Array(m);
    for (let _ = 0; _ < m; _++) {
      const { lookupIndex: v, name: C, params: A } = l[_], { def: R, path: I } = n.getSiType(A[f].type.unwrap());
      if (!R.isPrimitive && !I.length)
        return null;
      y[_] = {
        lookupIndex: v,
        name: R.isPrimitive ? `${C}${R.asPrimitive.toString()}` : `${C}${I[I.length - 1].toString()}`
      };
    }
    if (up(y, r))
      return i;
    for (let _ = 0; _ < m; _++) {
      const { lookupIndex: v, name: C, params: A } = l[_], { def: R, path: I } = n.getSiType(A[f].type.unwrap()), D = o_(e, v, A, I, !0);
      if (R.isPrimitive || !D)
        return null;
      y[_] = {
        lookupIndex: v,
        name: `${C}${D.name}`
      };
    }
    return up(y, r) ? i : null;
  }).filter((i) => !!i).map(({ lookupIndex: i, name: s, params: a }) => ({
    lookupIndex: i,
    name: r[i] || s,
    params: a
  }));
}
function KT(n, e, t, r) {
  if (n.registry.register(e), r.SpRuntimeUncheckedExtrinsic) {
    const [i, , s] = r.SpRuntimeUncheckedExtrinsic, a = n.getSiType(i.type.unwrap()), c = n.getSiType(s.type.unwrap()).path.join("::");
    let l = a.path.join("::");
    const u = l === "sp_runtime::multiaddress::MultiAddress";
    if (u) {
      const [f] = a.params;
      l = n.getSiType(f.type.unwrap()).path.join("::");
    }
    n.registry.register({
      // known: account::AccountId20, fp_account::AccountId20, primitive_types::H160
      AccountId: l.endsWith("::AccountId20") || l.endsWith("::H160") ? "AccountId20" : "AccountId32",
      Address: u ? "MultiAddress" : "AccountId",
      ExtrinsicSignature: ["sp_runtime::MultiSignature"].includes(c) ? "MultiSignature" : t[s.type.unwrap().toNumber()] || "MultiSignature"
    });
  }
}
function YT(n, e) {
  const t = Object.keys(n).some((i) => !i.startsWith("Pallet")), r = {};
  if (n.SpRuntimeUncheckedExtrinsic) {
    const [, { type: i }] = n.SpRuntimeUncheckedExtrinsic;
    r[i.unwrap().toNumber()] = "Call";
  } else
    t && !e && ap.warn("Unable to determine runtime Call type, cannot inspect sp_runtime::generic::unchecked_extrinsic::UncheckedExtrinsic");
  if (n.FrameSystemEventRecord) {
    const [{ type: i }] = n.FrameSystemEventRecord;
    r[i.unwrap().toNumber()] = "Event";
  } else
    t && !e && ap.warn("Unable to determine runtime Event type, cannot inspect frame_system::EventRecord");
  return r;
}
function QT(n, e) {
  const t = [], r = {};
  for (let c = 0, l = e.length; c < l; c++) {
    const u = e[c], f = u.id.toNumber(), m = GT(e, f, e[c]);
    m && t.push(m), r[f] = u;
  }
  const i = {}, s = {}, a = {}, o = JT(n, e, t);
  for (let c = 0, l = o.length; c < l; c++) {
    const { lookupIndex: u, name: f, params: m } = o[c];
    s[u] = f, i[f] = n.registry.createLookupType(u), a[f] = m;
  }
  return { lookups: i, names: s, params: a, types: r };
}
class $T extends Dt {
  constructor(t, r, i) {
    super(t, {
      types: "Vec<PortableType>"
    }, r);
    b(this, "__internal__alias");
    b(this, "__internal__lookups");
    b(this, "__internal__names");
    b(this, "__internal__params");
    b(this, "__internal__typeDefs", {});
    b(this, "__internal__types");
    const { lookups: s, names: a, params: o, types: c } = QT(this, this.types);
    this.__internal__alias = YT(o, i), this.__internal__lookups = s, this.__internal__names = a, this.__internal__params = o, this.__internal__types = c;
  }
  /**
   * @description Returns all the available type names for this chain
   **/
  get names() {
    return Object.values(this.__internal__names).sort();
  }
  /**
   * @description Returns all the available parameterized types for this chain
   **/
  get paramTypes() {
    return this.__internal__params;
  }
  /**
   * @description The types of the registry
   */
  get types() {
    return this.getT("types");
  }
  /**
   * @description Register all available types into the registry (generally for internal usage)
   */
  register() {
    KT(this, this.__internal__lookups, this.__internal__names, this.__internal__params);
  }
  /**
   * @description Returns the name for a specific lookup
   */
  getName(t) {
    return this.__internal__names[this.__internal__getLookupId(t)];
  }
  /**
   * @description Finds a specific type in the registry
   */
  getSiType(t) {
    const r = (this.__internal__types || this.types)[this.__internal__getLookupId(t)];
    if (!r)
      throw new Error(`PortableRegistry: Unable to find type with lookupId ${t.toString()}`);
    return r.type;
  }
  /**
   * @description Lookup the type definition for the index
   */
  getTypeDef(t) {
    const r = this.__internal__getLookupId(t);
    if (!this.__internal__typeDefs[r]) {
      const i = this.__internal__names[r], s = {
        info: M.DoNotConstruct,
        lookupIndex: r,
        lookupName: i,
        type: this.registry.createLookupType(r)
      };
      i && (this.__internal__typeDefs[r] = s);
      const a = this.__internal__extract(this.getSiType(t), r);
      i || (this.__internal__typeDefs[r] = s), Object.keys(a).forEach((o) => {
        (o !== "lookupName" || a[o]) && (this.__internal__typeDefs[r][o] = a[o]);
      }), a.info === M.Plain && (this.__internal__typeDefs[r].lookupNameRoot = this.__internal__typeDefs[r].lookupName, delete this.__internal__typeDefs[r].lookupName);
    }
    return this.__internal__typeDefs[r];
  }
  /**
   * @description For a specific field, perform adjustments to not have built-in conflicts
   */
  sanitizeField(t) {
    let r = null, i = null;
    return t.isSome && (r = Ee(t.unwrap()), r.includes("#") ? (i = r, r = i.replace(/#/g, "_")) : qT.includes(r) && (i = r, r = `${r}_`)), [r, i];
  }
  /** @internal Creates a TypeDef based on an internal lookupId */
  __internal__createSiDef(t) {
    const r = this.getTypeDef(t), i = t.toNumber();
    return [M.DoNotConstruct, M.Enum, M.Struct].includes(r.info) && r.lookupName ? {
      docs: r.docs,
      info: M.Si,
      lookupIndex: i,
      lookupName: this.__internal__names[i],
      type: this.registry.createLookupType(t)
    } : r;
  }
  /** @internal Converts a lookupId input to the actual lookup index */
  __internal__getLookupId(t) {
    if (Pe(t)) {
      if (!this.registry.isLookupType(t))
        throw new Error(`PortableRegistry: Expected a lookup string type, found ${t}`);
      return parseInt(t.replace("Lookup", ""), 10);
    } else if (xe(t))
      return t;
    return t.toNumber();
  }
  /** @internal Converts a type into a TypeDef for Codec usage */
  __internal__extract(t, r) {
    const i = t.path.join("::");
    let s;
    const a = this.__internal__alias[r] || XT(t);
    try {
      if (a)
        s = this.__internal__extractAliasPath(r, a);
      else
        switch (t.def.type) {
          case "Array":
            s = this.__internal__extractArray(r, t.def.asArray);
            break;
          case "BitSequence":
            s = this.__internal__extractBitSequence(r, t.def.asBitSequence);
            break;
          case "Compact":
            s = this.__internal__extractCompact(r, t.def.asCompact);
            break;
          case "Composite":
            s = this.__internal__extractComposite(r, t, t.def.asComposite);
            break;
          case "HistoricMetaCompat":
            s = this.__internal__extractHistoric(r, t.def.asHistoricMetaCompat);
            break;
          case "Primitive":
            s = this.__internal__extractPrimitive(r, t);
            break;
          case "Sequence":
            s = this.__internal__extractSequence(r, t.def.asSequence);
            break;
          case "Tuple":
            s = this.__internal__extractTuple(r, t.def.asTuple);
            break;
          case "Variant":
            s = this.__internal__extractVariant(r, t, t.def.asVariant);
            break;
          default:
            ru(t.def.type);
        }
    } catch (o) {
      throw new Error(`PortableRegistry: ${r}${i ? ` (${i})` : ""}: Error extracting ${_e(t)}: ${o.message}`);
    }
    return J({
      docs: lp(t.docs),
      namespace: i
    }, s);
  }
  /** @internal Extracts a ScaleInfo Array into TypeDef.VecFixed */
  __internal__extractArray(t, { len: r, type: i }) {
    const s = r.toNumber();
    if (s > 2048)
      throw new Error("Only support for [Type; <length>], where length <= 2048");
    return an(this.registry, {
      info: M.VecFixed,
      length: s,
      sub: this.__internal__createSiDef(i)
    });
  }
  /** @internal Extracts a ScaleInfo BitSequence into TypeDef.Plain */
  __internal__extractBitSequence(t, { bitOrderType: r, bitStoreType: i }) {
    const s = this.__internal__createSiDef(r), a = this.__internal__createSiDef(i), [o, c] = cp.includes(s.namespace || "") ? [s, a] : [a, s];
    if (!o.namespace || !cp.includes(o.namespace))
      throw new Error(`Unexpected bitOrder found as ${o.namespace || "<unknown>"}`);
    if (c.info !== M.Plain || c.type !== "u8")
      throw new Error(`Only u8 bitStore is currently supported, found ${c.type}`);
    return s_.includes(o.namespace), {
      info: M.Plain,
      type: "BitVec"
    };
  }
  /** @internal Extracts a ScaleInfo Compact into TypeDef.Compact */
  __internal__extractCompact(t, { type: r }) {
    return an(this.registry, {
      info: M.Compact,
      sub: this.__internal__createSiDef(r)
    });
  }
  /** @internal Extracts a ScaleInfo Composite into TypeDef.{BTree*, Range*, Wrapper*} */
  __internal__extractComposite(t, { params: r, path: i }, { fields: s }) {
    if (i.length) {
      const a = i[0].toString(), o = i[i.length - 1].toString();
      if (i.length === 1 && a === "BTreeMap") {
        if (r.length !== 2)
          throw new Error(`BTreeMap requires 2 parameters, found ${r.length}`);
        return an(this.registry, {
          info: M.BTreeMap,
          sub: r.map(({ type: c }) => this.__internal__createSiDef(c.unwrap()))
        });
      } else if (i.length === 1 && a === "BTreeSet") {
        if (r.length !== 1)
          throw new Error(`BTreeSet requires 1 parameter, found ${r.length}`);
        return an(this.registry, {
          info: M.BTreeSet,
          sub: this.__internal__createSiDef(r[0].type.unwrap())
        });
      } else if (["Range", "RangeInclusive"].includes(a)) {
        if (r.length !== 1)
          throw new Error(`Range requires 1 parameter, found ${r.length}`);
        return an(this.registry, {
          info: a === "Range" ? M.Range : M.RangeInclusive,
          sub: this.__internal__createSiDef(r[0].type.unwrap()),
          type: a
        });
      } else if (["WrapperKeepOpaque", "WrapperOpaque"].includes(o)) {
        if (r.length !== 1)
          throw new Error(`WrapperOpaque requires 1 parameter, found ${r.length}`);
        return an(this.registry, {
          info: o === "WrapperKeepOpaque" ? M.WrapperKeepOpaque : M.WrapperOpaque,
          sub: this.__internal__createSiDef(r[0].type.unwrap()),
          type: o
        });
      }
    }
    return FT.some((a) => dd(a, i)) ? this.__internal__extractCompositeSet(t, r, s) : this.__internal__extractFields(t, s);
  }
  /** @internal Extracts a ScaleInfo CompositeSet into TypeDef.Set */
  __internal__extractCompositeSet(t, r, i) {
    if (r.length !== 1 || i.length !== 1)
      throw new Error("Set handling expects param/field as single entries");
    return an(this.registry, {
      info: M.Set,
      length: this.registry.createTypeUnsafe(this.registry.createLookupType(i[0].type), []).bitLength(),
      sub: this.getSiType(r[0].type.unwrap()).def.asVariant.variants.map(({ index: s, name: a }) => ({
        // This will be an issue > 2^53 - 1 ... don't have those (yet)
        index: s.toNumber(),
        info: M.Plain,
        name: a.toString(),
        type: "Null"
      }))
    });
  }
  /** @internal Extracts ScaleInfo enum/struct fields into TypeDef.{Struct, Tuple} */
  __internal__extractFields(t, r) {
    let i = !0, s = !0;
    const a = r.length;
    for (let l = 0; l < a; l++) {
      const { name: u } = r[l];
      i = i && u.isSome, s = s && u.isNone;
    }
    if (!s && !i)
      throw new Error("Invalid fields type detected, expected either Tuple (all unnamed) or Struct (all named)");
    if (a === 0)
      return {
        info: M.Null,
        type: "Null"
      };
    if (s && a === 1) {
      const l = this.__internal__createSiDef(r[0].type);
      return J({}, l, t === -1 ? null : {
        lookupIndex: t,
        lookupName: this.__internal__names[t],
        lookupNameRoot: l.lookupName
      }, r[0].typeName.isSome ? { typeName: La(r[0].typeName.unwrap()) } : null);
    }
    const [o, c] = this.__internal__extractFieldsAlias(r);
    return an(this.registry, J({
      info: s ? M.Tuple : M.Struct,
      sub: o
    }, c.size ? { alias: c } : null, t === -1 ? null : {
      lookupIndex: t,
      lookupName: this.__internal__names[t]
    }));
  }
  /** @internal Apply field aliassed (with no JS conflicts) */
  __internal__extractFieldsAlias(t) {
    const r = /* @__PURE__ */ new Map(), i = t.length, s = new Array(i);
    for (let a = 0; a < i; a++) {
      const { docs: o, name: c, type: l, typeName: u } = t[a], f = this.__internal__createSiDef(l);
      if (c.isNone)
        s[a] = f;
      else {
        const [m, y] = this.sanitizeField(c);
        m && y && r.set(m, y), s[a] = J({
          docs: lp(o),
          name: m
        }, f, u.isSome ? { typeName: La(u.unwrap()) } : null);
      }
    }
    return [s, r];
  }
  /** @internal Extracts an internal Historic (pre V14) type  */
  __internal__extractHistoric(t, r) {
    return J({
      displayName: r.toString(),
      isFromSi: !0
    }, Jr(r));
  }
  /** @internal Extracts a ScaleInfo Primitive into TypeDef.Plain */
  __internal__extractPrimitive(t, r) {
    const i = r.def.asPrimitive.type.toString();
    return {
      info: M.Plain,
      type: BT[i] || i.toLowerCase()
    };
  }
  /** @internal Applies an alias path onto the TypeDef */
  __internal__extractAliasPath(t, r) {
    return {
      info: M.Plain,
      type: r
    };
  }
  /** @internal Extracts a ScaleInfo Sequence into TypeDef.Vec (with Bytes shortcut) */
  __internal__extractSequence(t, { type: r }) {
    const i = this.__internal__createSiDef(r);
    return i.type === "u8" ? {
      info: M.Plain,
      type: "Bytes"
    } : an(this.registry, {
      info: M.Vec,
      lookupIndex: t,
      lookupName: this.__internal__names[t],
      sub: i
    });
  }
  /** @internal Extracts a ScaleInfo Tuple into TypeDef.Tuple */
  __internal__extractTuple(t, r) {
    if (r.length === 0)
      return {
        info: M.Null,
        type: "Null"
      };
    if (r.length === 1)
      return this.getTypeDef(r[0]);
    const i = r.map((s) => this.__internal__createSiDef(s));
    return an(this.registry, {
      info: M.Tuple,
      lookupIndex: t,
      lookupName: this.__internal__names[t],
      sub: i
    });
  }
  /** @internal Extracts a ScaleInfo Variant into TypeDef.{Option, Result, Enum} */
  __internal__extractVariant(t, { params: r, path: i }, { variants: s }) {
    if (i.length) {
      const a = i[0].toString();
      if (a === "Option") {
        if (r.length !== 1)
          throw new Error(`Option requires 1 parameter, found ${r.length}`);
        return an(this.registry, {
          info: M.Option,
          sub: this.__internal__createSiDef(r[0].type.unwrap())
        });
      } else if (a === "Result") {
        if (r.length !== 2)
          throw new Error(`Result requires 2 parameters, found ${r.length}`);
        return an(this.registry, {
          info: M.Result,
          sub: r.map(({ type: o }, c) => J({
            name: ["Ok", "Error"][c]
          }, this.__internal__createSiDef(o.unwrap())))
        });
      }
    }
    return s.length === 0 ? {
      info: M.Null,
      type: "Null"
    } : this.__internal__extractVariantEnum(t, s);
  }
  /** @internal Extracts a ScaleInfo Variant into TypeDef.Enum */
  __internal__extractVariantEnum(t, r) {
    const i = [];
    return r.slice().sort((s, a) => s.index.cmp(a.index)).forEach(({ fields: s, index: a, name: o }) => {
      const c = a.toNumber();
      for (; i.length !== c; )
        i.push({
          index: i.length,
          info: M.Null,
          name: `__Unused${i.length}`,
          type: "Null"
        });
      i.push(J(this.__internal__extractFields(-1, s), {
        index: c,
        name: o.toString()
      }));
    }), an(this.registry, {
      info: M.Enum,
      lookupIndex: t,
      lookupName: this.__internal__names[t],
      sub: i
    });
  }
}
function c_(n) {
  return (e, { type: t }) => e.createType("Si1TypeDef", {
    [n]: {
      type: t.toNumber()
    }
  });
}
function e8(n, { len: e, type: t }) {
  return n.createType("Si1TypeDef", {
    Array: {
      len: e,
      type: t.toNumber()
    }
  });
}
function t8(n, { bitOrderType: e, bitStoreType: t }) {
  return n.createType("Si1TypeDef", {
    BitSequence: {
      bitOrderType: e.toNumber(),
      bitStoreType: t.toNumber()
    }
  });
}
const n8 = c_("Compact");
function r8(n, { fields: e }) {
  return n.createType("Si1TypeDef", {
    Composite: {
      fields: l_(n, e)
    }
  });
}
function l_(n, e) {
  return e.map(({ docs: t, name: r, type: i, typeName: s }) => n.createType("Si1Field", {
    docs: t,
    name: r,
    type: i.toNumber(),
    typeName: s
  }));
}
function i8(n, e) {
  return `${e.map((t) => t.toString()).join("::")}`, n.createType("Si1TypeDef", {
    Tuple: []
  });
}
function s8(n, e) {
  return n.createType("Si1TypeDef", {
    Primitive: e.toString()
  });
}
const a8 = c_("Sequence");
function o8(n, e) {
  return n.createType("Si1TypeDef", {
    Tuple: e.map((t) => t.toNumber())
  });
}
function c8(n, { variants: e }) {
  return n.createType("Si1TypeDef", {
    Variant: {
      variants: e.map(({ discriminant: t, docs: r, fields: i, name: s }, a) => n.createType("Si1Variant", {
        docs: r,
        fields: l_(n, i),
        index: t.isSome ? t.unwrap().toNumber() : a,
        name: s
      }))
    }
  });
}
function l8(n, { def: e, path: t }) {
  let r;
  switch (e.type) {
    case "Array":
      r = e8(n, e.asArray);
      break;
    case "BitSequence":
      r = t8(n, e.asBitSequence);
      break;
    case "Compact":
      r = n8(n, e.asCompact);
      break;
    case "Composite":
      r = r8(n, e.asComposite);
      break;
    case "Phantom":
      r = i8(n, t);
      break;
    case "Primitive":
      r = s8(n, e.asPrimitive);
      break;
    case "Sequence":
      r = a8(n, e.asSequence);
      break;
    case "Tuple":
      r = o8(n, e.asTuple);
      break;
    case "Variant":
      r = c8(n, e.asVariant);
      break;
    default:
      ru(e.type);
  }
  return r;
}
function u8(n, e) {
  return e.map((t, r) => n.createType("PortableType", {
    // offsets are +1 from v0
    id: r + 1,
    type: {
      def: l8(n, t),
      docs: [],
      params: t.params.map((i) => n.createType("Si1TypeParameter", {
        type: i.toNumber()
      })),
      path: t.path.map((i) => i.toString())
    }
  }));
}
function fd(n, e = []) {
  for (let t = 0, r = n.length; t < r; t++) {
    const i = n[t];
    Array.isArray(i) ? fd(i, e) : e.push(i);
  }
  return [...new Set(e)];
}
function Rs(n, e) {
  const t = n.getTypeDef(e);
  return t.lookupName || t.type;
}
function Fn(n, { sub: e }) {
  const { lookupName: t, type: r } = e;
  return hd([t || r]);
}
function Yr(n, { sub: e }) {
  return hd(e.map(({ lookupName: t, type: r }) => t || r));
}
function ns(n, { info: e }) {
  throw new Error(`Unhandled: Unable to create and validate type from ${n} (info=${M[e]})`);
}
const d8 = {
  [M.BTreeMap]: Yr,
  [M.BTreeSet]: Fn,
  [M.Compact]: Fn,
  [M.DoNotConstruct]: ns,
  [M.Enum]: Yr,
  [M.HashMap]: Yr,
  [M.Int]: ns,
  [M.Linkage]: Fn,
  [M.Null]: ns,
  [M.Option]: Fn,
  [M.Plain]: (n, e) => e.lookupName || e.type,
  [M.Range]: Fn,
  [M.RangeInclusive]: Fn,
  [M.Result]: Yr,
  [M.Set]: Yr,
  [M.Si]: ns,
  [M.Struct]: Yr,
  [M.Tuple]: Yr,
  [M.UInt]: ns,
  [M.Vec]: Fn,
  [M.VecFixed]: Fn,
  [M.WrapperKeepOpaque]: Fn,
  [M.WrapperOpaque]: Fn
};
function hd(n) {
  const e = n.length, t = new Array(e);
  for (let r = 0; r < e; r++) {
    const i = n[r], s = Jr(i);
    t[r] = d8[s.info](i, s);
  }
  return t;
}
const f8 = Qt("metadata");
function h8(n, e, t) {
  const r = fd(hd(t)).filter((i) => !n.hasType(i) && !n.isLookupType(i)).sort();
  if (r.length !== 0) {
    const i = `Unknown types found, no types for ${r.join(", ")}`;
    if (e)
      throw new Error(i);
    f8.warn(i);
  }
  return t;
}
function u_(n, e) {
  return e.map(({ type: t }) => n.getTypeDef(t).type);
}
function dp(n, e) {
  return n.getSiType(e).def.asVariant.variants.map(({ fields: t }) => u_(n, t));
}
function p8({ lookup: n, pallets: e }) {
  return e.reduce((t, { calls: r, constants: i, events: s, storage: a }) => (t.push([u_(n, i)]), r.isSome && t.push(dp(n, r.unwrap().type)), s.isSome && t.push(dp(n, s.unwrap().type)), a.isSome && t.push(a.unwrap().items.map(({ type: o }) => {
    if (o.isPlain)
      return [n.getTypeDef(o.asPlain).type];
    const { hashers: c, key: l, value: u } = o.asMap;
    return c.length === 1 ? [
      n.getTypeDef(u).type,
      n.getTypeDef(l).type
    ] : [
      n.getTypeDef(u).type,
      ...n.getSiType(l).def.asTuple.map((f) => n.getTypeDef(f).type)
    ];
  })), t), []);
}
function m8(n, e, t) {
  return h8(n, t, fd(p8(e)));
}
function g8(n) {
  const e = n.map((r) => r.toString().trim()), t = e.findIndex((r) => !r.length);
  return t === -1 ? e : e.slice(0, t);
}
function y8(n, { extrinsic: e, lookup: t, pallets: r }) {
  return n.createTypeUnsafe("MetadataLatest", [{
    extrinsic: e,
    lookup: {
      types: t.types.map(({ id: i, type: s }) => n.createTypeUnsafe("PortableType", [{
        id: i,
        type: J({}, s, { docs: g8(s.docs) })
      }]))
    },
    pallets: r.map(({ calls: i, index: s, name: a }) => ({
      calls: n.createTypeUnsafe("Option<PalletCallMetadataLatest>", [i.unwrapOr(null)]),
      index: s,
      name: a
    }))
  }]).toJSON();
}
function _8(n) {
  return n.isPlain ? n.asPlain : n.asMap.value;
}
function Fl(n, e, t) {
  const r = Rs(n.lookup, _8(e));
  return t ? `Option<${r}>` : r;
}
function zi(n, { type: e }, t, r) {
  const i = {}, s = n.getSiType(e).def.asVariant.variants;
  for (let a = 0, o = s.length; a < o; a++)
    Ut(i, s[a], r, t, a);
  return i;
}
const Tc = [], Nr = [], v8 = [], b8 = [], w8 = [], rs = {
  extrinsic: {},
  payload: {}
}, fp = {
  extrinsic: {
    era: "ExtrinsicEra"
  },
  payload: {
    blockHash: "Hash"
  }
}, hp = {
  extrinsic: {
    tip: "Compact<Balance>"
  },
  payload: {}
}, x8 = {
  ChargeTransactionPayment: hp,
  CheckBlockGasLimit: rs,
  CheckEra: fp,
  CheckGenesis: {
    extrinsic: {},
    payload: {
      genesisHash: "Hash"
    }
  },
  CheckMortality: fp,
  CheckNonZeroSender: rs,
  CheckNonce: {
    extrinsic: {
      nonce: "Compact<Index>"
    },
    payload: {}
  },
  CheckSpecVersion: {
    extrinsic: {},
    payload: {
      specVersion: "u32"
    }
  },
  CheckTxVersion: {
    extrinsic: {},
    payload: {
      transactionVersion: "u32"
    }
  },
  CheckVersion: {
    extrinsic: {},
    payload: {
      specVersion: "u32"
    }
  },
  CheckWeight: rs,
  LockStakingStatus: rs,
  SkipCheckIfFeeless: hp,
  ValidateEquivocationReport: rs
}, d_ = J({}, x8, b8, w8, v8), Nc = [
  "CheckVersion",
  "CheckGenesis",
  "CheckEra",
  "CheckNonce",
  "CheckWeight",
  "ChargeTransactionPayment",
  "CheckBlockGasLimit"
];
function S8(n, e = {}) {
  const t = [...Object.keys(d_), ...Object.keys(e)];
  return n.filter((r) => !t.includes(r));
}
function pp(n, e, t = {}) {
  return n.map((r) => t[r] || d_[r]).filter((r) => !!r).reduce((r, i) => J(r, i[e]), {});
}
function E8(n, e) {
  if (!(e != null && e.length))
    return { DataType: Yn };
  const t = e.subarray(0, 2);
  return {
    DataType: n.findMetaEvent(t),
    value: {
      data: e.subarray(2),
      index: t
    }
  };
}
class f_ extends qi {
  constructor(t, r, i, s = "<unknown>", a = "<unknown>") {
    const o = (i == null ? void 0 : i.fields) || [];
    super(t, o.map(({ type: l }) => t.createLookupType(l)), r);
    b(this, "__internal__meta");
    b(this, "__internal__method");
    b(this, "__internal__names", null);
    b(this, "__internal__section");
    b(this, "__internal__typeDef");
    this.__internal__meta = i, this.__internal__method = a, this.__internal__section = s, this.__internal__typeDef = o.map(({ type: l }) => t.lookup.getTypeDef(l));
    const c = o.map(({ name: l }) => t.lookup.sanitizeField(l)[0]).filter((l) => !!l);
    c.length === o.length && (this.__internal__names = c, Hr(this, c, (l, u) => this[u]));
  }
  /**
   * @description The wrapped [[EventMetadata]]
   */
  get meta() {
    return this.__internal__meta;
  }
  /**
   * @description The method as a string
   */
  get method() {
    return this.__internal__method;
  }
  /**
   * @description The field names (as available)
   */
  get names() {
    return this.__internal__names;
  }
  /**
   * @description The section as a string
   */
  get section() {
    return this.__internal__section;
  }
  /**
   * @description The [[TypeDef]] for this event
   */
  get typeDef() {
    return this.__internal__typeDef;
  }
  /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */
  toHuman(t) {
    if (this.__internal__names !== null) {
      const r = {};
      for (let i = 0, s = this.__internal__names.length; i < s; i++)
        r[this.__internal__names[i]] = this[i].toHuman(t);
      return r;
    }
    return super.toHuman(t);
  }
}
class C8 extends Dt {
  // Currently we _only_ decode from Uint8Array, since we expect it to
  // be used via EventRecord
  constructor(e, t) {
    const { DataType: r, value: i } = E8(e, t);
    super(e, {
      index: "EventId",
      // eslint-disable-next-line sort-keys
      data: r
    }, i);
  }
  /**
   * @description The wrapped [[EventData]]
   */
  get data() {
    return this.getT("data");
  }
  /**
   * @description The [[EventId]], identifying the raw event
   */
  get index() {
    return this.getT("index");
  }
  /**
   * @description The [[EventMetadata]] with the documentation
   */
  get meta() {
    return this.data.meta;
  }
  /**
   * @description The method string identifying the event
   */
  get method() {
    return this.data.method;
  }
  /**
   * @description The section string identifying the event
   */
  get section() {
    return this.data.section;
  }
  /**
   * @description The [[TypeDef]] for the event
   */
  get typeDef() {
    return this.data.typeDef;
  }
  /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */
  toHuman(e) {
    return J({
      method: this.method,
      section: this.section
    }, e ? { docs: this.meta.docs.map((t) => t.toString()) } : null, super.toHuman(e));
  }
}
const h_ = 4;
class Ja extends Dt {
  constructor(e, t, { isSigned: r } = {}) {
    super(e, {
      signature: "ExtrinsicSignatureV4",
      // eslint-disable-next-line sort-keys
      method: "Call"
    }, Ja.decodeExtrinsic(e, t, r));
  }
  /** @internal */
  static decodeExtrinsic(e, t, r = !1) {
    if (t instanceof Ja)
      return t;
    if (t instanceof e.createClassUnsafe("Call"))
      return { method: t };
    if (te(t)) {
      const i = e.createTypeUnsafe("ExtrinsicSignatureV4", [t, { isSigned: r }]);
      return {
        method: e.createTypeUnsafe("Call", [t.subarray(i.encodedLength)]),
        signature: i
      };
    }
    return t || {};
  }
  /**
   * @description The length of the value when encoded as a Uint8Array
   */
  get encodedLength() {
    return this.toU8a().length;
  }
  /**
   * @description The [[Call]] this extrinsic wraps
   */
  get method() {
    return this.getT("method");
  }
  /**
   * @description The [[ExtrinsicSignatureV4]]
   */
  get signature() {
    return this.getT("signature");
  }
  /**
   * @description The version for the signature
   */
  get version() {
    return h_;
  }
  /**
   * @description Add an [[ExtrinsicSignatureV4]] to the extrinsic (already generated)
   */
  addSignature(e, t, r) {
    return this.signature.addSignature(e, t, r), this;
  }
  /**
   * @description Sign the extrinsic with a specific keypair
   */
  sign(e, t) {
    return this.signature.sign(this.method, e, t), this;
  }
  /**
   * @describe Adds a fake signature to the extrinsic
   */
  signFake(e, t) {
    return this.signature.signFake(this.method, e, t), this;
  }
}
const jl = 128, A8 = 0, Rc = new Uint8Array(), p_ = 4, m_ = new Uint8Array([0]), g_ = 127, mp = [
  "ExtrinsicUnknown",
  "ExtrinsicUnknown",
  "ExtrinsicUnknown",
  "ExtrinsicUnknown",
  "ExtrinsicV4"
];
function Ka(n, e, t) {
  if (e instanceof To)
    return e.unwrap();
  const r = (t & jl) === jl, i = mp[t & g_] || mp[0];
  return n.createTypeUnsafe(i, [e, { isSigned: r, version: t }]);
}
function P8(n, e, t = p_) {
  return te(e) || Array.isArray(e) || ye(e) ? k8(n, j(e), t) : e instanceof n.createClassUnsafe("Call") ? Ka(n, { method: e }, t) : Ka(n, e, t);
}
function k8(n, e, t) {
  if (!e.length)
    return Ka(n, new Uint8Array(), t);
  const [r, i] = co(e), s = r + i.toNumber();
  if (s > e.length)
    throw new Error(`Extrinsic: length less than remainder, expected at least ${s}, found ${e.length}`);
  const a = e.subarray(r, s);
  return Ka(n, a.subarray(1), a[0]);
}
class T8 extends Co {
  constructor(e, t, r) {
    super(e, t, r);
    const i = Object.keys(e.getSignedExtensionTypes()), s = (a) => this.inner.signature[a];
    for (let a = 0, o = i.length; a < o; a++)
      uo(this, i[a], s);
  }
  /**
   * @description The arguments passed to for the call, exposes args so it is compatible with [[Call]]
   */
  get args() {
    return this.method.args;
  }
  /**
   * @description The argument definitions, compatible with [[Call]]
   */
  get argsDef() {
    return this.method.argsDef;
  }
  /**
   * @description The actual `[sectionIndex, methodIndex]` as used in the Call
   */
  get callIndex() {
    return this.method.callIndex;
  }
  /**
   * @description The actual data for the Call
   */
  get data() {
    return this.method.data;
  }
  /**
   * @description The era for this extrinsic
   */
  get era() {
    return this.inner.signature.era;
  }
  /**
   * @description The length of the value when encoded as a Uint8Array
   */
  get encodedLength() {
    return this.toU8a().length;
  }
  /**
   * @description `true` id the extrinsic is signed
   */
  get isSigned() {
    return this.inner.signature.isSigned;
  }
  /**
   * @description The length of the actual data, excluding prefix
   */
  get length() {
    return this.toU8a(!0).length;
  }
  /**
   * @description The [[FunctionMetadataLatest]] that describes the extrinsic
   */
  get meta() {
    return this.method.meta;
  }
  /**
   * @description The [[Call]] this extrinsic wraps
   */
  get method() {
    return this.inner.method;
  }
  /**
   * @description The nonce for this extrinsic
   */
  get nonce() {
    return this.inner.signature.nonce;
  }
  /**
   * @description The actual [[EcdsaSignature]], [[Ed25519Signature]] or [[Sr25519Signature]]
   */
  get signature() {
    return this.inner.signature.signature;
  }
  /**
   * @description The [[Address]] that signed
   */
  get signer() {
    return this.inner.signature.signer;
  }
  /**
   * @description Forwards compat
   */
  get tip() {
    return this.inner.signature.tip;
  }
  /**
   * @description Returns the raw transaction version (not flagged with signing information)
  */
  get type() {
    return this.inner.version;
  }
  get inner() {
    return this.unwrap();
  }
  /**
   * @description Returns the encoded version flag
  */
  get version() {
    return this.type | (this.isSigned ? jl : A8);
  }
  /**
   * @description Checks if the source matches this in type
   */
  is(e) {
    return this.method.is(e);
  }
  unwrap() {
    return super.unwrap();
  }
}
class To extends T8 {
  constructor(t, r, { version: i } = {}) {
    super(t, P8(t, r, i));
    b(this, "__internal__hashCache");
  }
  /**
   * @description returns a hash of the contents
   */
  get hash() {
    return this.__internal__hashCache || (this.__internal__hashCache = super.hash), this.__internal__hashCache;
  }
  /**
   * @description Injects an already-generated signature into the extrinsic
   */
  addSignature(t, r, i) {
    return this.inner.addSignature(t, r, i), this.__internal__hashCache = void 0, this;
  }
  /**
   * @description Returns a breakdown of the hex encoding for this Codec
   */
  inspect() {
    const t = Me(...this.toU8aInner());
    return {
      inner: this.isSigned ? this.inner.inspect().inner : this.inner.method.inspect().inner,
      outer: [nt(t.length), new Uint8Array([this.version])]
    };
  }
  /**
   * @description Sign the extrinsic with a specific keypair
   */
  sign(t, r) {
    return this.inner.sign(t, r), this.__internal__hashCache = void 0, this;
  }
  /**
   * @describe Adds a fake signature to the extrinsic
   */
  signFake(t, r) {
    return this.inner.signFake(t, r), this.__internal__hashCache = void 0, this;
  }
  /**
   * @description Returns a hex string representation of the value
   */
  toHex(t) {
    return pe(this.toU8a(t));
  }
  /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */
  toHuman(t) {
    return J({}, {
      isSigned: this.isSigned,
      method: this.method.toHuman(t)
    }, this.isSigned ? {
      era: this.era.toHuman(t),
      nonce: this.nonce.toHuman(t),
      signature: this.signature.toHex(),
      signer: this.signer.toHuman(t),
      tip: this.tip.toHuman(t)
    } : null);
  }
  /**
   * @description Converts the Object to JSON, typically used for RPC transfers
   */
  toJSON() {
    return this.toHex();
  }
  /**
   * @description Returns the base runtime type name for this instance
   */
  toRawType() {
    return "Extrinsic";
  }
  /**
   * @description Encodes the value as a Uint8Array as per the SCALE specifications
   * @param isBare true when the value is not length-prefixed
   */
  toU8a(t) {
    const r = Me(...this.toU8aInner());
    return t ? r : wn(r);
  }
  toU8aInner() {
    return [
      new Uint8Array([this.version]),
      this.inner.toU8a()
    ];
  }
}
b(To, "LATEST_EXTRINSIC_VERSION", h_);
function N8(n) {
  const e = n.toString(2);
  let t = 0;
  for (; e[e.length - 1 - t] === "0"; )
    t++;
  return t;
}
function R8(n, e) {
  if (te(e) || ye(e) || Array.isArray(e))
    return O8(n, j(e));
  if (e) {
    if (qt(e))
      return I8(n, e);
  } else
    return [new vn(n), new vn(n)];
  throw new Error("Invalid data passed to Mortal era");
}
function I8(n, e) {
  const { current: t, period: r } = e;
  let i = Math.pow(2, Math.ceil(Math.log2(r)));
  i = Math.min(Math.max(i, 4), 65536);
  const s = t % i, a = Math.max(i >> 12, 1), o = s / a * a;
  return [new vn(n, i), new vn(n, o)];
}
function O8(n, e) {
  if (e.length === 0)
    return [new vn(n), new vn(n)];
  const t = fn(e.subarray(0, 1)).toNumber(), r = fn(e.subarray(1, 2)).toNumber(), i = t + (r << 8), s = 2 << i % 16, a = Math.max(s >> 12, 1), o = (i >> 4) * a;
  if (s < 4 || o >= s)
    throw new Error("Invalid data passed to Mortal era");
  return [new vn(n, s), new vn(n, o)];
}
function Wl(n = new Uint8Array()) {
  if (te(n))
    return !n.length || n[0] === 0 ? new Uint8Array([0]) : new Uint8Array([1, n[0], n[1]]);
  if (n) {
    if (n instanceof v_)
      return Wl(n.toU8a());
    if (ye(n))
      return Wl(Mt(n));
    if (qt(n)) {
      const e = Object.entries(n).map(([i, s]) => [i.toLowerCase(), s]), t = e.find(([i]) => i.toLowerCase() === "mortalera"), r = e.find(([i]) => i.toLowerCase() === "immortalera");
      return t ? { MortalEra: t[1] } : r ? { ImmortalEra: r[1] } : { MortalEra: n };
    }
  } else
    return new Uint8Array([0]);
  throw new Error("Invalid data passed to Era");
}
class y_ extends bn {
  constructor(e, t) {
    super(e, m_);
  }
}
class __ extends qi {
  constructor(e, t) {
    super(e, {
      period: vn,
      phase: vn
    }, R8(e, t));
  }
  /**
   * @description Encoded length for mortals occupy 2 bytes, different from the actual Tuple since it is encoded. This is a shortcut fro `toU8a().length`
   */
  get encodedLength() {
    return 2;
  }
  /**
   * @description The period of this Mortal wraps as a [[U64]]
   */
  get period() {
    return this[0];
  }
  /**
   * @description The phase of this Mortal wraps as a [[U64]]
   */
  get phase() {
    return this[1];
  }
  /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */
  toHuman() {
    return {
      period: Oa(this.period),
      phase: Oa(this.phase)
    };
  }
  /**
   * @description Returns a JSON representation of the actual value
   */
  toJSON() {
    return this.toHex();
  }
  /**
   * @description Encodes the value as a Uint8Array as per the parity-codec specifications
   * @param isBare true when the value has none of the type-specific prefixes (internal)
   * Period and phase are encoded:
   *   - The period of validity from the block hash found in the signing material.
   *   - The phase in the period that this transaction's lifetime begins (and, importantly,
   *     implies which block hash is included in the signature material). If the `period` is
   *     greater than 1 << 12, then it will be a factor of the times greater than 1<<12 that
   *     `period` is.
   */
  toU8a(e) {
    const t = this.period.toNumber(), r = Math.min(15, Math.max(1, N8(t) - 1)) + (this.phase.toNumber() / Math.max(t >> 12, 1) << 4);
    return new Uint8Array([
      r & 255,
      r >> 8
    ]);
  }
  /**
   * @description Get the block number of the start of the era whose properties this object describes that `current` belongs to.
   */
  birth(e) {
    const t = this.phase.toNumber(), r = this.period.toNumber();
    return ~~((Math.max(Tt(e).toNumber(), t) - t) / r) * r + t;
  }
  /**
   * @description Get the block number of the first block at which the era has ended.
   */
  death(e) {
    return this.birth(e) + this.period.toNumber();
  }
}
class v_ extends Ln {
  constructor(e, t) {
    super(e, {
      ImmortalEra: y_,
      MortalEra: __
    }, Wl(t));
  }
  /**
   * @description Override the encoded length method
   */
  get encodedLength() {
    return this.isImmortalEra ? this.asImmortalEra.encodedLength : this.asMortalEra.encodedLength;
  }
  /**
   * @description Returns the item as a [[ImmortalEra]]
   */
  get asImmortalEra() {
    if (!this.isImmortalEra)
      throw new Error(`Cannot convert '${this.type}' via asImmortalEra`);
    return this.inner;
  }
  /**
   * @description Returns the item as a [[MortalEra]]
   */
  get asMortalEra() {
    if (!this.isMortalEra)
      throw new Error(`Cannot convert '${this.type}' via asMortalEra`);
    return this.inner;
  }
  /**
   * @description `true` if Immortal
   */
  get isImmortalEra() {
    return this.index === 0;
  }
  /**
   * @description `true` if Mortal
   */
  get isMortalEra() {
    return this.index > 0;
  }
  /**
   * @description Encodes the value as a Uint8Array as per the parity-codec specifications
   * @param isBare true when the value has none of the type-specific prefixes (internal)
   */
  toU8a(e) {
    return this.isMortalEra ? this.asMortalEra.toU8a(e) : this.asImmortalEra.toU8a(e);
  }
}
const gp = [
  "ExtrinsicPayloadUnknown",
  "ExtrinsicPayloadUnknown",
  "ExtrinsicPayloadUnknown",
  "ExtrinsicPayloadUnknown",
  "ExtrinsicPayloadV4"
];
function M8(n, e, t = p_) {
  return e instanceof b_ ? e.unwrap() : n.createTypeUnsafe(gp[t] || gp[0], [e, { version: t }]);
}
class b_ extends Co {
  constructor(e, t, { version: r } = {}) {
    super(e, M8(e, t, r));
  }
  /**
   * @description The block [[BlockHash]] the signature applies to (mortal/immortal)
   */
  get blockHash() {
    return this.inner.blockHash;
  }
  /**
   * @description The [[ExtrinsicEra]]
   */
  get era() {
    return this.inner.era;
  }
  /**
   * @description The genesis block [[BlockHash]] the signature applies to
   */
  get genesisHash() {
    return this.inner.genesisHash || this.registry.createTypeUnsafe("Hash", []);
  }
  /**
   * @description The [[Bytes]] contained in the payload
   */
  get method() {
    return this.inner.method;
  }
  /**
   * @description The [[Index]]
   */
  get nonce() {
    return this.inner.nonce;
  }
  /**
   * @description The specVersion as a [[u32]] for this payload
   */
  get specVersion() {
    return this.inner.specVersion || this.registry.createTypeUnsafe("u32", []);
  }
  /**
   * @description The [[Balance]]
   */
  get tip() {
    return this.inner.tip || this.registry.createTypeUnsafe("Compact<Balance>", []);
  }
  /**
   * @description The transaction version as a [[u32]] for this payload
   */
  get transactionVersion() {
    return this.inner.transactionVersion || this.registry.createTypeUnsafe("u32", []);
  }
  /**
   * @description Compares the value of the input to see if there is a match
   */
  eq(e) {
    return this.inner.eq(e);
  }
  /**
   * @description Sign the payload with the keypair
   */
  sign(e) {
    const t = this.inner.sign(e);
    return {
      signature: pe(t)
    };
  }
  /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */
  toHuman(e) {
    return this.inner.toHuman(e);
  }
  /**
   * @description Converts the Object to JSON, typically used for RPC transfers
   */
  toJSON() {
    return this.toHex();
  }
  /**
   * @description Returns the base runtime type name for this instance
   */
  toRawType() {
    return "ExtrinsicPayload";
  }
  /**
   * @description Returns the string representation of the value
   */
  toString() {
    return this.toHex();
  }
  /**
   * @description Returns a serialized u8a form
   */
  toU8a(e) {
    return super.toU8a(e ? { method: !0 } : !1);
  }
}
class L8 extends Dt {
  constructor(e, t, { version: r = 0 } = {}) {
    throw super(e, {}), new Error(`Unsupported extrinsic payload version ${r}`);
  }
}
class D8 extends Dt {
  constructor(e, t, { isSigned: r = !1, version: i = 0 } = {}) {
    throw super(e, {}), new Error(`Unsupported ${r ? "" : "un"}signed extrinsic version ${i & g_}`);
  }
}
const yp = {
  address: "Address",
  blockHash: "Hash",
  blockNumber: "BlockNumber",
  era: "ExtrinsicEra",
  genesisHash: "Hash",
  method: "Call",
  nonce: "Compact<Index>",
  runtimeVersion: "RuntimeVersion",
  signedExtensions: "Vec<Text>",
  tip: "Compact<Balance>",
  version: "u8"
};
class U8 extends Dt {
  constructor(t, r) {
    const i = J({}, t.getSignedExtensionTypes(), t.getSignedExtensionExtra());
    super(t, J({}, i, yp), r);
    b(this, "__internal__extraTypes");
    this.__internal__extraTypes = {};
    const s = (a) => this.get(a);
    for (const [a, o] of Object.entries(i))
      yp[a] || (this.__internal__extraTypes[a] = o), uo(this, a, s);
  }
  get address() {
    return this.getT("address");
  }
  get blockHash() {
    return this.getT("blockHash");
  }
  get blockNumber() {
    return this.getT("blockNumber");
  }
  get era() {
    return this.getT("era");
  }
  get genesisHash() {
    return this.getT("genesisHash");
  }
  get method() {
    return this.getT("method");
  }
  get nonce() {
    return this.getT("nonce");
  }
  get runtimeVersion() {
    return this.getT("runtimeVersion");
  }
  get signedExtensions() {
    return this.getT("signedExtensions");
  }
  get tip() {
    return this.getT("tip");
  }
  get version() {
    return this.getT("version");
  }
  /**
   * @description Creates an representation of the structure as an ISignerPayload JSON
   */
  toPayload() {
    const t = {}, r = Object.keys(this.__internal__extraTypes);
    for (let i = 0, s = r.length; i < s; i++) {
      const a = r[i], o = this.getT(a);
      (!(o instanceof yr) || o.isSome) && (t[a] = o.toJSON());
    }
    return J(t, {
      // the known defaults as managed explicitly and has different
      // formatting in cases, e.g. we mostly expose a hex format here
      address: this.address.toString(),
      blockHash: this.blockHash.toHex(),
      blockNumber: this.blockNumber.toHex(),
      era: this.era.toHex(),
      genesisHash: this.genesisHash.toHex(),
      method: this.method.toHex(),
      nonce: this.nonce.toHex(),
      signedExtensions: this.signedExtensions.map((i) => i.toString()),
      specVersion: this.runtimeVersion.specVersion.toHex(),
      tip: this.tip.toHex(),
      transactionVersion: this.runtimeVersion.transactionVersion.toHex(),
      version: this.version.toNumber()
    });
  }
  /**
   * @description Creates a representation of the payload in raw Exrinsic form
   */
  toRaw() {
    const t = this.toPayload(), r = pe(this.registry.createTypeUnsafe("ExtrinsicPayload", [t, { version: t.version }]).toU8a({ method: !0 }));
    return {
      address: t.address,
      data: r,
      type: "payload"
    };
  }
}
function V8(n, e, t, r) {
  const i = t.length > 256 ? n.hash(t) : t;
  return e.sign(i, r);
}
class ql extends Dt {
  constructor(t, r) {
    super(t, J({ method: "Bytes" }, t.getSignedExtensionTypes(), t.getSignedExtensionExtra()), r);
    b(this, "__internal__signOptions");
    this.__internal__signOptions = {
      withType: t.createTypeUnsafe("ExtrinsicSignature", []) instanceof Ln
    };
  }
  /**
   * @description Returns a breakdown of the hex encoding for this Codec
   */
  inspect() {
    return super.inspect({ method: !0 });
  }
  /**
   * @description The block [[BlockHash]] the signature applies to (mortal/immortal)
   */
  get blockHash() {
    return this.getT("blockHash");
  }
  /**
   * @description The [[ExtrinsicEra]]
   */
  get era() {
    return this.getT("era");
  }
  /**
   * @description The genesis [[BlockHash]] the signature applies to (mortal/immortal)
   */
  get genesisHash() {
    return this.getT("genesisHash");
  }
  /**
   * @description The [[Bytes]] contained in the payload
   */
  get method() {
    return this.getT("method");
  }
  /**
   * @description The [[Index]]
   */
  get nonce() {
    return this.getT("nonce");
  }
  /**
   * @description The specVersion for this signature
   */
  get specVersion() {
    return this.getT("specVersion");
  }
  /**
   * @description The tip [[Balance]]
   */
  get tip() {
    return this.getT("tip");
  }
  /**
   * @description The transactionVersion for this signature
   */
  get transactionVersion() {
    return this.getT("transactionVersion");
  }
  /**
   * @description The (optional) asset id for this signature for chains that support transaction fees in assets
   */
  get assetId() {
    return this.getT("assetId");
  }
  /**
   * @description Sign the payload with the keypair
   */
  sign(t) {
    return V8(this.registry, t, this.toU8a({ method: !0 }), this.__internal__signOptions);
  }
}
const B8 = new Uint8Array(256).fill(1);
function Ic(n, e) {
  return n.createTypeUnsafe("Address", [te(e) ? pe(e) : e]);
}
class Ya extends Dt {
  constructor(t, r, { isSigned: i } = {}) {
    const s = t.getSignedExtensionTypes();
    super(t, J(
      // eslint-disable-next-line sort-keys
      { signer: "Address", signature: "ExtrinsicSignature" },
      s
    ), Ya.decodeExtrinsicSignature(r, i));
    b(this, "__internal__signKeys");
    this.__internal__signKeys = Object.keys(s), Hr(this, this.__internal__signKeys, (a) => this.get(a));
  }
  /** @internal */
  static decodeExtrinsicSignature(t, r = !1) {
    if (t) {
      if (t instanceof Ya)
        return t;
    } else
      return Rc;
    return r ? t : Rc;
  }
  /**
   * @description The length of the value when encoded as a Uint8Array
   */
  get encodedLength() {
    return this.isSigned ? super.encodedLength : 0;
  }
  /**
   * @description `true` if the signature is valid
   */
  get isSigned() {
    return !this.signature.isEmpty;
  }
  /**
   * @description The [[ExtrinsicEra]] (mortal or immortal) this signature applies to
   */
  get era() {
    return this.getT("era");
  }
  /**
   * @description The [[Index]] for the signature
   */
  get nonce() {
    return this.getT("nonce");
  }
  /**
   * @description The actual [[EcdsaSignature]], [[Ed25519Signature]] or [[Sr25519Signature]]
   */
  get signature() {
    return this.multiSignature.value || this.multiSignature;
  }
  /**
   * @description The raw [[ExtrinsicSignature]]
   */
  get multiSignature() {
    return this.getT("signature");
  }
  /**
   * @description The [[Address]] that signed
   */
  get signer() {
    return this.getT("signer");
  }
  /**
   * @description The [[Balance]] tip
   */
  get tip() {
    return this.getT("tip");
  }
  _injectSignature(t, r, i) {
    for (let s = 0, a = this.__internal__signKeys.length; s < a; s++) {
      const o = this.__internal__signKeys[s], c = i.get(o);
      Ne(c) || this.set(o, c);
    }
    return this.set("signer", t), this.set("signature", r), this;
  }
  /**
   * @description Adds a raw signature
   */
  addSignature(t, r, i) {
    return this._injectSignature(Ic(this.registry, t), this.registry.createTypeUnsafe("ExtrinsicSignature", [r]), new ql(this.registry, i));
  }
  /**
   * @description Creates a payload from the supplied options
   */
  createPayload(t, r) {
    const { era: i, runtimeVersion: { specVersion: s, transactionVersion: a } } = r;
    return new ql(this.registry, J({}, r, {
      era: i || m_,
      method: t.toHex(),
      specVersion: s,
      transactionVersion: a
    }));
  }
  /**
   * @description Generate a payload and applies the signature from a keypair
   */
  sign(t, r, i) {
    if (!(r != null && r.addressRaw))
      throw new Error(`Expected a valid keypair for signing, found ${_e(r)}`);
    const s = this.createPayload(t, i);
    return this._injectSignature(Ic(this.registry, r.addressRaw), this.registry.createTypeUnsafe("ExtrinsicSignature", [s.sign(r)]), s);
  }
  /**
   * @description Generate a payload and applies a fake signature
   */
  signFake(t, r, i) {
    if (!r)
      throw new Error(`Expected a valid address for signing, found ${_e(r)}`);
    const s = this.createPayload(t, i);
    return this._injectSignature(Ic(this.registry, r), this.registry.createTypeUnsafe("ExtrinsicSignature", [B8]), s);
  }
  /**
   * @description Encodes the value as a Uint8Array as per the SCALE specifications
   * @param isBare true when the value has none of the type-specific prefixes (internal)
   */
  toU8a(t) {
    return this.isSigned ? super.toU8a(t) : Rc;
  }
}
function _p(n) {
  if (te(n) || Array.isArray(n))
    return j(n);
  if (n) {
    if (ye(n))
      return Mt(n);
    if (Pe(n))
      return rn(n.toString());
  } else
    return new Uint8Array();
  throw new Error(`Unknown type passed to AccountId constructor, found typeof ${typeof n}`);
}
class w_ extends Zr {
  constructor(e, t = 264, r) {
    const i = _p(r);
    if (i.length * 8 < t && i.some((a) => a))
      throw new Error(`Invalid AccountId provided, expected ${t >> 3} bytes, found ${i.length}`);
    super(e, i, t);
  }
  /**
   * @description Compares the value of the input to see if there is a match
   */
  eq(e) {
    return super.eq(_p(e));
  }
  /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */
  toHuman() {
    return this.toJSON();
  }
  /**
   * @description Converts the Object to JSON, typically used for RPC transfers
   */
  toJSON() {
    return this.toString();
  }
  /**
   * @description Converts the value in a best-fit primitive form
   */
  toPrimitive() {
    return this.toJSON();
  }
  /**
   * @description Returns the string representation of the value
   */
  toString() {
    return bo(this, this.registry.chainSS58);
  }
  /**
   * @description Returns the base runtime type name for this instance
   */
  toRawType() {
    return "AccountId";
  }
}
class Qa extends w_ {
  constructor(e, t) {
    super(e, 256, t);
  }
}
class H8 extends w_ {
  constructor(e, t) {
    super(e, 264, t);
  }
}
const F8 = 239, vp = 252, bp = 253, wp = 254, j8 = new Z(F8), W8 = new Z(1).shln(16), q8 = new Z(1).shln(32);
function x_(n) {
  return n instanceof kt ? n.toBn() : Yt(n) || xe(n) || ye(n) || te(n) || vr(n) ? n : x_(rn(n));
}
class kt extends Ts {
  constructor(e, t = new Z(0)) {
    super(e, x_(t));
  }
  static calcLength(e) {
    const t = Tt(e);
    return t.lte(j8) ? 1 : t.lt(W8) ? 2 : t.lt(q8) ? 4 : 8;
  }
  static readLength(e) {
    const t = e[0];
    return t === vp ? [1, 2] : t === bp ? [1, 4] : t === wp ? [1, 8] : [0, 1];
  }
  static writeLength(e) {
    switch (e.length) {
      case 2:
        return new Uint8Array([vp]);
      case 4:
        return new Uint8Array([bp]);
      case 8:
        return new Uint8Array([wp]);
      default:
        return new Uint8Array([]);
    }
  }
  /**
   * @description Compares the value of the input to see if there is a match
   */
  eq(e) {
    return Yt(e) || xe(e) ? super.eq(e) : super.eq(this.registry.createTypeUnsafe("AccountIndex", [e]));
  }
  /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */
  toHuman() {
    return this.toJSON();
  }
  /**
   * @description Converts the Object to JSON, typically used for RPC transfers
   */
  toJSON() {
    return this.toString();
  }
  /**
   * @description Converts the value in a best-fit primitive form
   */
  toPrimitive() {
    return this.toJSON();
  }
  /**
   * @description Returns the string representation of the value
   */
  toString() {
    const e = kt.calcLength(this);
    return bo(this.toU8a().subarray(0, e), this.registry.chainSS58);
  }
  /**
   * @description Returns the base runtime type name for this instance
   */
  toRawType() {
    return "AccountIndex";
  }
}
class z8 extends Dt {
  constructor(e, t) {
    super(e, {
      header: "Header",
      // eslint-disable-next-line sort-keys
      extrinsics: "Vec<Extrinsic>"
    }, t);
  }
  /**
   * @description Encodes a content [[Hash]] for the block
   */
  get contentHash() {
    return this.registry.hash(this.toU8a());
  }
  /**
   * @description The [[Extrinsic]] contained in the block
   */
  get extrinsics() {
    return this.getT("extrinsics");
  }
  /**
   * @description Block/header [[Hash]]
   */
  get hash() {
    return this.header.hash;
  }
  /**
   * @description The [[Header]] of the block
   */
  get header() {
    return this.getT("header");
  }
}
function pd(n, e) {
  return e.fields.reduce((t, { name: r, type: i }, s) => (t[r.unwrapOr(`param${s}`).toString()] = n.createLookupType(i), t), {});
}
function X8(n, e, t) {
  const { args: r, callIndex: i } = e, s = i instanceof S_ ? i.toU8a() : i, a = t || n.findMetaCall(s).meta;
  return {
    args: r,
    argsDef: pd(n, a),
    callIndex: i,
    meta: a
  };
}
function G8(n, e, t) {
  const r = n.firstCallIndex.slice();
  r.set(e.subarray(0, 2), 0);
  const i = t || n.findMetaCall(r).meta;
  return {
    args: e.subarray(2),
    argsDef: pd(n, i),
    callIndex: r,
    meta: i
  };
}
function Z8(n, e = new Uint8Array(), t) {
  if (te(e) || ye(e))
    return G8(n, j(e), t);
  if (qt(e) && e.callIndex && e.args)
    return X8(n, e, t);
  throw new Error(`Call: Cannot decode value '${e}' of type ${typeof e}`);
}
class S_ extends Zr {
  constructor(e, t) {
    super(e, t, 16);
  }
  /**
   * @description Converts the value in a best-fit primitive form
   */
  toPrimitive() {
    return this.toHex();
  }
}
class J8 extends Dt {
  constructor(t, r, i) {
    var e = (...args) => {
      super(...args);
      b(this, "_meta");
    };
    const s = Z8(t, r, i);
    try {
      e(t, {
        callIndex: S_,
        // eslint-disable-next-line sort-keys
        args: Dt.with(s.argsDef)
      }, s);
    } catch (a) {
      let o = "unknown.unknown";
      try {
        const c = t.findMetaCall(s.callIndex);
        o = `${c.section}.${c.method}`;
      } catch {
      }
      throw new Error(`Call: failed decoding ${o}:: ${a.message}`);
    }
    this._meta = s.meta;
  }
  /**
   * @description The arguments for the function call
   */
  get args() {
    return [...this.getT("args").values()];
  }
  /**
   * @description The argument definitions
   */
  get argsDef() {
    return pd(this.registry, this.meta);
  }
  /**
   * @description The argument entries
   */
  get argsEntries() {
    return [...this.getT("args").entries()];
  }
  /**
   * @description The encoded `[sectionIndex, methodIndex]` identifier
   */
  get callIndex() {
    return this.getT("callIndex").toU8a();
  }
  /**
   * @description The encoded data
   */
  get data() {
    return this.getT("args").toU8a();
  }
  /**
   * @description The [[FunctionMetadata]]
   */
  get meta() {
    return this._meta;
  }
  /**
   * @description Returns the name of the method
   */
  get method() {
    return this.registry.findMetaCall(this.callIndex).method;
  }
  /**
   * @description Returns the module containing the method
   */
  get section() {
    return this.registry.findMetaCall(this.callIndex).section;
  }
  /**
   * @description Checks if the source matches this in type
   */
  is(t) {
    return t.callIndex[0] === this.callIndex[0] && t.callIndex[1] === this.callIndex[1];
  }
  /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */
  toHuman(t) {
    let r;
    try {
      r = this.registry.findMetaCall(this.callIndex);
    } catch {
    }
    return J({
      args: this.argsEntries.reduce((i, [s, a]) => J(i, { [s]: a.toHuman(t) }), {}),
      method: r == null ? void 0 : r.method,
      section: r == null ? void 0 : r.section
    }, t && r ? { docs: r.meta.docs.map((i) => i.toString()) } : null);
  }
  /**
   * @description Returns the base runtime type name for this instance
   */
  toRawType() {
    return "Call";
  }
}
function oa(n, e, t, r = !0) {
  return t && ue(t.unwrapOrDefault) ? t : n.createTypeUnsafe(e, [
    r ? Mr(t) || Ne(t) ? null : Array.isArray(t) ? t : [t] : t
  ]);
}
function K8(n, e, t) {
  return e === "ss58Format" ? oa(n, "Option<u32>", t, !1) : e === "tokenDecimals" ? oa(n, "Option<Vec<u32>>", t) : e === "tokenSymbol" ? oa(n, "Option<Vec<Text>>", t) : e === "isEthereum" ? oa(n, "Bool", t, !1) : t;
}
function Y8(n, e) {
  return (
    // allow decoding from a map as well (ourselves)
    (e && ue(e.entries) ? [...e.entries()] : Object.entries(e || {})).reduce((t, [r, i]) => (t[r] = K8(n, r, i), t), {
      isEthereum: n.createTypeUnsafe("Bool", []),
      ss58Format: n.createTypeUnsafe("Option<u32>", []),
      tokenDecimals: n.createTypeUnsafe("Option<Vec<u32>>", []),
      tokenSymbol: n.createTypeUnsafe("Option<Vec<Text>>", [])
    })
  );
}
class Q8 extends wg {
  constructor(e, t) {
    super(e, Y8(e, t));
  }
  /**
   * @description The chain uses Ethereum addresses
   */
  get isEthereum() {
    return this.getT("isEthereum");
  }
  /**
   * @description The chain ss58Format
   */
  get ss58Format() {
    return this.getT("ss58Format");
  }
  /**
   * @description The decimals for each of the tokens
   */
  get tokenDecimals() {
    return this.getT("tokenDecimals");
  }
  /**
   * @description The symbols for the tokens
   */
  get tokenSymbol() {
    return this.getT("tokenSymbol");
  }
}
const $8 = /* @__PURE__ */ Ze("aura"), e5 = /* @__PURE__ */ Ze("BABE"), t5 = /* @__PURE__ */ Ze("FRNK"), n5 = /* @__PURE__ */ Ze("pow_"), r5 = /* @__PURE__ */ Ze("nmbs");
function i5(n, e, t) {
  return t[n.createTypeUnsafe("RawAuraPreDigest", [e.toU8a(!0)]).slotNumber.mod(new Z(t.length)).toNumber()];
}
function s5(n, e, t) {
  const r = n.createTypeUnsafe("RawBabePreDigestCompat", [e.toU8a(!0)]);
  return t[r.value.toNumber()];
}
function a5(n, e) {
  return n.createTypeUnsafe("AccountId", [e]);
}
class o5 extends Zr {
  constructor(e, t) {
    super(e, xe(t) ? Lt(t, { isLe: !1 }) : t, 32);
  }
  /**
   * @description `true` if the engine matches aura
   */
  get isAura() {
    return this.eq($8);
  }
  /**
   * @description `true` is the engine matches babe
   */
  get isBabe() {
    return this.eq(e5);
  }
  /**
   * @description `true` is the engine matches grandpa
   */
  get isGrandpa() {
    return this.eq(t5);
  }
  /**
   * @description `true` is the engine matches pow
   */
  get isPow() {
    return this.eq(n5);
  }
  /**
   * @description `true` is the engine matches nimbus
   */
  get isNimbus() {
    return this.eq(r5);
  }
  /**
   * @description From the input bytes, decode into an author
   */
  extractAuthor(e, t) {
    if (t != null && t.length) {
      if (this.isAura)
        return i5(this.registry, e, t);
      if (this.isBabe)
        return s5(this.registry, e, t);
    }
    if (this.isPow || this.isNimbus)
      return a5(this.registry, e);
  }
  /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */
  toHuman() {
    return this.toString();
  }
  /**
   * @description Returns the base runtime type name for this instance
   */
  toRawType() {
    return "ConsensusEngineId";
  }
  /**
   * @description Override the default toString to return a 4-byte string
   */
  toString() {
    return this.isAscii ? Nn(this) : pe(this);
  }
}
const xp = new Uint8Array([255]);
function c5(n, e) {
  const t = rn(e);
  return t.length === 32 ? n.createTypeUnsafe("AccountId", [t]) : n.createTypeUnsafe("AccountIndex", [fn(t)]);
}
function l5(n, e) {
  if (e.length === 32)
    return n.createTypeUnsafe("AccountId", [e]);
  if (e[0] === 255)
    return n.createTypeUnsafe("AccountId", [e.subarray(1)]);
  const [t, r] = kt.readLength(e);
  return n.createTypeUnsafe("AccountIndex", [fn(e.subarray(t, t + r))]);
}
function u5(n, e) {
  return e instanceof E_ ? e.inner : e instanceof Qa || e instanceof kt ? e : Yt(e) || xe(e) || vr(e) ? n.createTypeUnsafe("AccountIndex", [e]) : Array.isArray(e) || ye(e) || te(e) ? l5(n, j(e)) : c5(n, e);
}
class E_ extends Co {
  constructor(e, t = new Uint8Array()) {
    super(e, u5(e, t));
  }
  /**
   * @description The length of the value when encoded as a Uint8Array
   */
  get encodedLength() {
    const e = this._rawLength;
    return e + // for 1 byte AccountIndexes, we are not adding a specific prefix
    (e > 1 ? 1 : 0);
  }
  /**
   * @description The length of the raw value, either AccountIndex or AccountId
   */
  get _rawLength() {
    return this.inner instanceof kt ? kt.calcLength(this.inner) : this.inner.encodedLength;
  }
  /**
   * @description Returns a breakdown of the hex encoding for this Codec
   */
  inspect() {
    const e = this.inner.toU8a().subarray(0, this._rawLength);
    return {
      outer: [
        new Uint8Array(this.inner instanceof kt ? kt.writeLength(e) : xp),
        e
      ]
    };
  }
  /**
   * @description Returns a hex string representation of the value
   */
  toHex() {
    return pe(this.toU8a());
  }
  /**
   * @description Returns the base runtime type name for this instance
   */
  toRawType() {
    return "Address";
  }
  /**
   * @description Encodes the value as a Uint8Array as per the SCALE specifications
   * @param isBare true when the value has none of the type-specific prefixes (internal)
   */
  toU8a(e) {
    const t = this.inner.toU8a().subarray(0, this._rawLength);
    return e ? t : Me(this.inner instanceof kt ? kt.writeLength(t) : xp, t);
  }
}
function Sp(n, e) {
  return [0, 32].includes(e.length) ? { Id: e } : e.length === 20 ? { Address20: e } : e.length <= 8 ? { Index: n.createTypeUnsafe("AccountIndex", [e]).toNumber() } : e;
}
function d5(n, e) {
  return e instanceof Qa ? { Id: e } : te(e) ? Sp(n, e) : e instanceof zl ? e : e instanceof kt || Yt(e) || xe(e) ? { Index: xe(e) ? e : e.toNumber() } : Pe(e) ? Sp(n, rn(e.toString())) : e;
}
class zl extends Ln {
  constructor(e, t) {
    super(e, {
      Id: "AccountId",
      Index: "Compact<AccountIndex>",
      Raw: "Bytes",
      // eslint-disable-next-line sort-keys
      Address32: "H256",
      // eslint-disable-next-line sort-keys
      Address20: "H160"
    }, d5(e, t));
  }
  /**
   * @description Returns a breakdown of the hex encoding for this Codec
   */
  inspect() {
    const { inner: e, outer: t = [] } = this.inner.inspect();
    return {
      inner: e,
      outer: [new Uint8Array([this.index]), ...t]
    };
  }
  /**
   * @description Returns the string representation of the value
   */
  toString() {
    return this.value.toString();
  }
}
const $a = 128, md = 0, f5 = 127, C_ = 0;
function Ep(n) {
  return n ? new Uint8Array([$a | C_]) : new Uint8Array([md]);
}
function h5(n) {
  return n.length ? n.subarray(0, 1) : new Uint8Array([md]);
}
function p5(n, e) {
  return new Uint8Array([
    (new Mi(n, e.aye).isTrue ? $a : md) | n.createTypeUnsafe("Conviction", [e.conviction || C_]).index
  ]);
}
function m5(n, e) {
  return te(e) ? h5(e) : Ne(e) || e instanceof Boolean || bs(e) ? Ep(new Mi(n, e).isTrue) : xe(e) ? Ep(e < 0) : p5(n, e);
}
class g5 extends Zr {
  constructor(t, r) {
    const i = m5(t, r);
    super(t, i, 8);
    b(this, "__internal__aye");
    b(this, "__internal__conviction");
    this.__internal__aye = (i[0] & $a) === $a, this.__internal__conviction = this.registry.createTypeUnsafe("Conviction", [i[0] & f5]);
  }
  /**
   * @description returns a V2 conviction
   */
  get conviction() {
    return this.__internal__conviction;
  }
  /**
   * @description true if the wrapped value is a positive vote
   */
  get isAye() {
    return this.__internal__aye;
  }
  /**
   * @description true if the wrapped value is a negative vote
   */
  get isNay() {
    return !this.isAye;
  }
  /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */
  toHuman(t) {
    return {
      conviction: this.conviction.toHuman(t),
      vote: this.isAye ? "Aye" : "Nay"
    };
  }
  /**
   * @description Converts the value in a best-fit primitive form
   */
  toPrimitive() {
    return {
      aye: this.isAye,
      conviction: this.conviction.toPrimitive()
    };
  }
  /**
   * @description Returns the base runtime type name for this instance
   */
  toRawType() {
    return "Vote";
  }
}
function Cp(n) {
  return te(n) || Array.isArray(n) ? j(n) : ye(n) || W3(n.toString()) ? Mt(n.toString()) : Pe(n) ? j(n) : n;
}
class A_ extends Zr {
  constructor(e, t = new Uint8Array()) {
    super(e, Cp(t), 160);
  }
  /**
   * @description Compares the value of the input to see if there is a match
   */
  eq(e) {
    return !!e && super.eq(Cp(e));
  }
  /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */
  toHuman() {
    return this.toJSON();
  }
  /**
   * @description Converts the Object to JSON, typically used for RPC transfers
   */
  toJSON() {
    return this.toString();
  }
  /**
   * @description Converts the value in a best-fit primitive form
   */
  toPrimitive() {
    return this.toJSON();
  }
  /**
   * @description Returns the string representation of the value
   */
  toString() {
    return Gu(this);
  }
  /**
   * @description Returns the base runtime type name for this instance
   */
  toRawType() {
    return "AccountId";
  }
}
const y5 = new Uint8Array([255]);
function _5(n, e) {
  const t = rn(e);
  return t.length === 20 ? n.createTypeUnsafe("EthereumAccountId", [t]) : n.createTypeUnsafe("AccountIndex", [fn(t)]);
}
function v5(n, e) {
  if (e.length === 20)
    return n.createTypeUnsafe("EthereumAccountId", [e]);
  if (e[0] === 255)
    return n.createTypeUnsafe("EthereumAccountId", [e.subarray(1)]);
  const [t, r] = kt.readLength(e);
  return n.createTypeUnsafe("AccountIndex", [fn(e.subarray(t, t + r))]);
}
function b5(n, e) {
  return e instanceof P_ ? e.inner : e instanceof A_ || e instanceof kt ? e : te(e) || Array.isArray(e) || ye(e) ? v5(n, j(e)) : Yt(e) || xe(e) || vr(e) ? n.createTypeUnsafe("AccountIndex", [e]) : _5(n, e);
}
class P_ extends Co {
  constructor(e, t = new Uint8Array()) {
    super(e, b5(e, t));
  }
  /**
   * @description The length of the value when encoded as a Uint8Array
   */
  get encodedLength() {
    const e = this._rawLength;
    return e + // for 1 byte AccountIndexes, we are not adding a specific prefix
    (e > 1 ? 1 : 0);
  }
  /**
   * @description The length of the raw value, either AccountIndex or AccountId
   */
  get _rawLength() {
    return this.inner instanceof kt ? kt.calcLength(this.inner) : this.inner.encodedLength;
  }
  /**
   * @description Returns a hex string representation of the value
   */
  toHex() {
    return pe(this.toU8a());
  }
  /**
   * @description Returns the base runtime type name for this instance
   */
  toRawType() {
    return "Address";
  }
  /**
   * @description Encodes the value as a Uint8Array as per the SCALE specifications
   * @param isBare true when the value has none of the type-specific prefixes (internal)
   */
  toU8a(e) {
    const t = this.inner.toU8a().subarray(0, this._rawLength);
    return e ? t : Me(this.inner instanceof kt ? kt.writeLength(t) : y5, t);
  }
}
function w5(n, e) {
  const t = e[0];
  if (t) {
    if (t >= 1 && t <= 33) {
      const r = t - 1, i = e.subarray(1, r + 1);
      return [n.createTypeUnsafe("Raw", [i]), 1];
    } else if (t >= 34 && t <= 37)
      return [e.subarray(1, 32 + 1), t - 32];
  } else
    return [void 0, void 0];
  throw new Error(`Unable to decode Data, invalid indicator byte ${t}`);
}
function x5(n, e) {
  return te(e) || Pe(e) ? w5(n, j(e)) : e ? [e, void 0] : [void 0, void 0];
}
class S5 extends Ln {
  constructor(e, t) {
    if (super(e, {
      None: "Null",
      Raw: "Bytes",
      // eslint-disable-next-line sort-keys
      BlakeTwo256: "H256",
      Sha256: "H256",
      // eslint-disable-next-line sort-keys
      Keccak256: "H256",
      ShaThree256: "H256"
      // 5
    }, ...x5(e, t)), this.isRaw && this.asRaw.length > 32)
      throw new Error("Data.Raw values are limited to a maximum length of 32 bytes");
  }
  get asBlakeTwo256() {
    return this.value;
  }
  get asKeccak256() {
    return this.value;
  }
  get asRaw() {
    return this.value;
  }
  get asSha256() {
    return this.value;
  }
  get asShaThree256() {
    return this.value;
  }
  get isBlakeTwo256() {
    return this.index === 2;
  }
  get isKeccak256() {
    return this.index === 4;
  }
  get isNone() {
    return this.index === 0;
  }
  get isRaw() {
    return this.index === 1;
  }
  get isSha256() {
    return this.index === 3;
  }
  get isShaThree256() {
    return this.index === 5;
  }
  /**
   * @description The encoded length
   */
  get encodedLength() {
    return this.toU8a().length;
  }
  /**
   * @description Encodes the value as a Uint8Array as per the SCALE specifications
   */
  toU8a() {
    if (this.index === 0)
      return new Uint8Array(1);
    if (this.index === 1) {
      const t = this.value.toU8a(!0), r = Math.min(t.length, 32), i = new Uint8Array(r + 1);
      return i.set([r + 1], 0), i.set(t.subarray(0, r), 1), i;
    }
    const e = new Uint8Array(33);
    return e.set([this.index + 32], 0), e.set(this.value.toU8a(), 1), e;
  }
}
const E5 = {
  // opaque
  Blake2_128: [16, !1],
  Blake2_128Concat: [16, !0],
  Blake2_256: [32, !1],
  Identity: [0, !0],
  Twox128: [16, !1],
  Twox256: [32, !1],
  Twox64Concat: [8, !0]
};
function C5(n) {
  if (te(n) || !n || Pe(n))
    return { key: n };
  if (n instanceof No)
    return {
      key: n,
      method: n.method,
      section: n.section
    };
  if (ue(n))
    return {
      key: n(),
      method: n.method,
      section: n.section
    };
  if (Array.isArray(n)) {
    const [e, t = []] = n;
    if (!ue(e))
      throw new Error("Expected function input for key construction");
    if (e.meta && e.meta.type.isMap) {
      const r = e.meta.type.asMap;
      if (!Array.isArray(t) || t.length !== r.hashers.length)
        throw new Error(`Expected an array of ${r.hashers.length} values as params to a Map query`);
    }
    return {
      key: e(...t),
      method: e.method,
      section: e.section
    };
  }
  throw new Error(`Unable to convert input ${n} to StorageKey`);
}
function A5(n, e, t) {
  let r = 32;
  const i = t.length, s = new Array(i);
  for (let a = 0; a < i; a++) {
    const [o, c] = t[a], [l, u] = E5[o.type], f = u ? n.createTypeUnsafe(Rs(n.lookup, c), [e.subarray(r + l)]) : n.createTypeUnsafe("Raw", [e.subarray(r, r + l)]);
    r += l + (u ? f.encodedLength : 0), s[a] = f;
  }
  return s;
}
function P5(n, e, t) {
  if (!t || !t.type.isMap)
    return [];
  const { hashers: r, key: i } = t.type.asMap, s = r.length === 1 ? [i] : n.lookup.getSiType(i).def.asTuple;
  return A5(n, e, r.map((a, o) => [a, s[o]]));
}
function k5(n) {
  if (n instanceof No)
    return n.meta;
  if (ue(n))
    return n.meta;
  if (Array.isArray(n)) {
    const [e] = n;
    return e.meta;
  }
}
function T5(n, e) {
  if (e instanceof No)
    return e.outputType;
  if (ue(e))
    return Fl(n, e.meta.type);
  if (Array.isArray(e)) {
    const [t] = e;
    if (t.meta)
      return Fl(n, t.meta.type);
  }
  return "Raw";
}
class No extends Xs {
  constructor(t, r, i = {}) {
    const { key: s, method: a, section: o } = C5(r);
    super(t, s);
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore This is assigned via this.decodeArgsFromMeta()
    b(this, "__internal__args");
    b(this, "__internal__meta");
    b(this, "__internal__outputType");
    b(this, "__internal__method");
    b(this, "__internal__section");
    this.__internal__outputType = T5(t, r), this.setMeta(k5(r), i.section || o, i.method || a);
  }
  /**
   * @description Return the decoded arguments (applicable to map with decodable values)
   */
  get args() {
    return this.__internal__args;
  }
  /**
   * @description The metadata or `undefined` when not available
   */
  get meta() {
    return this.__internal__meta;
  }
  /**
   * @description The key method or `undefined` when not specified
   */
  get method() {
    return this.__internal__method;
  }
  /**
   * @description The output type
   */
  get outputType() {
    return this.__internal__outputType;
  }
  /**
   * @description The key section or `undefined` when not specified
   */
  get section() {
    return this.__internal__section;
  }
  is(t) {
    return t.section === this.section && t.method === this.method;
  }
  /**
   * @description Sets the meta for this key
   */
  setMeta(t, r, i) {
    this.__internal__meta = t, this.__internal__method = i || this.__internal__method, this.__internal__section = r || this.__internal__section, t && (this.__internal__outputType = Fl(this.registry, t.type));
    try {
      this.__internal__args = P5(this.registry, this.toU8a(!0), t);
    } catch {
    }
    return this;
  }
  /**
   * @description Returns the Human representation for this type
   */
  toHuman() {
    return this.__internal__args.length ? this.__internal__args.map((t) => t.toHuman()) : super.toHuman();
  }
  /**
   * @description Returns the raw type for this
   */
  toRawType() {
    return "StorageKey";
  }
}
const N5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BitVec: iT,
  Bool: Mi,
  Bytes: Xs,
  Data: S5,
  F32: Bh,
  F64: Hh,
  GenericAccountId: Qa,
  GenericAccountId32: Qa,
  GenericAccountId33: H8,
  GenericAccountIndex: kt,
  GenericAddress: zl,
  GenericBlock: z8,
  GenericCall: J8,
  GenericChainProperties: Q8,
  GenericConsensusEngineId: o5,
  GenericEthereumAccountId: A_,
  GenericEthereumLookupSource: P_,
  GenericEvent: C8,
  GenericEventData: f_,
  GenericExtrinsic: To,
  GenericExtrinsicEra: v_,
  GenericExtrinsicPayload: b_,
  GenericExtrinsicPayloadUnknown: L8,
  GenericExtrinsicPayloadV4: ql,
  GenericExtrinsicSignatureV4: Ya,
  GenericExtrinsicUnknown: D8,
  GenericExtrinsicV4: Ja,
  GenericImmortalEra: y_,
  GenericLookupSource: E_,
  GenericMortalEra: __,
  GenericMultiAddress: zl,
  GenericSignerPayload: U8,
  GenericVote: g5,
  I128: qh,
  I16: jh,
  I256: zh,
  I32: Vl,
  I64: Wh,
  I8: Fh,
  ISize: Xh,
  Null: Yn,
  OptionBool: pT,
  StorageKey: No,
  Text: Tu,
  Type: mT,
  U128: Jh,
  U16: Zh,
  U256: Kh,
  U32: Ts,
  U64: vn,
  U8: Gh,
  USize: Yh,
  bool: Mi,
  f32: Bh,
  f64: Hh,
  i128: qh,
  i16: jh,
  i256: zh,
  i32: Vl,
  i64: Wh,
  i8: Fh,
  isize: Xh,
  u128: Jh,
  u16: Zh,
  u256: Kh,
  u32: Ts,
  u64: vn,
  u8: Gh,
  usize: Yh
}, Symbol.toStringTag, { value: "Module" }));
function k_(n) {
  return ({ name: e }) => n(e);
}
const gd = /* @__PURE__ */ k_(Ee), T_ = /* @__PURE__ */ k_((n) => n.toString());
function R5(n, e) {
  return n.callIndex[0] === e[0] && n.callIndex[1] === e[1];
}
function I5(n, e, t, r) {
  const i = r.fields, s = Ee(r.name), a = (...o) => {
    if (i.length !== o.length)
      throw new Error(`Extrinsic ${e}.${s} expects ${i.length} arguments, got ${o.length}.`);
    return n.createTypeUnsafe("Call", [{ args: o, callIndex: t }, r]);
  };
  return a.is = (o) => R5(o, t), a.callIndex = t, a.meta = r, a.method = s, a.section = e, a.toJSON = () => r.toJSON(), a;
}
function N_({ calls: n }) {
  return n.isSome;
}
function R_(n, e, t, r, i) {
  const { fields: s, index: a } = t, o = s.length, c = new Array(o);
  for (let l = 0; l < o; l++) {
    const { name: u, type: f, typeName: m } = s[l];
    c[l] = J({
      name: Ee(u.unwrapOr(`param${l}`)),
      type: Rs(e, f)
    }, m.isSome ? { typeName: m.unwrap() } : null);
  }
  return I5(n, r, new Uint8Array([i, a.toNumber()]), n.createTypeUnsafe("FunctionMetadataLatest", [J({ args: c }, t)]));
}
function O5(n, { lookup: e, pallets: t }, r) {
  const i = {}, s = t.filter(N_);
  for (let a = 0, o = s.length; a < o; a++) {
    const { calls: c, index: l, name: u } = s[a], f = Ee(u), m = r >= 12 ? l.toNumber() : a;
    Ut(i, f, () => zi(e, c.unwrap(), gd, (y) => R_(n, e, y, f, m)));
  }
  return i;
}
function Oc(n, e) {
  return e.toNumber() >= 2 ? n.createTypeUnsafe("StorageHasherV10", [e.toNumber() + 1]) : n.createTypeUnsafe("StorageHasherV10", [e]);
}
function M5(n, e) {
  return e.isMap ? [J({}, e.asMap, {
    hasher: Oc(n, e.asMap.hasher)
  }), 1] : e.isDoubleMap ? [J({}, e.asDoubleMap, {
    hasher: Oc(n, e.asDoubleMap.hasher),
    key2Hasher: Oc(n, e.asDoubleMap.key2Hasher)
  }), 2] : [e.asPlain, 0];
}
function L5(n, e) {
  const t = e.storage.unwrapOr(null);
  return n.createTypeUnsafe("ModuleMetadataV10", [J({}, e, {
    storage: t ? J({}, t, {
      items: t.items.map((r) => J({}, r, {
        type: n.createTypeUnsafe("StorageEntryTypeV10", M5(n, r.type))
      }))
    }) : null
  })]);
}
function D5(n, { modules: e }) {
  return n.createTypeUnsafe("MetadataV10", [{
    modules: e.map((t) => L5(n, t))
  }]);
}
function U5(n, { modules: e }) {
  return n.createTypeUnsafe("MetadataV11", [{
    // This is new in V11, pass V0 here - something non-existing, telling the API to use
    // the fallback for this information (on-chain detection)
    extrinsic: {
      signedExtensions: [],
      version: 0
    },
    modules: e
  }]);
}
function V5(n, { extrinsic: e, modules: t }) {
  return n.createTypeUnsafe("MetadataV12", [{
    extrinsic: e,
    modules: t.map((r) => n.createTypeUnsafe("ModuleMetadataV12", [J({}, r, { index: 255 })]))
  }]);
}
function B5(n, e) {
  return n.createTypeUnsafe("MetadataV13", [e]);
}
const H5 = {
  assets: {
    Approval: "AssetApproval",
    ApprovalKey: "AssetApprovalKey",
    Balance: "TAssetBalance",
    DestroyWitness: "AssetDestroyWitness"
  },
  babe: {
    EquivocationProof: "BabeEquivocationProof"
  },
  balances: {
    Status: "BalanceStatus"
  },
  beefy: {
    AuthorityId: "BeefyId"
  },
  contracts: {
    StorageKey: "ContractStorageKey"
  },
  electionProviderMultiPhase: {
    Phase: "ElectionPhase"
  },
  ethereum: {
    Block: "EthBlock",
    Header: "EthHeader",
    Receipt: "EthReceipt",
    Transaction: "EthTransaction",
    TransactionStatus: "EthTransactionStatus"
  },
  evm: {
    Account: "EvmAccount",
    Log: "EvmLog",
    Vicinity: "EvmVicinity"
  },
  grandpa: {
    Equivocation: "GrandpaEquivocation",
    EquivocationProof: "GrandpaEquivocationProof"
  },
  identity: {
    Judgement: "IdentityJudgement"
  },
  inclusion: {
    ValidatorIndex: "ParaValidatorIndex"
  },
  paraDisputes: {
    ValidatorIndex: "ParaValidatorIndex"
  },
  paraInclusion: {
    ValidatorIndex: "ParaValidatorIndex"
  },
  paraScheduler: {
    ValidatorIndex: "ParaValidatorIndex"
  },
  paraShared: {
    ValidatorIndex: "ParaValidatorIndex"
  },
  parachains: {
    Id: "ParaId"
  },
  parasDisputes: {
    ValidatorIndex: "ParaValidatorIndex"
  },
  parasInclusion: {
    ValidatorIndex: "ParaValidatorIndex"
  },
  parasScheduler: {
    ValidatorIndex: "ParaValidatorIndex"
  },
  parasShared: {
    ValidatorIndex: "ParaValidatorIndex"
  },
  proposeParachain: {
    Proposal: "ParachainProposal"
  },
  proxy: {
    Announcement: "ProxyAnnouncement"
  },
  scheduler: {
    ValidatorIndex: "ParaValidatorIndex"
  },
  shared: {
    ValidatorIndex: "ParaValidatorIndex"
  },
  society: {
    Judgement: "SocietyJudgement",
    Vote: "SocietyVote"
  },
  staking: {
    Compact: "CompactAssignments"
  },
  treasury: {
    Proposal: "TreasuryProposal"
  },
  xcm: {
    AssetId: "XcmAssetId"
  },
  xcmPallet: {
    AssetId: "XcmAssetId"
  }
};
function F5({ knownTypes: n }, e) {
  var t;
  return {
    ...H5[e] ?? {},
    ...((t = n.typesAlias) == null ? void 0 : t[e]) ?? {}
  };
}
const j5 = [["<", ">"], ["<", ","], [",", ">"], ["(", ")"], ["(", ","], [",", ","], [",", ")"]];
function ur(n, e) {
  const t = e.toString(), r = n.findIndex(({ def: i }) => i.HistoricMetaCompat === t);
  return r !== -1 ? r : n.push({
    def: {
      HistoricMetaCompat: t
    }
  }) - 1;
}
function W5(n, ...e) {
  for (let t = 0, r = e.length; t < r; t++)
    ur(n, e[t]);
}
function q5(n, e) {
  return n.push({
    def: {
      Tuple: e
    }
  }) - 1;
}
function yd(n, e, t, r) {
  return t.push({
    def: {
      Variant: { variants: r }
    },
    path: [`pallet_${n.toString()}`, "pallet", e]
  }) - 1;
}
function z5(n, e, t) {
  n.register({
    OriginCaller: {
      _enum: e.map((r, i) => [
        r.name.toString(),
        t >= 12 ? r.index.toNumber() : i
      ]).sort((r, i) => r[1] - i[1]).reduce((r, [i, s]) => {
        for (let a = Object.keys(r).length; a < s; a++)
          r[`Empty${a}`] = "Null";
        return r[i] = vk[i] || "Null", r;
      }, {})
    }
  });
}
function Gs(n, e) {
  e.forEach((t) => {
    const r = Object.keys(n).find((i) => t.eq(i));
    if (r)
      t.setOverride(n[r]);
    else {
      const i = t.toString(), s = Object.entries(n).reduce((a, [o, c]) => j5.reduce((l, [u, f]) => l.replace(`${u}${o}${f}`, `${u}${c}${f}`), a), i);
      i !== s && t.setOverride(s);
    }
  });
}
function X5(n, e, t, r, i) {
  const s = r.map(({ args: a, docs: o, name: c }, l) => (Gs(i, a.map(({ type: u }) => u)), e.createTypeUnsafe("SiVariant", [{
    docs: o,
    fields: a.map(({ name: u, type: f }) => e.createTypeUnsafe("SiField", [{ name: u, type: ur(n, f) }])),
    index: l,
    name: c
  }])));
  return e.createTypeUnsafe("PalletCallMetadataV14", [{
    type: yd(t, "Call", n, s)
  }]);
}
function G5(n, e, t, r) {
  return t.map(({ docs: i, name: s, type: a, value: o }) => (Gs(r, [a]), e.createTypeUnsafe("PalletConstantMetadataV14", [{
    docs: i,
    name: s,
    type: ur(n, a),
    value: o
  }])));
}
function Z5(n, e, t, r, i) {
  const s = r.map(({ docs: a, name: o }, c) => e.createTypeUnsafe("SiVariant", [{
    docs: a,
    fields: [],
    index: c,
    name: o
  }]));
  return e.createTypeUnsafe("PalletErrorMetadataV14", [{
    type: yd(t, "Error", n, s)
  }]);
}
function J5(n, e, t, r, i) {
  const s = r.map(({ args: a, docs: o, name: c }, l) => (Gs(i, a), e.createTypeUnsafe("SiVariant", [{
    docs: o,
    fields: a.map((u) => e.createTypeUnsafe("SiField", [{ type: ur(n, u) }])),
    index: l,
    name: c
  }])));
  return e.createTypeUnsafe("PalletEventMetadataV14", [{
    type: yd(t, "Event", n, s)
  }]);
}
function Mc(n, e, t, { hashers: r, isLinked: i, isOptional: s, keys: a, value: o }) {
  return Gs(t, [o, ...Array.isArray(a) ? a : [a]]), e.createTypeUnsafe("StorageEntryTypeV14", [{
    Map: {
      hashers: r,
      key: r.length === 1 ? ur(n, a[0]) : q5(n, a.map((c) => ur(n, c))),
      value: i ? ur(n, `(${s ? `Option<${o.toString()}>` : o.toString()}, Linkage<${a[0].toString()}>)`) : ur(n, o)
    }
  }]);
}
function K5(n, e, { items: t, prefix: r }, i) {
  return e.createTypeUnsafe("PalletStorageMetadataV14", [{
    items: t.map(({ docs: s, fallback: a, modifier: o, name: c, type: l }) => {
      let u;
      if (l.isPlain) {
        const f = l.asPlain;
        Gs(i, [f]), u = e.createTypeUnsafe("StorageEntryTypeV14", [{
          Plain: ur(n, f)
        }]);
      } else if (l.isMap) {
        const f = l.asMap;
        u = Mc(n, e, i, {
          hashers: [f.hasher],
          isLinked: f.linked.isTrue,
          isOptional: o.isOptional,
          keys: [f.key],
          value: f.value
        });
      } else if (l.isDoubleMap) {
        const f = l.asDoubleMap;
        u = Mc(n, e, i, {
          hashers: [f.hasher, f.key2Hasher],
          isLinked: !1,
          isOptional: o.isOptional,
          keys: [f.key1, f.key2],
          value: f.value
        });
      } else {
        const f = l.asNMap;
        u = Mc(n, e, i, {
          hashers: f.hashers,
          isLinked: !1,
          isOptional: o.isOptional,
          keys: f.keyVec,
          value: f.value
        });
      }
      return e.createTypeUnsafe("StorageEntryMetadataV14", [{
        docs: s,
        fallback: a,
        modifier: o,
        name: c,
        type: u
      }]);
    }),
    prefix: r
  }]);
}
function Y5(n, { signedExtensions: e, version: t }) {
  return n.createTypeUnsafe("ExtrinsicMetadataV14", [{
    signedExtensions: e.map((r) => ({
      identifier: r,
      type: 0
      // we don't map the fields at all
    })),
    type: 0,
    version: t
  }]);
}
function Q5(n, e, t, { calls: r, constants: i, errors: s, events: a, storage: o }) {
  const c = F5(e, Ee(t.name));
  return e.createTypeUnsafe("PalletMetadataV14", [{
    calls: r && X5(n, e, t.name, r, c),
    constants: G5(n, e, i, c),
    errors: s && Z5(n, e, t.name, s),
    events: a && J5(n, e, t.name, a, c),
    index: t.index,
    name: t.name,
    storage: o && K5(n, e, o, c)
  }]);
}
function $5(n, e, t) {
  const r = [];
  W5(r, "Null", "u8", "u16", "u32", "u64"), z5(n, e.modules, t);
  const i = Y5(n, e.extrinsic), s = e.modules.map((a) => Q5(r, n, a, {
    calls: a.calls.unwrapOr(null),
    constants: a.constants,
    errors: a.errors.length ? a.errors : null,
    events: a.events.unwrapOr(null),
    storage: a.storage.unwrapOr(null)
  }));
  return n.createTypeUnsafe("MetadataV14", [{
    extrinsic: i,
    lookup: {
      types: r.map((a, o) => n.createTypeUnsafe("PortableType", [{ id: o, type: a }]))
    },
    pallets: s
  }]);
}
function eN(n, e, t) {
  var i;
  const r = e.lookup.paramTypes.SpRuntimeUncheckedExtrinsic;
  return n.createTypeUnsafe("MetadataV15", [
    J({}, e, {
      extrinsic: n.createTypeUnsafe("ExtrinsicMetadataV15", [
        J({}, e.extrinsic, {
          addressType: r == null ? void 0 : r[0].type.unwrapOr(0),
          callType: r == null ? void 0 : r[1].type.unwrapOr(0),
          extraType: r == null ? void 0 : r[3].type.unwrapOr(0),
          signatureType: r == null ? void 0 : r[2].type.unwrapOr(0)
        })
      ]),
      outerEnums: n.createTypeUnsafe("OuterEnums15", [{
        // FIXME We need to extract & add the errorType in here
        // (these doesn't seem to be an esay way to detect & extract it)
        callType: r == null ? void 0 : r[1].type.unwrapOr(0),
        eventType: (i = e.lookup.paramTypes.FrameSystemEventRecord) == null ? void 0 : i[0].type.unwrapOr(0)
      }])
    })
  ]);
}
function tN(n, e, t) {
  return e;
}
const Ap = 1635018093;
class nN extends Ts {
  constructor(e, t) {
    if (super(e, t), !this.isEmpty && !this.eq(Ap))
      throw new Error(`MagicNumber mismatch: expected ${e.createTypeUnsafe("u32", [Ap]).toHex()}, found ${this.toHex()}`);
  }
}
const rN = [15, 14, 13, 12, 11, 10, 9], iN = rN[0], sN = 14;
class Ro extends Dt {
  constructor(t, r) {
    super(t, {
      magicNumber: nN,
      metadata: "MetadataAll"
    }, r);
    b(this, "__internal__converted", /* @__PURE__ */ new Map());
    b(this, "__internal__assertVersion", (t) => {
      if (this.version > t)
        throw new Error(`Cannot convert metadata from version ${this.version} to ${t}`);
      return this.version === t;
    });
    b(this, "__internal__getVersion", (t, r) => {
      if (t !== "latest" && this.__internal__assertVersion(t)) {
        const i = `asV${t}`;
        return this.__internal__metadata()[i];
      }
      if (!this.__internal__converted.has(t)) {
        const i = t === "latest" ? `asV${iN}` : `asV${t - 1}`;
        this.__internal__converted.set(t, r(this.registry, this[i], this.version));
      }
      return this.__internal__converted.get(t);
    });
    /**
     * @description the metadata wrapped
     */
    b(this, "__internal__metadata", () => this.getT("metadata"));
  }
  /**
   * @description Returns the wrapped metadata as a limited calls-only (latest) version
   */
  get asCallsOnly() {
    return new Ro(this.registry, {
      magicNumber: this.magicNumber,
      metadata: this.registry.createTypeUnsafe("MetadataAll", [y8(this.registry, this.asLatest), sN])
    });
  }
  /**
   * @description Returns the wrapped metadata as a V9 object
   */
  get asV9() {
    return this.__internal__assertVersion(9), this.__internal__metadata().asV9;
  }
  /**
   * @description Returns the wrapped values as a V10 object
   */
  get asV10() {
    return this.__internal__getVersion(10, D5);
  }
  /**
   * @description Returns the wrapped values as a V11 object
   */
  get asV11() {
    return this.__internal__getVersion(11, U5);
  }
  /**
   * @description Returns the wrapped values as a V12 object
   */
  get asV12() {
    return this.__internal__getVersion(12, V5);
  }
  /**
   * @description Returns the wrapped values as a V13 object
   */
  get asV13() {
    return this.__internal__getVersion(13, B5);
  }
  /**
   * @description Returns the wrapped values as a V14 object
   */
  get asV14() {
    return this.__internal__getVersion(14, $5);
  }
  /**
   * @description Returns the wrapped values as a V14 object
   */
  get asV15() {
    return this.__internal__getVersion(15, eN);
  }
  /**
   * @description Returns the wrapped values as a latest version object
   */
  get asLatest() {
    return this.__internal__getVersion("latest", tN);
  }
  /**
   * @description The magicNumber for the Metadata (known constant)
   */
  get magicNumber() {
    return this.getT("magicNumber");
  }
  /**
   * @description the metadata version this structure represents
   */
  get version() {
    return this.__internal__metadata().index;
  }
  getUniqTypes(t) {
    return m8(this.registry, this.asLatest, t);
  }
  /**
   * @description Converts the Object to JSON, typically used for RPC transfers
   */
  toJSON() {
    return this.asLatest, super.toJSON();
  }
}
const I_ = new Uint8Array([109, 101, 116, 97, 9]), Pp = I_.length - 1;
function aN(n, e) {
  if (e.length === 0)
    return I_;
  if (e[Pp] === 9)
    try {
      return new Ro(n, e);
    } catch {
      e[Pp] = 10;
    }
  return e;
}
class eo extends Ro {
  constructor(e, t) {
    super(e, te(t) || Pe(t) ? aN(e, j(t)) : t);
  }
}
function O_(n, { pallets: e }, t) {
  const r = {};
  for (let i = 0, s = e.length; i < s; i++) {
    const { constants: a, name: o } = e[i];
    a.isEmpty || Ut(r, Ee(o), () => Lr({}, a, (c) => {
      const l = n.createTypeUnsafe(n.createLookupType(c.type), [Mt(c.value.toHex())]);
      return l.meta = c, l;
    }, gd));
  }
  return r;
}
function M_(n, e) {
  return J({ args: e.fields.map(({ type: t }) => n.getTypeDef(t).type) }, e);
}
function oN(n, { lookup: e, pallets: t }, r) {
  const i = {};
  for (let s = 0, a = t.length; s < a; s++) {
    const { errors: o, index: c, name: l } = t[s];
    if (o.isSome) {
      const u = r >= 12 ? c.toNumber() : s;
      Ut(i, Ee(l), () => zi(e, o.unwrap(), T_, (f) => ({
        // We sprinkle in isCodec & isU8a to ensure we are dealing with the correct objects
        is: (m) => Jn(m) && Jn(m.index) && m.index.eq(u) && (te(m.error) ? m.error[0] === f.index.toNumber() : Jn(m.error) && m.error.eq(f.index)),
        meta: n.createTypeUnsafe("ErrorMetadataLatest", [M_(e, f)])
      })));
    }
  }
  return i;
}
function L_({ events: n }) {
  return n.isSome;
}
function cN(n, { lookup: e, pallets: t }, r) {
  const i = {}, s = t.filter(L_);
  for (let a = 0, o = s.length; a < o; a++) {
    const { events: c, index: l, name: u } = s[a], f = r >= 12 ? l.toNumber() : a;
    Ut(i, Ee(u), () => zi(e, c.unwrap(), T_, (m) => ({
      // We sprinkle in isCodec & isU8a to ensure we are dealing with the correct objects
      is: (y) => Jn(y) && te(y.index) && f === y.index[0] && m.index.eq(y.index[1]),
      meta: n.createTypeUnsafe("EventMetadataLatest", [M_(e, m)])
    })));
  }
  return i;
}
const lN = (n) => Pi(n, 128), uN = {
  Blake2_128: (n) => (
    // eslint-disable-line camelcase
    hn(n, 128)
  ),
  Blake2_128Concat: (n) => (
    // eslint-disable-line camelcase
    Me(hn(n, 128), j(n))
  ),
  Blake2_256: (n) => (
    // eslint-disable-line camelcase
    hn(n, 256)
  ),
  Identity: (n) => j(n),
  Twox128: (n) => Pi(n, 128),
  Twox256: (n) => Pi(n, 256),
  Twox64Concat: (n) => Me(Pi(n, 64), j(n))
};
function dN(n) {
  return uN[n.type] || lN;
}
const Io = {
  args: [],
  hashers: [],
  keys: []
};
function fN(n) {
  return !Ne(n);
}
function D_({ method: n, section: e }, { args: t, keys: r }) {
  if (Array.isArray(t)) {
    if (t.filter(fN).length !== r.length)
      throw new Error(`Call to ${Ee(e || "unknown")}.${Ee(n || "unknown")} needs ${r.length} arguments, found [${t.join(", ")}]`);
  } else
    throw new Error(`Call to ${Ee(e || "unknown")}.${Ee(n || "unknown")} needs ${r.length} arguments`);
}
function U_(n, e, { args: t, hashers: r, keys: i }) {
  const s = i.length, a = new Array(s);
  for (let o = 0; o < s; o++)
    a[o] = dN(r[o])(n.createTypeUnsafe(n.createLookupType(i[o]), [t[o]]).toU8a());
  return [
    [
      Pi(e.prefix, 128),
      Pi(e.method, 128)
    ],
    a
  ];
}
function Lc(n, e, t) {
  D_(e, t);
  const { meta: r } = e, [i, s] = U_(n, e, t);
  let a = [];
  if (r.type.isMap) {
    const { hashers: c, key: l } = r.type.asMap;
    a = c.length === 1 ? [`${c[0].type}(${Rs(n.lookup, l)})`] : n.lookup.getSiType(l).def.asTuple.map((u, f) => `${c[f].type}(${Rs(n.lookup, u)})`);
  }
  const o = ["module", "method"].concat(...t.args.map((c, l) => a[l]));
  return {
    inner: i.concat(...s).map((c, l) => ({ name: o[l], outer: [c] }))
  };
}
function to(n, e, t) {
  const [r, i] = U_(n, e, t);
  return Me(...r, ...i);
}
function Dc(n, e, t) {
  return D_(e, t), wn(to(n, e, t));
}
function hN(n, e, t) {
  const { meta: { type: r } } = e;
  return (...i) => {
    if (r.isPlain)
      return t.skipHashing ? { inner: [], name: "wellKnown", outer: [j(t.key)] } : Lc(n, e, Io);
    const { hashers: s, key: a } = r.asMap;
    return s.length === 1 ? Lc(n, e, { args: i, hashers: s, keys: [a] }) : Lc(n, e, { args: i, hashers: s, keys: n.lookup.getSiType(a).def.asTuple });
  };
}
function pN(n, e, t) {
  const { meta: { type: r } } = e;
  let i = null;
  return (...s) => {
    if (r.isPlain)
      return i || (i = t.skipHashing ? wn(j(t.key)) : Dc(n, e, Io)), i;
    const { hashers: a, key: o } = r.asMap;
    return a.length === 1 ? Dc(n, e, { args: s, hashers: a, keys: [o] }) : Dc(n, e, { args: s, hashers: a, keys: n.lookup.getSiType(o).def.asTuple });
  };
}
function mN(n, e, t) {
  const { meta: r, method: i, prefix: s, section: a } = e, o = pN(n, e, t);
  return o.inspect = hN(n, e, t), o.meta = r, o.method = Ee(i), o.prefix = s, o.section = a, o.toJSON = () => J({ storage: { method: i, prefix: s, section: a } }, r.toJSON()), o;
}
function gN(n, { meta: { docs: e, name: t, type: r }, section: i }, { method: s }, a) {
  const o = n.createTypeUnsafe("StorageEntryMetadataLatest", [{
    docs: e,
    fallback: n.createTypeUnsafe("Bytes", []),
    modifier: n.createTypeUnsafe("StorageEntryModifierLatest", [1]),
    name: t,
    type: n.createTypeUnsafe("StorageEntryTypeLatest", [r.asMap.key, 0])
  }]);
  a.meta = o;
  const c = (...l) => n.createTypeUnsafe("StorageKey", [a(...l), { method: s, section: i }]);
  return c.meta = o, c;
}
function yN(n, e, t) {
  const { meta: { type: r }, method: i, section: s } = e;
  return t.iterKey = gN(n, e, t, (...a) => {
    if (a.length && (r.isPlain || a.length >= r.asMap.hashers.length))
      throw new Error(`Iteration of ${Ee(s || "unknown")}.${Ee(i || "unknown")} needs arguments to be at least one less than the full arguments, found [${a.join(", ")}]`);
    if (a.length && r.isMap) {
      const { hashers: o, key: c } = r.asMap, l = o.length === 1 ? [c] : n.lookup.getSiType(c).def.asTuple;
      return new bn(n, to(n, e, { args: a, hashers: o.slice(0, a.length), keys: l.slice(0, a.length) }));
    }
    return new bn(n, to(n, e, Io));
  }), t;
}
function V_(n, e, t) {
  const { meta: { type: r } } = e, i = mN(n, e, t);
  return r.isMap && yN(n, e, i), i.keyPrefix = (...s) => i.iterKey && i.iterKey(...s) || Ri(i())[1], i;
}
function kp(n, e) {
  const t = e.toLowerCase();
  return n.lookup.types.find((r) => r.type.def.isPrimitive && r.type.def.asPrimitive.toString().toLowerCase() === t || r.type.def.isHistoricMetaCompat && r.type.def.asHistoricMetaCompat.toString().toLowerCase() === t);
}
function _N(n, e) {
  let t = kp(n, e);
  if (!t && e === "Bytes") {
    const r = kp(n, "u8");
    r && (t = n.lookup.types.find((i) => i.type.def.isSequence && i.type.def.asSequence.type.eq(r.id) || i.type.def.isHistoricMetaCompat && i.type.def.asHistoricMetaCompat.eq(e)));
  }
  return t || `${e}`, t;
}
function B_({ method: n, prefix: e, section: t }, r, { docs: i, type: s }) {
  return (a) => {
    var o;
    return V_(a, {
      meta: a.createTypeUnsafe("StorageEntryMetadataLatest", [{
        docs: a.createTypeUnsafe("Vec<Text>", [[i]]),
        modifier: a.createTypeUnsafe("StorageEntryModifierLatest", ["Required"]),
        name: a.createTypeUnsafe("Text", [n]),
        toJSON: () => r,
        type: a.createTypeUnsafe("StorageEntryTypeLatest", [{ Plain: ((o = _N(a, s)) == null ? void 0 : o.id) || 0 }])
      }]),
      method: n,
      prefix: e,
      section: t
    }, { key: r, skipHashing: !0 });
  };
}
const vN = "Substrate", bN = "substrate";
function hi(n, e, t) {
  return B_({ method: n, prefix: vN, section: bN }, e, t);
}
const wN = {
  changesTrieConfig: hi("changesTrieConfig", ":changes_trie", {
    docs: "Changes trie configuration is stored under this key.",
    type: "u32"
  }),
  childStorageKeyPrefix: hi("childStorageKeyPrefix", ":child_storage:", {
    docs: "Prefix of child storage keys.",
    type: "u32"
  }),
  code: hi("code", ":code", {
    docs: "Wasm code of the runtime.",
    type: "Bytes"
  }),
  extrinsicIndex: hi("extrinsicIndex", ":extrinsic_index", {
    docs: "Current extrinsic index (u32) is stored under this key.",
    type: "u32"
  }),
  heapPages: hi("heapPages", ":heappages", {
    docs: "Number of wasm linear memory pages required for execution of the runtime.",
    type: "u64"
  }),
  intrablockEntropy: hi("intrablockEntropy", ":intrablock_entropy", {
    docs: "Current intra-block entropy (a universally unique `[u8; 32]` value) is stored here.",
    type: "[u8; 32]"
  })
};
function xN(n) {
  const e = {}, t = Object.entries(wN);
  for (let r = 0, i = t.length; r < i; r++)
    e[t[r][0]] = t[r][1](n);
  return { substrate: e };
}
const SN = "palletVersion", EN = ":__STORAGE_VERSION__:", CN = { docs: "Returns the current pallet version from storage", type: "u16" };
function AN(n, { pallets: e }, t) {
  const r = xN(n);
  for (let i = 0, s = e.length; i < s; i++) {
    const { name: a, storage: o } = e[i];
    if (o.isSome) {
      const c = Ee(a), { items: l, prefix: u } = o.unwrap(), f = u.toString();
      Ut(r, c, () => Lr({
        palletVersion: B_({ method: SN, prefix: f, section: c }, to(n, { method: EN, prefix: a.toString() }, Io), CN)(n)
      }, l, (m) => V_(n, { meta: m, method: m.name.toString(), prefix: f, section: c }, {}), gd));
    }
  }
  return r;
}
function PN(n, e) {
  if (!(e instanceof eo))
    throw new Error("You need to pass a valid Metadata instance to Decorated");
  const t = e.asLatest, r = e.version;
  return {
    consts: O_(n, t),
    errors: oN(n, t, r),
    events: cN(n, t, r),
    query: AN(n, t),
    registry: n,
    tx: O5(n, t, r)
  };
}
const kN = new Uint8Array(2), Tp = Qt("registry");
function Np(n, e) {
  return parseInt(n, 10) - parseInt(e, 10);
}
function H_(n) {
  return n.toString();
}
function F_(n, e) {
  const t = e.length, r = new Array(t);
  for (let i = 0; i < t; i++)
    r[i] = n.getTypeDef(e[i].type).type;
  return r;
}
function no(n) {
  const e = Object.keys(n);
  for (let t = 0, r = e.length; t < r; t++)
    delete n[e[t]];
}
function _d({ index: n }) {
  return n.toString();
}
function TN(n, { lookup: e, pallets: t }, r, i) {
  no(i);
  for (let s = 0, a = t.length; s < a; s++) {
    const { errors: o, index: c, name: l } = t[s];
    if (o.isSome) {
      const u = Ee(l);
      Ut(i, r >= 12 ? c.toNumber() : s, () => zi(e, o.unwrap(), _d, ({ docs: f, fields: m, index: y, name: _ }) => ({
        args: F_(e, m),
        docs: f.map(H_),
        fields: m,
        index: y.toNumber(),
        method: _.toString(),
        name: _.toString(),
        section: u
      })));
    }
  }
}
function NN(n, { lookup: e, pallets: t }, r, i) {
  const s = t.filter(L_);
  no(i);
  for (let a = 0, o = s.length; a < o; a++) {
    const { events: c, index: l, name: u } = s[a];
    Ut(i, r >= 12 ? l.toNumber() : a, () => zi(e, c.unwrap(), _d, (f) => {
      const m = n.createType("EventMetadataLatest", J({}, f, { args: F_(e, f.fields) }));
      return class extends f_ {
        constructor(y, _) {
          super(y, _, m, Ee(u), f.name.toString());
        }
      };
    }));
  }
}
function RN(n, { lookup: e, pallets: t }, r, i, s) {
  const a = t.filter(N_);
  no(i), no(s);
  for (let o = 0, c = a.length; o < c; o++) {
    const { calls: l, index: u, name: f } = a[o], m = r >= 12 ? u.toNumber() : o, y = Ee(f), _ = l.unwrap();
    Ut(i, m, () => zi(e, _, _d, (A) => R_(n, e, A, y, m)));
    const { path: v } = n.lookup.getSiType(_.type), C = v.findIndex((A) => A.eq("pallet"));
    if (C !== -1) {
      const A = Ee(v.slice(0, C).map((R, I) => I === 0 ? R.replace(/^(frame|pallet)_/, "") : R).join(" "));
      s[A] ? s[A].push(y) : s[A] = [y];
    }
  }
}
function IN(n, e) {
  const t = n.getChainProperties(), r = O_(n, e.asLatest, e.version), i = r.system && (r.system.sS58Prefix || r.system.ss58Prefix);
  if (!i)
    return t;
  const { isEthereum: s, tokenDecimals: a, tokenSymbol: o } = t || {};
  return n.createTypeUnsafe("ChainProperties", [{ isEthereum: s, ss58Format: i, tokenDecimals: a, tokenSymbol: o }]);
}
class vd {
  constructor(e) {
    b(this, "__internal__chainProperties");
    b(this, "__internal__classes", /* @__PURE__ */ new Map());
    b(this, "__internal__definitions", /* @__PURE__ */ new Map());
    b(this, "__internal__firstCallIndex", null);
    b(this, "__internal__hasher", hn);
    b(this, "__internal__knownTypes", {});
    b(this, "__internal__lookup");
    b(this, "__internal__metadata");
    b(this, "__internal__metadataVersion", 0);
    b(this, "__internal__signedExtensions", Nc);
    b(this, "__internal__unknownTypes", /* @__PURE__ */ new Map());
    b(this, "__internal__userExtensions");
    b(this, "__internal__knownDefaults");
    b(this, "__internal__knownDefaultsEntries");
    b(this, "__internal__knownDefinitions");
    b(this, "__internal__metadataCalls", {});
    b(this, "__internal__metadataErrors", {});
    b(this, "__internal__metadataEvents", {});
    b(this, "__internal__moduleMap", {});
    b(this, "createdAtHash");
    b(this, "__internal__registerObject", (e) => {
      const t = Object.entries(e);
      for (let r = 0, i = t.length; r < i; r++) {
        const [s, a] = t[r];
        if (ue(a))
          this.__internal__classes.set(s, a);
        else {
          const o = Pe(a) ? a : _e(a);
          if (s === o)
            throw new Error(`Unable to register circular ${s} === ${o}`);
          this.__internal__classes.has(s) && this.__internal__classes.delete(s), this.__internal__definitions.set(s, o);
        }
      }
    });
    // register alias types alongside the portable/lookup setup
    // (we don't combine this into setLookup since that would/could
    // affect stand-along lookups, such as ABIs which don't have
    // actual on-chain metadata)
    b(this, "__internal__registerLookup", (e) => {
      this.setLookup(e);
      let t = null;
      if (this.hasType("SpWeightsWeightV2Weight")) {
        const r = this.createType("SpWeightsWeightV2Weight");
        t = r.refTime && r.proofSize ? "SpWeightsWeightV2Weight" : "WeightV1";
      } else
        Yt(this.createType("Weight")) || (t = "WeightV1");
      t && this.register({ Weight: t });
    });
    this.__internal__knownDefaults = J({ Json: wg, Metadata: eo, PortableRegistry: $T, Raw: bn }, N5), this.__internal__knownDefaultsEntries = Object.entries(this.__internal__knownDefaults), this.__internal__knownDefinitions = Ga;
    const t = Object.values(this.__internal__knownDefinitions);
    for (let r = 0, i = t.length; r < i; r++)
      this.register(t[r].types);
    e && (this.createdAtHash = this.createType("BlockHash", e));
  }
  get chainDecimals() {
    var e;
    if ((e = this.__internal__chainProperties) != null && e.tokenDecimals.isSome) {
      const t = this.__internal__chainProperties.tokenDecimals.unwrap();
      if (t.length)
        return t.map((r) => r.toNumber());
    }
    return [12];
  }
  get chainIsEthereum() {
    var e;
    return ((e = this.__internal__chainProperties) == null ? void 0 : e.isEthereum.isTrue) || !1;
  }
  get chainSS58() {
    var e;
    return (e = this.__internal__chainProperties) != null && e.ss58Format.isSome ? this.__internal__chainProperties.ss58Format.unwrap().toNumber() : void 0;
  }
  get chainTokens() {
    var e;
    if ((e = this.__internal__chainProperties) != null && e.tokenSymbol.isSome) {
      const t = this.__internal__chainProperties.tokenSymbol.unwrap();
      if (t.length)
        return t.map(H_);
    }
    return [zr.getDefaults().unit];
  }
  get firstCallIndex() {
    return this.__internal__firstCallIndex || kN;
  }
  /**
   * @description Returns true if the type is in a Compat format
   */
  isLookupType(e) {
    return /Lookup\d+$/.test(e);
  }
  /**
   * @description Creates a lookup string from the supplied id
   */
  createLookupType(e) {
    return `Lookup${typeof e == "number" ? e : e.toNumber()}`;
  }
  get knownTypes() {
    return this.__internal__knownTypes;
  }
  get lookup() {
    return zn(this.__internal__lookup, "PortableRegistry has not been set on this registry");
  }
  get metadata() {
    return zn(this.__internal__metadata, "Metadata has not been set on this registry");
  }
  get unknownTypes() {
    return [...this.__internal__unknownTypes.keys()];
  }
  get signedExtensions() {
    return this.__internal__signedExtensions;
  }
  clearCache() {
    this.__internal__classes = /* @__PURE__ */ new Map();
  }
  /**
   * @describe Creates an instance of the class
   */
  createClass(e) {
    return ys(this, e);
  }
  /**
   * @describe Creates an instance of the class
   */
  createClassUnsafe(e) {
    return ys(this, e);
  }
  /**
   * @description Creates an instance of a type as registered
   */
  createType(e, ...t) {
    return Hl(this, e, t);
  }
  /**
   * @description Creates an instance of a type as registered
   */
  createTypeUnsafe(e, t, r) {
    return Hl(this, e, t, r);
  }
  // find a specific call
  findMetaCall(e) {
    const [t, r] = [e[0], e[1]];
    return zn(this.__internal__metadataCalls[`${t}`] && this.__internal__metadataCalls[`${t}`][`${r}`], () => `findMetaCall: Unable to find Call with index [${t}, ${r}]/[${e.toString()}]`);
  }
  // finds an error
  findMetaError(e) {
    const [t, r] = te(e) ? [e[0], e[1]] : [
      e.index.toNumber(),
      te(e.error) ? e.error[0] : e.error.toNumber()
    ];
    return zn(this.__internal__metadataErrors[`${t}`] && this.__internal__metadataErrors[`${t}`][`${r}`], () => `findMetaError: Unable to find Error with index [${t}, ${r}]/[${e.toString()}]`);
  }
  findMetaEvent(e) {
    const [t, r] = [e[0], e[1]];
    return zn(this.__internal__metadataEvents[`${t}`] && this.__internal__metadataEvents[`${t}`][`${r}`], () => `findMetaEvent: Unable to find Event with index [${t}, ${r}]/[${e.toString()}]`);
  }
  get(e, t, r) {
    return this.getUnsafe(e, t, r);
  }
  getUnsafe(e, t, r) {
    let i = this.__internal__classes.get(e) || this.__internal__knownDefaults[e];
    if (!i) {
      const s = this.__internal__definitions.get(e);
      let a;
      s ? a = ys(this, s) : r ? a = IT(this, r) : t && (Tp.warn(`Unable to resolve type ${e}, it will fail on construction`), this.__internal__unknownTypes.set(e, !0), a = Ao.with(e)), a && (i = class extends a {
      }, this.__internal__classes.set(e, i), r && xe(r.lookupIndex) && this.__internal__classes.set(this.createLookupType(r.lookupIndex), i));
    }
    return i;
  }
  getChainProperties() {
    return this.__internal__chainProperties;
  }
  getClassName(e) {
    const t = [];
    for (const [r, i] of this.__internal__knownDefaultsEntries)
      e === i && t.push(r);
    for (const [r, i] of this.__internal__classes.entries())
      e === i && t.push(r);
    return t.length ? t.sort().reverse()[0] : void 0;
  }
  getDefinition(e) {
    return this.__internal__definitions.get(e);
  }
  getModuleInstances(e, t) {
    var r, i, s, a, o;
    return ((o = (a = (s = (i = (r = this.__internal__knownTypes) == null ? void 0 : r.typesBundle) == null ? void 0 : i.spec) == null ? void 0 : s[e.toString()]) == null ? void 0 : a.instances) == null ? void 0 : o[t]) || this.__internal__moduleMap[t];
  }
  getOrThrow(e) {
    const t = this.get(e);
    if (!t)
      throw new Error(`type ${e} not found`);
    return t;
  }
  getOrUnknown(e) {
    return this.get(e, !0);
  }
  getSignedExtensionExtra() {
    return pp(this.__internal__signedExtensions, "payload", this.__internal__userExtensions);
  }
  getSignedExtensionTypes() {
    return pp(this.__internal__signedExtensions, "extrinsic", this.__internal__userExtensions);
  }
  hasClass(e) {
    return this.__internal__classes.has(e) || !!this.__internal__knownDefaults[e];
  }
  hasDef(e) {
    return this.__internal__definitions.has(e);
  }
  hasType(e) {
    return !this.__internal__unknownTypes.get(e) && (this.hasClass(e) || this.hasDef(e));
  }
  hash(e) {
    return this.createType("CodecHash", this.__internal__hasher(e));
  }
  // eslint-disable-next-line no-dupe-class-members
  register(e, t) {
    if (ue(e))
      this.__internal__classes.set(e.name, e);
    else if (Pe(e)) {
      if (ue(t)) {
        if (e === t.toString())
          throw new Error(`Unable to register circular ${e} === ${e}`);
      } else
        throw new Error(`Expected class definition passed to '${e}' registration`);
      this.__internal__classes.set(e, t);
    } else
      this.__internal__registerObject(e);
  }
  // sets the chain properties
  setChainProperties(e) {
    e && (this.__internal__chainProperties = e);
  }
  setHasher(e) {
    this.__internal__hasher = e || hn;
  }
  setKnownTypes(e) {
    this.__internal__knownTypes = e;
  }
  setLookup(e) {
    this.__internal__lookup = e, e.register();
  }
  // sets the metadata
  setMetadata(e, t, r, i) {
    this.__internal__metadata = e.asLatest, this.__internal__metadataVersion = e.version, this.__internal__firstCallIndex = null, this.__internal__registerLookup(this.__internal__metadata.lookup), RN(this, this.__internal__metadata, this.__internal__metadataVersion, this.__internal__metadataCalls, this.__internal__moduleMap), TN(this, this.__internal__metadata, this.__internal__metadataVersion, this.__internal__metadataErrors), NN(this, this.__internal__metadata, this.__internal__metadataVersion, this.__internal__metadataEvents);
    const [s] = Object.keys(this.__internal__metadataCalls).sort(Np);
    if (s) {
      const [a] = Object.keys(this.__internal__metadataCalls[s]).sort(Np);
      a && (this.__internal__firstCallIndex = new Uint8Array([parseInt(s, 10), parseInt(a, 10)]));
    }
    this.setSignedExtensions(t || (this.__internal__metadata.extrinsic.version.gt(At) ? this.__internal__metadata.extrinsic.signedExtensions.map(({ identifier: a }) => a.toString()) : Nc), r, i), this.setChainProperties(IN(this, e));
  }
  // sets the available signed extensions
  setSignedExtensions(e = Nc, t, r) {
    if (this.__internal__signedExtensions = e, this.__internal__userExtensions = t, !r) {
      const i = S8(this.__internal__signedExtensions, this.__internal__userExtensions);
      i.length && Tp.warn(`Unknown signed extensions ${i.join(", ")} found, treating them as no-effect`);
    }
  }
}
const ON = {}, is = {
  DispatchErrorModule: "DispatchErrorModuleU8",
  FullIdentification: "()",
  Keys: "SessionKeys7B",
  Weight: "WeightV1"
}, MN = [
  {
    minmax: [0, 200],
    types: {
      ...is,
      AccountInfo: "AccountInfoWithDualRefCount",
      Address: "AccountId",
      LookupSource: "AccountId"
    }
  },
  {
    minmax: [201, 214],
    types: {
      ...is,
      AccountInfo: "AccountInfoWithDualRefCount"
    }
  },
  {
    minmax: [215, 228],
    types: {
      ...is,
      Keys: "SessionKeys6"
    }
  },
  {
    minmax: [229, 9099],
    types: {
      ...is,
      ...Fi("V0")
    }
  },
  {
    minmax: [9100, 9105],
    types: {
      ...is,
      ...Fi("V1")
    }
  },
  {
    // metadata v14
    minmax: [9106, void 0],
    types: {
      Weight: "WeightV1"
    }
  }
  // ,
  // {
  //   // weight v2 introduction
  //   minmax: [9300, undefined],
  //   types: {
  //     Weight: 'WeightV2'
  //   }
  // }
], Rp = {
  DispatchErrorModule: "DispatchErrorModuleU8",
  TAssetBalance: "u128",
  ProxyType: {
    _enum: [
      "Any",
      "NonTransfer",
      "CancelProxy",
      "Assets",
      "AssetOwner",
      "AssetManager",
      "Staking"
    ]
  },
  Weight: "WeightV1"
}, LN = [
  {
    minmax: [0, 3],
    types: {
      // Enum was modified mid-flight -
      // https://github.com/paritytech/substrate/pull/10382/files#diff-e4e016b33a82268b6208dc974eea841bad47597865a749fee2f937eb6fdf67b4R498
      DispatchError: "DispatchErrorPre6First",
      ...Rp,
      ...Fi("V0")
    }
  },
  {
    minmax: [4, 5],
    types: {
      // As above, see https://github.com/polkadot-js/api/issues/5301
      DispatchError: "DispatchErrorPre6First",
      ...Rp,
      ...Fi("V1")
    }
  },
  {
    // metadata V14
    minmax: [500, 9999],
    types: {
      Weight: "WeightV1",
      TAssetConversion: "Option<AssetId>"
    }
  },
  {
    minmax: [1e4, void 0],
    types: {
      Weight: "WeightV1"
    }
  }
], Ip = {
  DispatchErrorModule: "DispatchErrorModuleU8",
  TAssetBalance: "u128",
  ProxyType: {
    _enum: [
      "Any",
      "NonTransfer",
      "CancelProxy",
      "Assets",
      "AssetOwner",
      "AssetManager",
      "Staking"
    ]
  },
  Weight: "WeightV1"
}, DN = [
  {
    minmax: [0, 3],
    types: {
      // Enum was modified mid-flight -
      // https://github.com/paritytech/substrate/pull/10382/files#diff-e4e016b33a82268b6208dc974eea841bad47597865a749fee2f937eb6fdf67b4R498
      DispatchError: "DispatchErrorPre6First",
      ...Ip,
      ...Fi("V0")
    }
  },
  {
    minmax: [4, 5],
    types: {
      // As above, see https://github.com/polkadot-js/api/issues/5301
      DispatchError: "DispatchErrorPre6First",
      ...Ip,
      ...Fi("V1")
    }
  },
  {
    // metadata V14
    minmax: [500, 9434],
    types: {
      Weight: "WeightV1",
      TAssetConversion: "Option<AssetId>"
    }
  },
  {
    minmax: [9435, void 0],
    types: {
      Weight: "WeightV1"
    }
  }
], UN = {
  "centrifuge-chain": Nr,
  kusama: Nr,
  node: Nr,
  "node-template": Nr,
  polkadot: Nr,
  rococo: MN,
  shell: Nr,
  statemine: LN,
  statemint: Nr,
  westend: Nr,
  westmint: DN
}, VN = {
  centrifuge: "polkadot",
  kusama: "polkadot",
  polkadot: "polkadot",
  sora: "polkadot",
  statemine: "polkadot",
  statemint: "polkadot",
  westmint: "polkadot"
}, BN = {
  acala: 787,
  ajuna: 354,
  "aleph-node": 643,
  astar: 810,
  bifrost: 788,
  "bifrost-kusama": 788,
  centrifuge: 747,
  composable: 354,
  darwinia: 354,
  "dock-mainnet": 594,
  edgeware: 523,
  enjin: 1155,
  equilibrium: 99999997,
  genshiro: 99999996,
  hydradx: 354,
  "interlay-parachain": 354,
  karura: 686,
  khala: 434,
  kusama: 434,
  matrixchain: 1155,
  nodle: 1003,
  origintrail: 354,
  parallel: 354,
  pendulum: 354,
  phala: 354,
  picasso: 434,
  polkadex: 799,
  polkadot: 354,
  polymesh: 595,
  quartz: 631,
  sora: 617,
  stafi: 907,
  statemine: 434,
  // common-good on Kusama, shares derivation
  statemint: 354,
  // common-good on Polkadot, shares derivation
  ternoa: 995,
  unique: 661,
  vtb: 694,
  xxnetwork: 1955,
  zeitgeist: 354
}, HN = {
  "": !0,
  // this is the default non-network entry
  "cess-testnet": !0,
  "dock-testnet": !0,
  jupiter: !0,
  "mathchain-testnet": !0,
  p3dt: !0,
  subspace_testnet: !0,
  "zero-alphaville": !0
}, Op = [0, 2, 42], FN = ["testnet"];
function jN(n) {
  var i, s;
  const e = n.network || "", t = e.replace(/_/g, "-").split("-"), r = n;
  return r.slip44 = BN[e], r.hasLedgerSupport = !!r.slip44, r.genesisHash = Ny[e] || [], r.icon = VN[e] || "substrate", r.isTestnet = !!HN[e] || FN.includes(t[t.length - 1]), r.isIgnored = r.isTestnet || !(n.standardAccount && ((i = n.decimals) != null && i.length) && ((s = n.symbols) != null && s.length)) && n.prefix !== 42, r;
}
function WN({ genesisHash: n, prefix: e }) {
  return !!n.length || e === 42;
}
function qN(n) {
  return !n.isIgnored && !!n.network;
}
function zN(n, e) {
  const t = Op.includes(n.prefix), r = Op.includes(e.prefix);
  return t === r ? t ? 0 : n.displayName.localeCompare(e.displayName) : t ? -1 : 1;
}
const XN = Ty.map(jN), GN = XN.filter(qN).sort(zN), ZN = GN.filter(WN), JN = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  kusama: Tc,
  polkadot: Tc,
  westend: Tc
}, Symbol.toStringTag, { value: "Module" })), KN = {
  westend: {
    genesisHash: ["0xe143f23803ac50e8f6f8e62695d1ce9e4e1d68aa36c1cd2cfd15340213f3423e"]
  }
};
function YN([n, e]) {
  const t = ZN.find((r) => r.network === n) || KN[n];
  if (!t)
    throw new Error(`Unable to find info for chain ${n}`);
  return {
    genesisHash: Mt(t.genesisHash[0]),
    network: n,
    versions: e.map(([r, i, s]) => ({
      apis: s,
      blockNumber: new Z(r),
      specVersion: new Z(i)
    }))
  };
}
const QN = Object.entries(JN).map(YN);
function Xi(n, e, t) {
  return t(n.toString(), e.toString());
}
function ca(n = [], e) {
  return n.filter(({ minmax: [t, r] }) => (t == null || e >= t) && (r == null || e <= r)).reduce((t, { types: r }) => ({ ...t, ...r }), {});
}
function $N({ knownTypes: n }, e, t) {
  return Xi(e, t, (r, i) => {
    var s, a, o, c, l, u;
    return {
      ...((o = (a = (s = n.typesBundle) == null ? void 0 : s.spec) == null ? void 0 : a[i]) == null ? void 0 : o.signedExtensions) ?? {},
      ...((u = (l = (c = n.typesBundle) == null ? void 0 : c.chain) == null ? void 0 : l[r]) == null ? void 0 : u.signedExtensions) ?? {}
    };
  });
}
function e6({ knownTypes: n }, e, t, r) {
  const i = Tt(r).toNumber();
  return Xi(e, t, (s, a) => {
    var o, c, l, u, f, m, y, _;
    return {
      // The order here is always, based on -
      //   - spec then chain
      //   - typesBundle takes higher precedence
      //   - types is the final catch-all override
      ...ca(UN[a], i),
      ...ca(ON[s], i),
      ...ca((l = (c = (o = n.typesBundle) == null ? void 0 : o.spec) == null ? void 0 : c[a]) == null ? void 0 : l.types, i),
      ...ca((m = (f = (u = n.typesBundle) == null ? void 0 : u.chain) == null ? void 0 : f[s]) == null ? void 0 : m.types, i),
      ...((y = n.typesSpec) == null ? void 0 : y[a]) ?? {},
      ...((_ = n.typesChain) == null ? void 0 : _[s]) ?? {},
      ...n.types ?? {}
    };
  });
}
function t6({ knownTypes: n }, e, t) {
  return Xi(e, t, (r, i) => {
    var s, a, o, c, l, u;
    return n.hasher || ((o = (a = (s = n.typesBundle) == null ? void 0 : s.chain) == null ? void 0 : a[r]) == null ? void 0 : o.hasher) || ((u = (l = (c = n.typesBundle) == null ? void 0 : c.spec) == null ? void 0 : l[i]) == null ? void 0 : u.hasher) || null;
  });
}
function Mp({ knownTypes: n }, e, t) {
  return Xi(e, t, (r, i) => {
    var s, a, o, c, l, u;
    return {
      ...((o = (a = (s = n.typesBundle) == null ? void 0 : s.spec) == null ? void 0 : a[i]) == null ? void 0 : o.rpc) ?? {},
      ...((u = (l = (c = n.typesBundle) == null ? void 0 : c.chain) == null ? void 0 : l[r]) == null ? void 0 : u.rpc) ?? {}
    };
  });
}
function n6({ knownTypes: n }, e, t) {
  return Xi(e, t, (r, i) => {
    var s, a, o, c, l, u;
    return {
      ...((o = (a = (s = n.typesBundle) == null ? void 0 : s.spec) == null ? void 0 : a[i]) == null ? void 0 : o.runtime) ?? {},
      ...((u = (l = (c = n.typesBundle) == null ? void 0 : c.chain) == null ? void 0 : l[r]) == null ? void 0 : u.runtime) ?? {}
    };
  });
}
function r6({ knownTypes: n }, e, t) {
  return Xi(e, t, (r, i) => {
    var s, a, o, c, l, u;
    return {
      // as per versions, first spec, then chain then finally non-versioned
      ...((o = (a = (s = n.typesBundle) == null ? void 0 : s.spec) == null ? void 0 : a[i]) == null ? void 0 : o.alias) ?? {},
      ...((u = (l = (c = n.typesBundle) == null ? void 0 : c.chain) == null ? void 0 : l[r]) == null ? void 0 : u.alias) ?? {},
      ...n.typesAlias ?? {}
    };
  });
}
function i6(n, e) {
  const t = QN.find((r) => n.eq(r.genesisHash));
  return t ? [
    t.versions.reduce((r, i) => e.gt(i.blockNumber) ? i : r, void 0),
    t.versions.find((r) => e.lte(r.blockNumber))
  ] : [void 0, void 0];
}
function j_(n = 1750) {
  return (e) => {
    let [t, r, i, s] = [0, 0, gr.EMPTY, gr.EMPTY];
    return new Nt((a) => (e.subscribe(a), r++ === 0 && (t === 1 ? s.unsubscribe() : i = e.connect(), t = 3), () => {
      --r === 0 && (t === 2 ? (t = 0, s.unsubscribe()) : (t = 1, s = pP.schedule(() => {
        t = 0, i.unsubscribe();
      }, n)));
    }));
  };
}
function s6(n, e) {
  return _e({ t: n }) === _e({ t: e });
}
function a6(n) {
  throw n;
}
function o6() {
}
function W_({ delay: n, skipChange: e = !1, skipTimeout: t = !1 } = {}) {
  return (r) => r.pipe(
    oi(a6),
    e ? Ps(o6) : ek(s6),
    // eslint-disable-next-line deprecation/deprecation
    X0(1),
    t ? ed() : j_(n)
  );
}
function ve(n, e) {
  const r = wi((...i) => new Nt((s) => {
    const a = e(...i).subscribe(s);
    return () => {
      r.unmemoize(...i), a.unsubscribe();
    };
  }).pipe(W_()), { getInstanceId: () => n });
  return r;
}
const c6 = Qt("rpc-core"), l6 = {
  fallback: void 0,
  modifier: { isOptional: !0 },
  type: {
    asMap: { linked: { isTrue: !1 } },
    isMap: !1
  }
};
function la(n, { noErrorLog: e, params: t, type: r }, i) {
  e || c6.error(`${n}(${t.map(({ isOptional: s, name: a, type: o }) => `${a}${s ? "?" : ""}: ${o}`).join(", ")}): ${r}:: ${i.message}`);
}
function Lp(n) {
  return ["0x3a636f6465"].includes(n.toHex());
}
class u6 {
  /**
   * @constructor
   * Default constructor for the core RPC handler
   * @param  {ProviderInterface} provider An API provider using any of the supported providers (HTTP, SC or WebSocket)
   */
  constructor(e, t, { isPedantic: r = !0, provider: i, userRpc: s = {} }) {
    b(this, "__internal__instanceId");
    b(this, "__internal__isPedantic");
    b(this, "__internal__registryDefault");
    b(this, "__internal__storageCache", /* @__PURE__ */ new Map());
    b(this, "__internal__storageCacheHits", 0);
    b(this, "__internal__storageCacheSize", 0);
    b(this, "__internal__getBlockRegistry");
    b(this, "__internal__getBlockHash");
    b(this, "mapping", /* @__PURE__ */ new Map());
    b(this, "provider");
    b(this, "sections", []);
    if (!i || !ue(i.send))
      throw new Error("Expected Provider to API create");
    this.__internal__instanceId = e, this.__internal__isPedantic = r, this.__internal__registryDefault = t, this.provider = i;
    const a = Object.keys(Oh);
    this.sections.push(...a), this.addUserInterfaces(s);
  }
  /**
   * @description Returns the connected status of a provider
   */
  get isConnected() {
    return this.provider.isConnected;
  }
  /**
   * @description Manually connect from the attached provider
   */
  connect() {
    return this.provider.connect();
  }
  /**
   * @description Manually disconnect from the attached provider
   */
  disconnect() {
    return this.provider.disconnect();
  }
  /**
   * @description Returns the underlying core stats, including those from teh provider
   */
  get stats() {
    const e = this.provider.stats;
    return e ? {
      ...e,
      core: {
        cacheHits: this.__internal__storageCacheHits,
        cacheSize: this.__internal__storageCacheSize
      }
    } : void 0;
  }
  /**
   * @description Sets a registry swap (typically from Api)
   */
  setRegistrySwap(e) {
    this.__internal__getBlockRegistry = wi(e, {
      getInstanceId: () => this.__internal__instanceId
    });
  }
  /**
   * @description Sets a function to resolve block hash from block number
   */
  setResolveBlockHash(e) {
    this.__internal__getBlockHash = wi(e, {
      getInstanceId: () => this.__internal__instanceId
    });
  }
  addUserInterfaces(e) {
    this.sections.push(...Object.keys(e).filter((t) => !this.sections.includes(t)));
    for (let t = 0, r = this.sections.length; t < r; t++) {
      const i = this.sections[t], s = J({}, Oh[i], e[i]), a = Object.keys(s);
      for (let o = 0, c = a.length; o < c; o++) {
        const l = a[o], u = s[l], f = u.endpoint || `${i}_${l}`;
        if (!this.mapping.has(f)) {
          const m = !!u.pubsub;
          this[i] || (this[i] = {}), this.mapping.set(f, J({}, u, { isSubscription: m, jsonrpc: f, method: l, section: i })), Ut(this[i], l, () => m ? this._createMethodSubscribe(i, l, u) : this._createMethodSend(i, l, u));
        }
      }
    }
  }
  _memomize(e, t) {
    const r = { getInstanceId: () => this.__internal__instanceId }, i = wi(e(!0), r);
    return i.raw = wi(e(!1), r), i.meta = t, i;
  }
  _formatResult(e, t, r, i, s, a, o) {
    return e ? this._formatOutput(t, r, i, s, a, o) : o;
  }
  _createMethodSend(e, t, r) {
    const i = r.endpoint || `${e}_${t}`, s = r.params.findIndex(({ isHistoric: l }) => l);
    let a = null;
    const o = async (l, u) => {
      var C;
      const f = s === -1 ? null : u[s], m = f && r.params[s].type === "BlockNumber" ? await ((C = this.__internal__getBlockHash) == null ? void 0 : C.call(this, f)) : f, { registry: y } = l && m && this.__internal__getBlockRegistry ? await this.__internal__getBlockRegistry(j(m)) : { registry: this.__internal__registryDefault }, _ = this._formatParams(y, null, r, u), v = await this.provider.send(i, _.map((A) => A.toJSON()), !!m);
      return this._formatResult(l, y, m, t, r, _, v);
    }, c = (l) => (...u) => {
      const f = l && s !== -1 && !!u[s];
      return new Nt((m) => (o(l, u).then((y) => {
        m.next(y), m.complete();
      }).catch((y) => {
        la(t, r, y), m.error(y), m.complete();
      }), () => {
        l ? a == null || a.unmemoize(...u) : a == null || a.raw.unmemoize(...u);
      })).pipe(
        // eslint-disable-next-line deprecation/deprecation
        X0(1),
        // create a Replay(1)
        f ? j_() : ed()
      );
    };
    return a = this._memomize(c, r), a;
  }
  // create a subscriptor, it subscribes once and resolves with the id as subscribe
  _createSubscriber({ paramsJson: e, subName: t, subType: r, update: i }, s) {
    return new Promise((a, o) => {
      this.provider.subscribe(r, t, e, i).then(a).catch((c) => {
        s(c), o(c);
      });
    });
  }
  _createMethodSubscribe(e, t, r) {
    const [i, s, a] = r.pubsub, o = `${e}_${s}`, c = `${e}_${a}`, l = `${e}_${i}`;
    let u = null;
    const f = (m) => (...y) => new Nt((_) => {
      let v = Promise.resolve(null);
      const C = this.__internal__registryDefault, A = (R) => {
        la(t, r, R), _.error(R);
      };
      try {
        const R = this._formatParams(C, null, r, y), I = (D, L) => {
          if (D) {
            la(t, r, D);
            return;
          }
          try {
            _.next(this._formatResult(m, C, null, t, r, R, L));
          } catch (V) {
            _.error(V);
          }
        };
        v = this._createSubscriber({ paramsJson: R.map((D) => D.toJSON()), subName: o, subType: l, update: I }, A);
      } catch (R) {
        A(R);
      }
      return () => {
        m ? u == null || u.unmemoize(...y) : u == null || u.raw.unmemoize(...y), v.then((R) => Mr(R) ? Promise.resolve(!1) : this.provider.unsubscribe(l, c, R)).catch((R) => la(t, r, R));
      };
    }).pipe(W_());
    return u = this._memomize(f, r), u;
  }
  _formatParams(e, t, r, i) {
    const s = i.length, a = r.params.filter(({ isOptional: c }) => !c).length;
    if (s < a || s > r.params.length)
      throw new Error(`Expected ${r.params.length} parameters${a === r.params.length ? "" : ` (${r.params.length - a} optional)`}, ${s} found instead`);
    const o = new Array(s);
    for (let c = 0; c < s; c++)
      o[c] = e.createTypeUnsafe(r.params[c].type, [i[c]], { blockHash: t });
    return o;
  }
  _formatOutput(e, t, r, i, s, a) {
    if (i.type === "StorageData") {
      const o = s[0];
      return this._formatStorageData(e, t, o, a);
    } else if (i.type === "StorageChangeSet") {
      const o = s[0];
      return o ? this._formatStorageSet(e, a.block, o, a.changes) : e.createType("StorageChangeSet", a);
    } else if (i.type === "Vec<StorageChangeSet>") {
      const o = a, c = o.length, l = new Array(c);
      for (let u = 0; u < c; u++) {
        const { block: f, changes: m } = o[u];
        l[u] = [
          e.createType("BlockHash", f),
          this._formatStorageSet(e, f, s[0], m)
        ];
      }
      return r === "queryStorageAt" ? l[0][1] : l;
    }
    return e.createTypeUnsafe(i.type, [a], { blockHash: t });
  }
  _formatStorageData(e, t, r, i) {
    const s = Mr(i), a = s ? null : Lp(r) ? i : j(i);
    return this._newType(e, t, r, a, s);
  }
  _formatStorageSet(e, t, r, i) {
    const s = r.length, a = s !== 1, o = new Array(s);
    for (let c = 0; c < s; c++)
      o[c] = this._formatStorageSetEntry(e, t, r[c], i, a, c);
    return o;
  }
  _formatStorageSetEntry(e, t, r, i, s, a) {
    const o = r.toHex(), c = i.find(([_]) => _ === o), l = Ne(c);
    if (l && s) {
      const _ = this.__internal__storageCache.get(o);
      if (_)
        return this.__internal__storageCacheHits++, _;
    }
    const u = l ? null : c[1], f = Mr(u), m = f || Lp(r) ? u : j(u), y = this._newType(e, t, r, m, f, a);
    return this.__internal__storageCache.set(o, y), this.__internal__storageCacheSize++, y;
  }
  _newType(e, t, r, i, s, a = -1) {
    const o = r.outputType || "Raw", c = r.meta || l6, l = a === -1 ? "" : ` entry ${a}:`;
    try {
      return e.createTypeUnsafe(o, [
        s ? c.fallback ? o.includes("Linkage<") ? Me(Mt(c.fallback.toHex()), new Uint8Array(2)) : Mt(c.fallback.toHex()) : void 0 : c.modifier.isOptional ? e.createTypeUnsafe(o, [i], { blockHash: t, isPedantic: this.__internal__isPedantic }) : i
      ], { blockHash: t, isFallback: s && !!c.fallback, isOptional: c.modifier.isOptional, isPedantic: this.__internal__isPedantic && !c.modifier.isOptional });
    } catch (u) {
      throw new Error(`Unable to decode storage ${r.section || "unknown"}.${r.method || "unknown"}:${l}: ${u.message}`);
    }
  }
}
function Xl(n) {
  return vu(n.number) ? n.number.unwrap() : n.number;
}
function d6(n) {
  return n.pipe(oe(([e]) => e));
}
function f6(n) {
  return (e, t) => ve(e, (...r) => d6(n(t, ...r)));
}
function q_(n, e, t, r) {
  Ut(n, e, () => Lr({}, t(e), (i) => r(e, i)));
}
function h6(n, e) {
  return ve(n, (t) => {
    const r = te(t) ? t : rn((t || "").toString());
    if (r.length > 8)
      return fe(e.registry.createType("AccountId", r));
    const i = e.registry.createType("AccountIndex", r);
    return e.derive.accounts.indexToId(i.toString()).pipe(oe((s) => zn(s, "Unable to retrieve accountId")));
  });
}
function p6(n, [e, t, r, i, s]) {
  const a = n == null ? void 0 : n.toString(), o = (c) => c.toString() === a;
  return {
    isCouncil: ((e == null ? void 0 : e.map((c) => Array.isArray(c) ? c[0] : c.who)) || t || []).some(o),
    isSociety: (i || []).some(o),
    isSudo: (s == null ? void 0 : s.toString()) === a,
    isTechCommittee: (r || []).some(o)
  };
}
function m6(n, e) {
  return ve(n, () => {
    var s, a, o, c, l;
    const t = [void 0, [], [], [], void 0], r = [
      (s = e.query.elections || e.query.phragmenElection || e.query.electionsPhragmen) == null ? void 0 : s.members,
      (a = e.query.council) == null ? void 0 : a.members,
      (o = e.query.technicalCommittee) == null ? void 0 : o.members,
      (c = e.query.society) == null ? void 0 : c.members,
      (l = e.query.sudo) == null ? void 0 : l.key
    ], i = r.filter((u) => u);
    return i.length ? e.queryMulti(i).pipe(oe((u) => {
      let f = -1;
      for (let m = 0, y = r.length; m < y; m++)
        ue(r[m]) && (t[m] = u[++f]);
      return t;
    })) : fe(t);
  });
}
function g6(n, e) {
  return ve(n, (t) => e.derive.accounts._flags().pipe(oe((r) => p6(t, r))));
}
function y6(n, e) {
  return ve(n, (t) => {
    try {
      const r = te(t) ? t : rn((t || "").toString());
      if (r.length > 8) {
        const s = e.registry.createType("AccountId", r);
        return e.derive.accounts.idToIndex(s).pipe(oe((a) => [s, a]));
      }
      const i = e.registry.createType("AccountIndex", r);
      return e.derive.accounts.indexToId(i.toString()).pipe(oe((s) => [s, i]));
    } catch {
      return fe([void 0, void 0]);
    }
  });
}
const _6 = { toHex: () => {
} };
function Pn(n) {
  return n.isRaw ? Nn(n.asRaw.toU8a(!0)) : n.isNone ? void 0 : n.toHex();
}
function v6(n) {
  return n.reduce((e, [t, r]) => {
    const i = Pn(t), s = Pn(r);
    return i && s && (e[i] = s), e;
  }, {});
}
function b6(n, e) {
  if (!(n != null && n.isSome))
    return { judgements: [] };
  const { info: t, judgements: r } = n.unwrap(), i = Pn(t.display);
  return {
    display: e && Pn(e[1]) || i,
    displayParent: e && i,
    email: Pn(t.email),
    image: Pn(t.image),
    judgements: r,
    legal: Pn(t.legal),
    other: v6(t.additional),
    parent: e == null ? void 0 : e[0],
    pgp: t.pgpFingerprint.unwrapOr(_6).toHex(),
    riot: Pn(t.riot),
    twitter: Pn(t.twitter),
    web: Pn(t.web)
  };
}
function w6(n, e, t) {
  if (e != null && e.isSome)
    return fe([e, void 0]);
  if (t != null && t.isSome) {
    const r = t.unwrap();
    return Oe([
      n.derive.accounts._identity(r[0]).pipe(oe(([i]) => i)),
      fe(r)
    ]);
  }
  return fe([void 0, void 0]);
}
function x6(n, e) {
  return ve(n, (t) => {
    var r;
    return t && ((r = e.query.identity) != null && r.identityOf) ? Oe([
      e.query.identity.identityOf(t),
      e.query.identity.superOf(t)
    ]) : fe([void 0, void 0]);
  });
}
function S6(n, e) {
  return ve(n, (t) => e.derive.accounts._identity(t).pipe(Ce(([r, i]) => w6(e, r, i)), oe(([r, i]) => b6(r, i))));
}
const E6 = /* @__PURE__ */ f6((n, e) => n.derive.accounts.hasIdentityMulti([e]));
function C6(n, e) {
  return ve(n, (t) => {
    var r;
    return (r = e.query.identity) != null && r.identityOf ? Oe([
      e.query.identity.identityOf.multi(t),
      e.query.identity.superOf.multi(t)
    ]).pipe(oe(([i, s]) => i.map((a, o) => {
      const c = s[o], l = c && c.isSome ? c.unwrap()[0].toString() : void 0;
      let u;
      if (a && a.isSome) {
        const f = Pn(a.unwrap().info.display);
        f && !ye(f) && (u = f);
      }
      return { display: u, hasIdentity: !!(u || l), parentId: l };
    }))) : fe(t.map(() => ({ hasIdentity: !1 })));
  });
}
function A6(n, e) {
  return ve(n, (t) => e.derive.accounts.indexes().pipe(oe((r) => r[t.toString()])));
}
let Uc = null;
function P6(n) {
  return n.query.indices.accounts.entries().pipe(oe((e) => e.reduce((t, [r, i]) => (i.isSome && (t[i.unwrap()[0].toString()] = n.registry.createType("AccountIndex", r.args[0])), t), {})));
}
function k6(n, e) {
  return ve(n, () => Uc ? fe(Uc) : (e.query.indices ? P6(e).pipe(sk({})) : fe({})).pipe(oe((t) => (Uc = t, t))));
}
function T6(n, e) {
  return ve(n, (t) => e.query.indices ? e.query.indices.accounts(t).pipe(oe((r) => r.unwrapOr([])[0])) : fe(void 0));
}
function N6(n, e) {
  var t;
  return (e && ((t = n.query.nicks) != null && t.nameOf) ? n.query.nicks.nameOf(e) : fe(void 0)).pipe(oe((r) => r != null && r.isSome ? Nn(r.unwrap()[0]).substring(0, n.consts.nicks.maxLength.toNumber()) : void 0));
}
function R6(n, e) {
  return ve(n, (t) => e.derive.accounts.idAndIndex(t).pipe(Ce(([r, i]) => Oe([
    fe({ accountId: r, accountIndex: i }),
    e.derive.accounts.identity(r),
    N6(e, r)
  ])), oe(([{ accountId: r, accountIndex: i }, s, a]) => ({
    accountId: r,
    accountIndex: i,
    identity: s,
    nickname: a
  }))));
}
const I6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  _flags: m6,
  _identity: x6,
  accountId: h6,
  flags: g6,
  hasIdentity: E6,
  hasIdentityMulti: C6,
  idAndIndex: y6,
  idToIndex: A6,
  identity: S6,
  indexToId: T6,
  indexes: k6,
  info: R6
}, Symbol.toStringTag, { value: "Module" })), O6 = {}, Xt = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: O6
}, Symbol.toStringTag, { value: "Module" })), M6 = "0x76657374696e6720";
function L6(n, e, t) {
  let r = n.registry.createType("Balance"), i = [], s = n.registry.createType("Balance"), a = !1;
  if (Array.isArray(t)) {
    i = t.filter(({ until: c }) => !c || e && c.gt(e)), a = i.some(({ amount: c }) => c && c.isMax()), s = n.registry.createType("Balance", i.filter(({ id: c }) => c.eq(M6)).reduce((c, { amount: l }) => c.iadd(l), new Z(0)));
    const o = i.filter(({ amount: c }) => c && !c.isMax());
    o.length && (r = n.registry.createType("Balance", pu(...o.map(({ amount: c }) => c))));
  }
  return { allLocked: a, lockedBalance: r, lockedBreakdown: i, vestingLocked: s };
}
function Dp(n, e, t, r) {
  const { allLocked: i, lockedBalance: s, lockedBreakdown: a, vestingLocked: o } = L6(n, e, r);
  return J({}, t, {
    availableBalance: n.registry.createType("Balance", i ? 0 : pu(new Z(0), t != null && t.freeBalance ? t.freeBalance.sub(s) : new Z(0))),
    lockedBalance: s,
    lockedBreakdown: a,
    vestingLocked: o
  });
}
function D6(n, e, t) {
  const r = t || [], i = !e.vestingLocked.isZero(), s = r.map(({ locked: c, perBlock: l, startingBlock: u }) => n.gt(u) ? Jm(c, l.mul(n.sub(u))) : At), a = s.reduce((c, l) => c.iadd(l), new Z(0)), o = r.reduce((c, { locked: l }) => c.iadd(l), new Z(0));
  return {
    isVesting: i,
    vestedBalance: a,
    vestedClaimable: i ? e.vestingLocked.sub(o.sub(a)) : At,
    vesting: r.map(({ locked: c, perBlock: l, startingBlock: u }, f) => ({
      endBlock: c.div(l).iadd(u),
      locked: c,
      perBlock: l,
      startingBlock: u,
      vested: s[f]
    })).filter(({ locked: c }) => !c.isZero()),
    vestingTotal: o
  };
}
function U6(n, e) {
  const [t, [r, i, s], a] = e, o = Dp(n, a, t, i[0]);
  return J(o, D6(a, o, r), {
    accountId: t.accountId,
    accountNonce: t.accountNonce,
    additional: i.slice(1).map((c, l) => Dp(n, a, t.additional[l], c)),
    namedReserves: s
  });
}
function V6(n, e) {
  return Oe([
    n.query.balances.locks(e),
    n.query.balances.vesting(e)
  ]).pipe(oe(([t, r]) => {
    let i = null;
    if (r.isSome) {
      const { offset: s, perBlock: a, startingBlock: o } = r.unwrap();
      i = n.registry.createType("VestingInfo", { locked: s, perBlock: a, startingBlock: o });
    }
    return [
      i ? [i] : null,
      [t],
      []
    ];
  }));
}
const B6 = (n) => !!n;
function Up(n) {
  return [
    n.map((e) => !e),
    n.filter(B6)
  ];
}
function H6(n, e, t = ["balances"]) {
  var o;
  const [r, i] = Up(t.map((c) => {
    var l, u;
    return ((l = n.derive[c]) == null ? void 0 : l.customLocks) || ((u = n.query[c]) == null ? void 0 : u.locks);
  })), [s, a] = Up(t.map((c) => {
    var l;
    return (l = n.query[c]) == null ? void 0 : l.reserves;
  }));
  return Oe([
    (o = n.query.vesting) != null && o.vesting ? n.query.vesting.vesting(e) : fe(n.registry.createType("Option<VestingInfo>")),
    i.length ? Oe(i.map((c) => c(e))) : fe([]),
    a.length ? Oe(a.map((c) => c(e))) : fe([])
  ]).pipe(oe(([c, l, u]) => {
    let f = -1, m = -1;
    const y = c.unwrapOr(null);
    return [
      y ? Array.isArray(y) ? y : [y] : null,
      r.map((_) => _ ? n.registry.createType("Vec<BalanceLock>") : l[++f]),
      s.map((_) => _ ? n.registry.createType("Vec<PalletBalancesReserveData>") : u[++m])
    ];
  }));
}
function z_(n, e) {
  const t = e.registry.getModuleInstances(e.runtimeVersion.specName, "balances");
  return ve(n, (r) => {
    var i, s;
    return Oe([
      e.derive.balances.account(r),
      ue((i = e.query.system) == null ? void 0 : i.account) || ue((s = e.query.balances) == null ? void 0 : s.account) ? H6(e, r, t) : V6(e, r)
    ]).pipe(Ce(([a, o]) => Oe([
      fe(a),
      fe(o),
      e.derive.chain.bestNumber()
    ])), oe((a) => U6(e, a)));
  });
}
function nn(n) {
  return n.registry.createType("Balance");
}
function Vp(n, [e, t, r, i]) {
  const s = n.registry.createType("Balance", e.toBn());
  return {
    freeBalance: e,
    frozenFee: r,
    frozenMisc: i,
    reservedBalance: t,
    votingBalance: s
  };
}
function F6(n, [e, [t, [r, ...i]]]) {
  return J({
    accountId: e,
    accountNonce: t,
    additional: i.map((s) => Vp(n, s))
  }, Vp(n, r));
}
function j6(n, e) {
  return Oe([
    n.query.balances.freeBalance(e),
    n.query.balances.reservedBalance(e),
    n.query.system.accountNonce(e)
  ]).pipe(oe(([t, r, i]) => [
    i,
    [[t, r, nn(n), nn(n)]]
  ]));
}
function X_(n, e) {
  const t = (r) => [
    r,
    [[nn(n), nn(n), nn(n), nn(n)]]
  ];
  return ue(n.query.system.account) ? n.query.system.account(e).pipe(oe(({ nonce: r }) => t(r))) : ue(n.query.system.accountNonce) ? n.query.system.accountNonce(e).pipe(oe((r) => t(r))) : fe(t(n.registry.createType("Index")));
}
function Bp(n, e, t = ["balances"]) {
  const r = t.map((s) => {
    var a, o;
    return ((a = n.derive[s]) == null ? void 0 : a.customAccount) || ((o = n.query[s]) == null ? void 0 : o.account);
  }).filter((s) => ue(s)), i = (s, a) => [
    s,
    a.map(({ feeFrozen: o, free: c, miscFrozen: l, reserved: u }) => [c, u, o, l])
  ];
  return r.length ? ue(n.query.system.account) ? Oe([
    n.query.system.account(e),
    ...r.map((s) => s(e))
  ]).pipe(oe(([{ nonce: s }, ...a]) => i(s, a))) : Oe([
    n.query.system.accountNonce(e),
    ...r.map((s) => s(e))
  ]).pipe(oe(([s, ...a]) => i(s, a))) : X_(n, e);
}
function W6(n, e) {
  return n.query.system.account(e).pipe(oe((t) => {
    const r = t.nonce ? t.data : t[1], i = t.nonce || t[0];
    if (!r || r.isEmpty)
      return [
        i,
        [[nn(n), nn(n), nn(n), nn(n)]]
      ];
    const { feeFrozen: s, free: a, miscFrozen: o, reserved: c } = r;
    return [
      i,
      [[a, c, s, o]]
    ];
  }));
}
function q6(n, e) {
  const t = e.registry.getModuleInstances(e.runtimeVersion.specName, "balances"), r = t && t[0] !== "balances";
  return ve(n, (i) => e.derive.accounts.accountId(i).pipe(Ce((s) => {
    var a, o, c;
    return s ? Oe([
      fe(s),
      r ? Bp(e, s, t) : ue((a = e.query.system) == null ? void 0 : a.account) ? W6(e, s) : ue((o = e.query.balances) == null ? void 0 : o.account) ? Bp(e, s) : ue((c = e.query.balances) == null ? void 0 : c.freeBalance) ? j6(e, s) : X_(e, s)
    ]) : fe([e.registry.createType("AccountId"), [
      e.registry.createType("Index"),
      [[nn(e), nn(e), nn(e), nn(e)]]
    ]]);
  }), oe((s) => F6(e, s))));
}
function z6(n, e) {
  return ve(n, (t) => t != null && t.length ? Oe(t.map((r) => e.derive.balances.account(r))) : fe([]));
}
const X6 = z_, G6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  account: q6,
  all: z_,
  votingBalance: X6,
  votingBalances: z6
}, Symbol.toStringTag, { value: "Module" }));
function G_(n) {
  return (e, t) => ve(e, () => n(t).pipe(oe(Xl)));
}
function Z6(n, e) {
  var s, a, o, c;
  const t = (s = e.session) != null && s.validators ? e.session.validators() : fe(null), { logs: [r] } = n.digest, i = r && (r.isConsensus && r.asConsensus[0].isNimbus && r.asConsensus[1] || r.isPreRuntime && r.asPreRuntime[0].isNimbus && r.asPreRuntime[1]);
  if (i) {
    if ((a = e.authorMapping) != null && a.mappingWithDeposit)
      return Oe([
        fe(n),
        t,
        e.authorMapping.mappingWithDeposit(i).pipe(oe((l) => l.unwrapOr({ account: null }).account))
      ]);
    if ((o = e.parachainStaking) != null && o.selectedCandidates && ((c = e.session) != null && c.nextKeys)) {
      const l = i.toHex();
      return Oe([
        fe(n),
        t,
        e.parachainStaking.selectedCandidates().pipe(So((u) => Oe([
          fe(u),
          e.session.nextKeys.multi(u).pipe(oe((f) => f.findIndex((m) => m.unwrapOrDefault().nimbus.toHex() === l)))
        ])), oe(([u, f]) => f === -1 ? null : u[f]))
      ]);
    }
  }
  return Oe([
    fe(n),
    t,
    fe(null)
  ]);
}
function bd(n, e, t) {
  return n.queryAt(e.parentHash.isEmpty ? t || e.hash : e.parentHash).pipe(Ce((r) => Z6(e, r)));
}
const J6 = /* @__PURE__ */ G_((n) => n.rpc.chain.subscribeNewHeads()), K6 = /* @__PURE__ */ G_((n) => n.rpc.chain.subscribeFinalizedHeads());
function Y6(n, e) {
  return ve(n, () => Oe([
    e.derive.chain.bestNumber(),
    e.derive.chain.bestNumberFinalized()
  ]).pipe(oe(([t, r]) => e.registry.createType("BlockNumber", t.sub(r)))));
}
function Z_(n, e) {
  const [t] = n.logs.filter((a) => a.isConsensus), [r] = n.logs.filter((a) => a.isPreRuntime), [i] = n.logs.filter((a) => a.isSeal);
  let s;
  try {
    if (r) {
      const [a, o] = r.asPreRuntime;
      s = a.extractAuthor(o, e);
    }
    if (!s && t) {
      const [a, o] = t.asConsensus;
      s = a.extractAuthor(o, e);
    }
    if (!s && i) {
      const [a, o] = i.asSeal;
      s = a.extractAuthor(o, e);
    }
  } catch {
  }
  return s;
}
function J_(n, e, t, r) {
  const i = n.createClass("Header");
  class s extends i {
    constructor(c, l, u, f) {
      super(c, l);
      b(this, "__internal__author");
      this.__internal__author = f || Z_(this.digest, u || []), this.createdAtHash = l == null ? void 0 : l.createdAtHash;
    }
    /**
     * @description Convenience method, returns the author for the block
     */
    get author() {
      return this.__internal__author;
    }
  }
  return new s(n, e, t, r);
}
function Q6(n, e) {
  return n.map((t, r) => {
    let i, s;
    const a = e.filter(({ phase: o }) => o.isApplyExtrinsic && o.asApplyExtrinsic.eq(r)).map(({ event: o }) => (o.section === "system" && (o.method === "ExtrinsicSuccess" ? s = o.data[0] : o.method === "ExtrinsicFailed" && (i = o.data[0], s = o.data[1])), o));
    return { dispatchError: i, dispatchInfo: s, events: a, extrinsic: t };
  });
}
function $6(n, e, t, r, i) {
  const s = n.createClass("SignedBlock");
  class a extends s {
    constructor(l, u, f, m, y) {
      super(l, u);
      b(this, "__internal__author");
      b(this, "__internal__events");
      b(this, "__internal__extrinsics");
      this.__internal__author = y || Z_(this.block.header.digest, m || []), this.__internal__events = f || [], this.__internal__extrinsics = Q6(this.block.extrinsics, this.__internal__events), this.createdAtHash = u == null ? void 0 : u.createdAtHash;
    }
    /**
     * @description Convenience method, returns the author for the block
     */
    get author() {
      return this.__internal__author;
    }
    /**
     * @description Convenience method, returns the events associated with the block
     */
    get events() {
      return this.__internal__events;
    }
    /**
     * @description Returns the extrinsics and their events, mapped
     */
    get extrinsics() {
      return this.__internal__extrinsics;
    }
  }
  return new a(n, e, t, r, i);
}
function e4(n, e) {
  return ve(n, (t) => Oe([
    e.rpc.chain.getBlock(t),
    e.queryAt(t)
  ]).pipe(Ce(([r, i]) => Oe([
    fe(r),
    i.system.events(),
    bd(e, r.block.header, t)
  ])), oe(([r, i, [, s, a]]) => $6(i.registry, r, i, s, a))));
}
function t4(n, e) {
  return ve(n, (t) => e.rpc.chain.getBlockHash(t).pipe(Ce((r) => e.derive.chain.getBlock(r))));
}
function n4(n, e) {
  return ve(n, (t) => e.rpc.chain.getHeader(t).pipe(Ce((r) => bd(e, r, t)), oe(([r, i, s]) => J_((i || r).registry, r, i, s))));
}
function r4(n, e) {
  return ve(n, () => e.derive.chain.subscribeFinalizedHeads().pipe(Ce((t) => e.derive.chain.getBlock(t.createdAtHash || t.hash))));
}
function i4(n, e) {
  return ve(n, (t, r, i = []) => e.rpc.chain.getHeader(t).pipe(Ce((s) => s.parentHash.eq(r) ? fe([s, ...i]) : e.derive.chain._getHeaderRange(s.parentHash, r, [s, ...i]))));
}
function s4(n, e) {
  return ve(n, () => {
    let t = null;
    return e.rpc.chain.subscribeFinalizedHeads().pipe(Ce((r) => {
      const i = t, s = r.parentHash;
      return t = r.createdAtHash = r.hash, i === null || s.eq(i) ? fe(r) : e.derive.chain._getHeaderRange(s, i, [r]).pipe(Ce((a) => Xn(a)));
    }));
  });
}
function a4(n, e) {
  return ve(n, () => e.derive.chain.subscribeNewHeads().pipe(Ce((t) => e.derive.chain.getBlock(t.createdAtHash || t.hash))));
}
function o4(n, e) {
  return ve(n, () => e.rpc.chain.subscribeNewHeads().pipe(Ce((t) => bd(e, t)), oe(([t, r, i]) => (t.createdAtHash = t.hash, J_(t.registry, t, r, i)))));
}
const c4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  _getHeaderRange: i4,
  bestNumber: J6,
  bestNumberFinalized: K6,
  bestNumberLag: Y6,
  getBlock: e4,
  getBlockByNumber: t4,
  getHeader: n4,
  subscribeFinalizedBlocks: r4,
  subscribeFinalizedHeads: s4,
  subscribeNewBlocks: a4,
  subscribeNewHeads: o4
}, Symbol.toStringTag, { value: "Module" }));
function l4(n) {
  return fe([
    // deprecated
    n.consts.contracts.callBaseFee || n.registry.createType("Balance"),
    n.consts.contracts.contractFee || n.registry.createType("Balance"),
    n.consts.contracts.creationFee || n.registry.createType("Balance"),
    n.consts.contracts.transactionBaseFee || n.registry.createType("Balance"),
    n.consts.contracts.transactionByteFee || n.registry.createType("Balance"),
    n.consts.contracts.transferFee || n.registry.createType("Balance"),
    // current
    n.consts.contracts.rentByteFee || n.registry.createType("Balance"),
    n.consts.contracts.rentDepositOffset || n.registry.createType("Balance"),
    n.consts.contracts.surchargeReward || n.registry.createType("Balance"),
    n.consts.contracts.tombstoneDeposit || n.registry.createType("Balance")
  ]);
}
function u4(n, e) {
  return ve(n, () => l4(e).pipe(oe(([t, r, i, s, a, o, c, l, u, f]) => ({
    callBaseFee: t,
    contractFee: r,
    creationFee: i,
    rentByteFee: c,
    rentDepositOffset: l,
    surchargeReward: u,
    tombstoneDeposit: f,
    transactionBaseFee: s,
    transactionByteFee: a,
    transferFee: o
  }))));
}
const d4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  fees: u4
}, Symbol.toStringTag, { value: "Module" }));
function f4(n, e) {
  return ve(n, (t) => Oe([
    e.rpc.chain.getBlock(t),
    e.queryAt(t).pipe(Ce((r) => r.system.events()))
  ]).pipe(oe(([r, i]) => ({ block: r, events: i }))));
}
const h4 = 250, p4 = new Z(6 * 1e3), K_ = new Z(5), m4 = new Z(5 * 60 * 1e3);
function Y_(n, e) {
  return n.derive.balances.account(e).pipe(oe(({ accountNonce: t }) => t));
}
function g4(n, e) {
  var t;
  return (t = n.rpc.system) != null && t.accountNextIndex ? n.rpc.system.accountNextIndex(e) : Y_(n, e);
}
function y4(n) {
  return Oe([
    n.rpc.chain.getHeader().pipe(Ce((e) => (
      // check for chains at genesis (until block 1 is produced, e.g. 6s), since
      // we do need to allow transactions at chain start (also dev/seal chains)
      e.parentHash.isEmpty ? fe(e) : n.rpc.chain.getHeader(e.parentHash).pipe(oi(() => fe(e)))
    ))),
    n.rpc.chain.getFinalizedHead().pipe(Ce((e) => n.rpc.chain.getHeader(e).pipe(oi(() => fe(null)))))
  ]).pipe(oe(([e, t]) => (
    // determine the hash to use, current when lag > max, else finalized
    !t || Xl(e).sub(Xl(t)).gt(K_) ? e : t
  )));
}
function _4(n, e) {
  return (t, r, i) => Oe([
    // retrieve nonce if none was specified
    Ne(r) ? Y_(e, t) : r === -1 ? g4(e, t) : fe(e.registry.createType("Index", r)),
    // if no era (create) or era > 0 (mortal), do block retrieval
    Ne(i) || xe(i) && i > 0 ? y4(e) : fe(null)
  ]).pipe(oe(([s, a]) => {
    var o, c, l, u;
    return {
      header: a,
      mortalLength: Math.min(((c = (o = e.consts.system) == null ? void 0 : o.blockHashCount) == null ? void 0 : c.toNumber()) || h4, m4.div(((l = e.consts.babe) == null ? void 0 : l.expectedBlockTime) || ((u = e.consts.timestamp) == null ? void 0 : u.minimumPeriod.muln(2)) || p4).iadd(K_).toNumber()),
      nonce: s
    };
  }));
}
const v4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  events: f4,
  signingInfo: _4
}, Symbol.toStringTag, { value: "Module" })), b4 = { accounts: I6, alliance: Xt, bagsList: Xt, balances: G6, bounties: Xt, chain: c4, contracts: d4, council: Xt, crowdloan: Xt, democracy: Xt, elections: Xt, imOnline: Xt, membership: Xt, parachains: Xt, session: Xt, society: Xt, staking: Xt, technicalCommittee: Xt, treasury: Xt, tx: v4 }, Qr = {
  allianceMotion: {
    instances: ["allianceMotion"],
    methods: []
  },
  bagsList: {
    instances: ["voterBagsList", "voterList", "bagsList"],
    methods: [],
    withDetect: !0
  },
  contracts: {
    instances: ["contracts"],
    methods: []
  },
  council: {
    instances: ["council"],
    methods: [],
    withDetect: !0
  },
  crowdloan: {
    instances: ["crowdloan"],
    methods: []
  },
  democracy: {
    instances: ["democracy"],
    methods: []
  },
  elections: {
    instances: ["phragmenElection", "electionsPhragmen", "elections", "council"],
    methods: [],
    withDetect: !0
  },
  imOnline: {
    instances: ["imOnline"],
    methods: []
  },
  membership: {
    instances: ["membership"],
    methods: []
  },
  parachains: {
    instances: ["parachains", "registrar"],
    methods: []
  },
  session: {
    instances: ["session"],
    methods: []
  },
  society: {
    instances: ["society"],
    methods: []
  },
  staking: {
    instances: ["staking"],
    methods: ["erasRewardPoints"]
  },
  technicalCommittee: {
    instances: ["technicalCommittee"],
    methods: [],
    withDetect: !0
  },
  treasury: {
    instances: ["treasury"],
    methods: []
  }
};
function w4(n, e, t) {
  return n.registry.getModuleInstances(e, t) || [];
}
function Hp(n, e, t) {
  const r = {}, i = Object.keys(t), s = Object.keys(e.query), a = e.runtimeVersion.specName, o = (y) => s.includes(y), c = (y) => w4(e, a, y).some(o), l = (y) => (_) => y.some((v) => s.includes(v) && e.query[v][_]), u = (y) => Object.keys(t[y]), f = (y, _) => t[y][_](n, e), m = (y) => !Qr[y] || Qr[y].instances.some(o) && (!Qr[y].methods.length || Qr[y].methods.every(l(Qr[y].instances))) || Qr[y].withDetect && Qr[y].instances.some(c);
  for (let y = 0, _ = i.length; y < _; y++) {
    const v = i[y];
    m(v) && q_(r, v, u, f);
  }
  return r;
}
function x4(n, e, t = {}) {
  return {
    ...Hp(n, e, b4),
    ...Hp(n, e, t)
  };
}
function S4(n) {
  return n("return this");
}
const Gl = typeof globalThis < "u" ? globalThis : typeof global < "u" ? global : typeof self < "u" ? self : typeof window < "u" ? window : S4(Function), Fp = -99999;
function ss(n, e, t) {
  Object.defineProperty(n, e, {
    configurable: !0,
    enumerable: !1,
    value: t
  });
}
class Q_ extends Error {
  constructor(t = "", r = Fp, i) {
    super();
    b(this, "code");
    b(this, "data");
    b(this, "message");
    b(this, "name");
    b(this, "stack");
    if (ss(this, "message", String(t)), ss(this, "name", this.constructor.name), ss(this, "data", i), ss(this, "code", r), ue(Error.captureStackTrace))
      Error.captureStackTrace(this, this.constructor);
    else {
      const { stack: s } = new Error(t);
      s && ss(this, "stack", s);
    }
  }
}
b(Q_, "CODES", {
  ASSERT: -90009,
  INVALID_JSONRPC: -99998,
  METHOD_NOT_FOUND: -32601,
  UNKNOWN: Fp
});
function E4(n) {
  if (Ne(n))
    return "";
  const e = `: ${Pe(n) ? n.replace(/Error\("/g, "").replace(/\("/g, "(").replace(/"\)/g, ")").replace(/\(/g, ", ").replace(/\)/g, "") : _e(n)}`;
  return e.length <= 256 ? e : `${e.substring(0, 255)}`;
}
function jp(n) {
  if (n) {
    const { code: e, data: t, message: r } = n;
    throw new Q_(`${e}: ${r}${E4(t)}`, e, t);
  }
}
class C4 {
  constructor() {
    b(this, "__internal__id", 0);
  }
  decodeResponse(e) {
    if (!e || e.jsonrpc !== "2.0")
      throw new Error("Invalid jsonrpc field in decoded object");
    const t = !Ne(e.params) && !Ne(e.method);
    if (!xe(e.id) && (!t || !xe(e.params.subscription) && !Pe(e.params.subscription)))
      throw new Error("Invalid id field in decoded object");
    if (jp(e.error), e.result === void 0 && !t)
      throw new Error("No result found in jsonrpc response");
    return t ? (jp(e.params.error), e.params.result) : e.result;
  }
  encodeJson(e, t) {
    const [r, i] = this.encodeObject(e, t);
    return [r, _e(i)];
  }
  encodeObject(e, t) {
    const r = ++this.__internal__id;
    return [r, {
      id: r,
      jsonrpc: "2.0",
      method: e,
      params: t
    }];
  }
}
const A4 = "http://127.0.0.1:9933", P4 = "ws://127.0.0.1:9944", k4 = {
  HTTP_URL: A4,
  WS_URL: P4
}, T4 = 128;
class Wp {
  constructor(e) {
    b(this, "key");
    b(this, "next");
    b(this, "prev");
    this.key = e, this.next = this.prev = this;
  }
}
class N4 {
  constructor(e = T4) {
    b(this, "capacity");
    b(this, "__internal__data", /* @__PURE__ */ new Map());
    b(this, "__internal__refs", /* @__PURE__ */ new Map());
    b(this, "__internal__length", 0);
    b(this, "__internal__head");
    b(this, "__internal__tail");
    this.capacity = e, this.__internal__head = this.__internal__tail = new Wp("<empty>");
  }
  get length() {
    return this.__internal__length;
  }
  get lengthData() {
    return this.__internal__data.size;
  }
  get lengthRefs() {
    return this.__internal__refs.size;
  }
  entries() {
    const e = this.keys(), t = e.length, r = new Array(t);
    for (let i = 0; i < t; i++) {
      const s = e[i];
      r[i] = [s, this.__internal__data.get(s)];
    }
    return r;
  }
  keys() {
    const e = [];
    if (this.__internal__length) {
      let t = this.__internal__head;
      for (; t !== this.__internal__tail; )
        e.push(t.key), t = t.next;
      e.push(t.key);
    }
    return e;
  }
  get(e) {
    const t = this.__internal__data.get(e);
    return t ? (this.__internal__toHead(e), t) : null;
  }
  set(e, t) {
    if (this.__internal__data.has(e))
      this.__internal__toHead(e);
    else {
      const r = new Wp(e);
      this.__internal__refs.set(r.key, r), this.length === 0 ? this.__internal__head = this.__internal__tail = r : (this.__internal__head.prev = r, r.next = this.__internal__head, this.__internal__head = r), this.__internal__length === this.capacity ? (this.__internal__data.delete(this.__internal__tail.key), this.__internal__refs.delete(this.__internal__tail.key), this.__internal__tail = this.__internal__tail.prev, this.__internal__tail.next = this.__internal__head) : this.__internal__length += 1;
    }
    this.__internal__data.set(e, t);
  }
  __internal__toHead(e) {
    const t = this.__internal__refs.get(e);
    t && t !== this.__internal__head && (t.prev.next = t.next, t.next.prev = t.prev, t.next = this.__internal__head, this.__internal__head.prev = t, this.__internal__head = t);
  }
}
var $_ = { exports: {} };
(function(n) {
  var e = Object.prototype.hasOwnProperty, t = "~";
  function r() {
  }
  Object.create && (r.prototype = /* @__PURE__ */ Object.create(null), new r().__proto__ || (t = !1));
  function i(c, l, u) {
    this.fn = c, this.context = l, this.once = u || !1;
  }
  function s(c, l, u, f, m) {
    if (typeof u != "function")
      throw new TypeError("The listener must be a function");
    var y = new i(u, f || c, m), _ = t ? t + l : l;
    return c._events[_] ? c._events[_].fn ? c._events[_] = [c._events[_], y] : c._events[_].push(y) : (c._events[_] = y, c._eventsCount++), c;
  }
  function a(c, l) {
    --c._eventsCount === 0 ? c._events = new r() : delete c._events[l];
  }
  function o() {
    this._events = new r(), this._eventsCount = 0;
  }
  o.prototype.eventNames = function() {
    var l = [], u, f;
    if (this._eventsCount === 0)
      return l;
    for (f in u = this._events)
      e.call(u, f) && l.push(t ? f.slice(1) : f);
    return Object.getOwnPropertySymbols ? l.concat(Object.getOwnPropertySymbols(u)) : l;
  }, o.prototype.listeners = function(l) {
    var u = t ? t + l : l, f = this._events[u];
    if (!f)
      return [];
    if (f.fn)
      return [f.fn];
    for (var m = 0, y = f.length, _ = new Array(y); m < y; m++)
      _[m] = f[m].fn;
    return _;
  }, o.prototype.listenerCount = function(l) {
    var u = t ? t + l : l, f = this._events[u];
    return f ? f.fn ? 1 : f.length : 0;
  }, o.prototype.emit = function(l, u, f, m, y, _) {
    var v = t ? t + l : l;
    if (!this._events[v])
      return !1;
    var C = this._events[v], A = arguments.length, R, I;
    if (C.fn) {
      switch (C.once && this.removeListener(l, C.fn, void 0, !0), A) {
        case 1:
          return C.fn.call(C.context), !0;
        case 2:
          return C.fn.call(C.context, u), !0;
        case 3:
          return C.fn.call(C.context, u, f), !0;
        case 4:
          return C.fn.call(C.context, u, f, m), !0;
        case 5:
          return C.fn.call(C.context, u, f, m, y), !0;
        case 6:
          return C.fn.call(C.context, u, f, m, y, _), !0;
      }
      for (I = 1, R = new Array(A - 1); I < A; I++)
        R[I - 1] = arguments[I];
      C.fn.apply(C.context, R);
    } else {
      var D = C.length, L;
      for (I = 0; I < D; I++)
        switch (C[I].once && this.removeListener(l, C[I].fn, void 0, !0), A) {
          case 1:
            C[I].fn.call(C[I].context);
            break;
          case 2:
            C[I].fn.call(C[I].context, u);
            break;
          case 3:
            C[I].fn.call(C[I].context, u, f);
            break;
          case 4:
            C[I].fn.call(C[I].context, u, f, m);
            break;
          default:
            if (!R)
              for (L = 1, R = new Array(A - 1); L < A; L++)
                R[L - 1] = arguments[L];
            C[I].fn.apply(C[I].context, R);
        }
    }
    return !0;
  }, o.prototype.on = function(l, u, f) {
    return s(this, l, u, f, !1);
  }, o.prototype.once = function(l, u, f) {
    return s(this, l, u, f, !0);
  }, o.prototype.removeListener = function(l, u, f, m) {
    var y = t ? t + l : l;
    if (!this._events[y])
      return this;
    if (!u)
      return a(this, y), this;
    var _ = this._events[y];
    if (_.fn)
      _.fn === u && (!m || _.once) && (!f || _.context === f) && a(this, y);
    else {
      for (var v = 0, C = [], A = _.length; v < A; v++)
        (_[v].fn !== u || m && !_[v].once || f && _[v].context !== f) && C.push(_[v]);
      C.length ? this._events[y] = C.length === 1 ? C[0] : C : a(this, y);
    }
    return this;
  }, o.prototype.removeAllListeners = function(l) {
    var u;
    return l ? (u = t ? t + l : l, this._events[u] && a(this, u)) : (this._events = new r(), this._eventsCount = 0), this;
  }, o.prototype.off = o.prototype.removeListener, o.prototype.addListener = o.prototype.on, o.prefixed = t, o.EventEmitter = o, n.exports = o;
})($_);
var R4 = $_.exports;
const ev = /* @__PURE__ */ nu(R4), Vc = Gl.WebSocket, I4 = {
  1e3: "Normal Closure",
  1001: "Going Away",
  1002: "Protocol Error",
  1003: "Unsupported Data",
  1004: "(For future)",
  1005: "No Status Received",
  1006: "Abnormal Closure",
  1007: "Invalid frame payload data",
  1008: "Policy Violation",
  1009: "Message too big",
  1010: "Missing Extension",
  1011: "Internal Error",
  1012: "Service Restart",
  1013: "Try Again Later",
  1014: "Bad Gateway",
  1015: "TLS Handshake"
};
function O4(n) {
  if (n >= 0 && n <= 999)
    return "(Unused)";
  if (n >= 1016) {
    if (n <= 1999)
      return "(For WebSocket standard)";
    if (n <= 2999)
      return "(For WebSocket extensions)";
    if (n <= 3999)
      return "(For libraries and frameworks)";
    if (n <= 4999)
      return "(For applications)";
  }
  return I4[n] || "(Unknown)";
}
const M4 = {
  chain_finalisedHead: "chain_finalizedHead",
  chain_subscribeFinalisedHeads: "chain_subscribeFinalizedHeads",
  chain_unsubscribeFinalisedHeads: "chain_unsubscribeFinalizedHeads"
}, L4 = 2500, D4 = 60 * 1e3, U4 = 5e3, on = Qt("api-ws");
function qp(n, e) {
  Object.keys(n).forEach((t) => {
    e && e(n[t]), delete n[t];
  });
}
function Bc() {
  return { bytesRecv: 0, bytesSent: 0, cached: 0, errors: 0, requests: 0, subscriptions: 0, timeout: 0 };
}
class Zs {
  /**
   * @param {string | string[]}  endpoint    The endpoint url. Usually `ws://ip:9944` or `wss://ip:9944`, may provide an array of endpoint strings.
   * @param {number | false} autoConnectMs Whether to connect automatically or not (default). Provided value is used as a delay between retries.
   * @param {Record<string, string>} headers The headers provided to the underlying WebSocket
   * @param {number} [timeout] Custom timeout value used per request . Defaults to `DEFAULT_TIMEOUT_MS`
   */
  constructor(e = k4.WS_URL, t = L4, r = {}, i) {
    b(this, "__internal__callCache", new N4());
    b(this, "__internal__coder");
    b(this, "__internal__endpoints");
    b(this, "__internal__headers");
    b(this, "__internal__eventemitter");
    b(this, "__internal__handlers", {});
    b(this, "__internal__isReadyPromise");
    b(this, "__internal__stats");
    b(this, "__internal__waitingForId", {});
    b(this, "__internal__autoConnectMs");
    b(this, "__internal__endpointIndex");
    b(this, "__internal__endpointStats");
    b(this, "__internal__isConnected", !1);
    b(this, "__internal__subscriptions", {});
    b(this, "__internal__timeoutId", null);
    b(this, "__internal__websocket");
    b(this, "__internal__timeout");
    b(this, "__internal__emit", (e, ...t) => {
      this.__internal__eventemitter.emit(e, ...t);
    });
    b(this, "__internal__onSocketClose", (e) => {
      const t = new Error(`disconnected from ${this.endpoint}: ${e.code}:: ${e.reason || O4(e.code)}`);
      this.__internal__autoConnectMs > 0 && on.error(t.message), this.__internal__isConnected = !1, this.__internal__websocket && (this.__internal__websocket.onclose = null, this.__internal__websocket.onerror = null, this.__internal__websocket.onmessage = null, this.__internal__websocket.onopen = null, this.__internal__websocket = null), this.__internal__timeoutId && (clearInterval(this.__internal__timeoutId), this.__internal__timeoutId = null), qp(this.__internal__handlers, (r) => {
        try {
          r.callback(t, void 0);
        } catch (i) {
          on.error(i);
        }
      }), qp(this.__internal__waitingForId), this.__internal__endpointStats = Bc(), this.__internal__emit("disconnected"), this.__internal__autoConnectMs > 0 && setTimeout(() => {
        this.connectWithRetry().catch(Kn);
      }, this.__internal__autoConnectMs);
    });
    b(this, "__internal__onSocketError", (e) => {
      on.debug(() => ["socket error", e]), this.__internal__emit("error", e);
    });
    b(this, "__internal__onSocketMessage", (e) => {
      on.debug(() => ["received", e.data]);
      const t = e.data.length;
      this.__internal__endpointStats.bytesRecv += t, this.__internal__stats.total.bytesRecv += t;
      const r = JSON.parse(e.data);
      return Ne(r.method) ? this.__internal__onSocketMessageResult(r) : this.__internal__onSocketMessageSubscribe(r);
    });
    b(this, "__internal__onSocketMessageResult", (e) => {
      const t = this.__internal__handlers[e.id];
      if (!t) {
        on.debug(() => `Unable to find handler for id=${e.id}`);
        return;
      }
      try {
        const { method: r, params: i, subscription: s } = t, a = this.__internal__coder.decodeResponse(e);
        if (t.callback(null, a), s) {
          const o = `${s.type}::${a}`;
          this.__internal__subscriptions[o] = J({}, s, {
            method: r,
            params: i
          }), this.__internal__waitingForId[o] && this.__internal__onSocketMessageSubscribe(this.__internal__waitingForId[o]);
        }
      } catch (r) {
        this.__internal__endpointStats.errors++, this.__internal__stats.total.errors++, t.callback(r, void 0);
      }
      delete this.__internal__handlers[e.id];
    });
    b(this, "__internal__onSocketMessageSubscribe", (e) => {
      if (!e.method)
        throw new Error("No method found in JSONRPC response");
      const r = `${M4[e.method] || e.method}::${e.params.subscription}`, i = this.__internal__subscriptions[r];
      if (!i) {
        this.__internal__waitingForId[r] = e, on.debug(() => `Unable to find handler for subscription=${r}`);
        return;
      }
      delete this.__internal__waitingForId[r];
      try {
        const s = this.__internal__coder.decodeResponse(e);
        i.callback(null, s);
      } catch (s) {
        this.__internal__endpointStats.errors++, this.__internal__stats.total.errors++, i.callback(s, void 0);
      }
    });
    b(this, "__internal__onSocketOpen", () => {
      if (this.__internal__websocket === null)
        throw new Error("WebSocket cannot be null in onOpen");
      return on.debug(() => ["connected to", this.endpoint]), this.__internal__isConnected = !0, this.__internal__resubscribe(), this.__internal__emit("connected"), !0;
    });
    b(this, "__internal__resubscribe", () => {
      const e = this.__internal__subscriptions;
      this.__internal__subscriptions = {}, Promise.all(Object.keys(e).map(async (t) => {
        const { callback: r, method: i, params: s, type: a } = e[t];
        if (!a.startsWith("author_"))
          try {
            await this.subscribe(a, i, s, r);
          } catch (o) {
            on.error(o);
          }
      })).catch(on.error);
    });
    b(this, "__internal__timeoutHandlers", () => {
      const e = Date.now(), t = Object.keys(this.__internal__handlers);
      for (let r = 0, i = t.length; r < i; r++) {
        const s = this.__internal__handlers[t[r]];
        if (e - s.start > this.__internal__timeout) {
          try {
            s.callback(new Error(`No response received from RPC endpoint in ${this.__internal__timeout / 1e3}s`), void 0);
          } catch {
          }
          this.__internal__endpointStats.timeout++, this.__internal__stats.total.timeout++, delete this.__internal__handlers[t[r]];
        }
      }
    });
    const s = Array.isArray(e) ? e : [e];
    if (s.length === 0)
      throw new Error("WsProvider requires at least one Endpoint");
    s.forEach((a) => {
      if (!/^(wss|ws):\/\//.test(a))
        throw new Error(`Endpoint should start with 'ws://', received '${a}'`);
    }), this.__internal__eventemitter = new ev(), this.__internal__autoConnectMs = t || 0, this.__internal__coder = new C4(), this.__internal__endpointIndex = -1, this.__internal__endpoints = s, this.__internal__headers = r, this.__internal__websocket = null, this.__internal__stats = {
      active: { requests: 0, subscriptions: 0 },
      total: Bc()
    }, this.__internal__endpointStats = Bc(), this.__internal__timeout = i || D4, t && t > 0 && this.connectWithRetry().catch(Kn), this.__internal__isReadyPromise = new Promise((a) => {
      this.__internal__eventemitter.once("connected", () => {
        a(this);
      });
    });
  }
  /**
   * @summary `true` when this provider supports subscriptions
   */
  get hasSubscriptions() {
    return !0;
  }
  /**
   * @summary `true` when this provider supports clone()
   */
  get isClonable() {
    return !0;
  }
  /**
   * @summary Whether the node is connected or not.
   * @return {boolean} true if connected
   */
  get isConnected() {
    return this.__internal__isConnected;
  }
  /**
   * @description Promise that resolves the first time we are connected and loaded
   */
  get isReady() {
    return this.__internal__isReadyPromise;
  }
  get endpoint() {
    return this.__internal__endpoints[this.__internal__endpointIndex];
  }
  /**
   * @description Returns a clone of the object
   */
  clone() {
    return new Zs(this.__internal__endpoints);
  }
  selectEndpointIndex(e) {
    return (this.__internal__endpointIndex + 1) % e.length;
  }
  /**
   * @summary Manually connect
   * @description The [[WsProvider]] connects automatically by default, however if you decided otherwise, you may
   * connect manually using this method.
   */
  // eslint-disable-next-line @typescript-eslint/require-await
  async connect() {
    if (this.__internal__websocket)
      throw new Error("WebSocket is already connected");
    try {
      this.__internal__endpointIndex = this.selectEndpointIndex(this.__internal__endpoints), this.__internal__websocket = typeof Gl.WebSocket < "u" && ug(Gl.WebSocket, Vc) ? new Vc(this.endpoint) : new Vc(this.endpoint, void 0, {
        headers: this.__internal__headers
      }), this.__internal__websocket && (this.__internal__websocket.onclose = this.__internal__onSocketClose, this.__internal__websocket.onerror = this.__internal__onSocketError, this.__internal__websocket.onmessage = this.__internal__onSocketMessage, this.__internal__websocket.onopen = this.__internal__onSocketOpen), this.__internal__timeoutId = setInterval(() => this.__internal__timeoutHandlers(), U4);
    } catch (e) {
      throw on.error(e), this.__internal__emit("error", e), e;
    }
  }
  /**
   * @description Connect, never throwing an error, but rather forcing a retry
   */
  async connectWithRetry() {
    if (this.__internal__autoConnectMs > 0)
      try {
        await this.connect();
      } catch {
        setTimeout(() => {
          this.connectWithRetry().catch(Kn);
        }, this.__internal__autoConnectMs);
      }
  }
  /**
   * @description Manually disconnect from the connection, clearing auto-connect logic
   */
  // eslint-disable-next-line @typescript-eslint/require-await
  async disconnect() {
    this.__internal__autoConnectMs = 0;
    try {
      this.__internal__websocket && this.__internal__websocket.close(1e3);
    } catch (e) {
      throw on.error(e), this.__internal__emit("error", e), e;
    }
  }
  /**
   * @description Returns the connection stats
   */
  get stats() {
    return {
      active: {
        requests: Object.keys(this.__internal__handlers).length,
        subscriptions: Object.keys(this.__internal__subscriptions).length
      },
      total: this.__internal__stats.total
    };
  }
  get endpointStats() {
    return this.__internal__endpointStats;
  }
  /**
   * @summary Listens on events after having subscribed using the [[subscribe]] function.
   * @param  {ProviderInterfaceEmitted} type Event
   * @param  {ProviderInterfaceEmitCb}  sub  Callback
   * @return unsubscribe function
   */
  on(e, t) {
    return this.__internal__eventemitter.on(e, t), () => {
      this.__internal__eventemitter.removeListener(e, t);
    };
  }
  /**
   * @summary Send JSON data using WebSockets to configured HTTP Endpoint or queue.
   * @param method The RPC methods to execute
   * @param params Encoded parameters as applicable for the method
   * @param subscription Subscription details (internally used)
   */
  send(e, t, r, i) {
    this.__internal__endpointStats.requests++, this.__internal__stats.total.requests++;
    const [s, a] = this.__internal__coder.encodeJson(e, t);
    let o = r ? this.__internal__callCache.get(a) : null;
    return o ? (this.__internal__endpointStats.cached++, this.__internal__stats.total.cached++) : (o = this.__internal__send(s, a, e, t, i), r && this.__internal__callCache.set(a, o)), o;
  }
  async __internal__send(e, t, r, i, s) {
    return new Promise((a, o) => {
      try {
        if (!this.isConnected || this.__internal__websocket === null)
          throw new Error("WebSocket is not connected");
        const c = (u, f) => {
          u ? o(u) : a(f);
        };
        on.debug(() => ["calling", r, t]), this.__internal__handlers[e] = {
          callback: c,
          method: r,
          params: i,
          start: Date.now(),
          subscription: s
        };
        const l = t.length;
        this.__internal__endpointStats.bytesSent += l, this.__internal__stats.total.bytesSent += l, this.__internal__websocket.send(t);
      } catch (c) {
        this.__internal__endpointStats.errors++, this.__internal__stats.total.errors++, o(c);
      }
    });
  }
  /**
   * @name subscribe
   * @summary Allows subscribing to a specific event.
   *
   * @example
   * <BR>
   *
   * ```javascript
   * const provider = new WsProvider('ws://127.0.0.1:9944');
   * const rpc = new Rpc(provider);
   *
   * rpc.state.subscribeStorage([[storage.system.account, <Address>]], (_, values) => {
   *   console.log(values)
   * }).then((subscriptionId) => {
   *   console.log('balance changes subscription id: ', subscriptionId)
   * })
   * ```
   */
  subscribe(e, t, r, i) {
    return this.__internal__endpointStats.subscriptions++, this.__internal__stats.total.subscriptions++, this.send(t, r, !1, { callback: i, type: e });
  }
  /**
   * @summary Allows unsubscribing to subscriptions made with [[subscribe]].
   */
  async unsubscribe(e, t, r) {
    const i = `${e}::${r}`;
    if (Ne(this.__internal__subscriptions[i]))
      return on.debug(() => `Unable to find active subscription=${i}`), !1;
    delete this.__internal__subscriptions[i];
    try {
      return this.isConnected && !Mr(this.__internal__websocket) ? this.send(t, [r]) : !0;
    } catch {
      return !1;
    }
  }
}
const V4 = /* @__PURE__ */ Qt("api/util");
function B4(n, { block: { extrinsics: e, header: t } }, r, i) {
  for (const [s, a] of e.entries())
    if (a.hash.eq(n))
      return {
        blockNumber: vu(t.number) ? t.number.unwrap() : t.number,
        events: r.filter(({ phase: o }) => o.isApplyExtrinsic && o.asApplyExtrinsic.eqn(s)),
        txIndex: s
      };
  if (i.isInBlock) {
    const s = e.map((a) => a.hash.toHex());
    V4.warn(`block ${t.hash.toHex()}: Unable to find extrinsic ${n.toHex()} inside ${s.join(", ")}`);
  }
  return {};
}
function Hc(n) {
  return ue(n.sign);
}
function zp(n, e) {
  const t = (a) => Object.keys(e[a]), r = (a, o) => n(e[a][o]), i = {}, s = Object.keys(e);
  for (let a = 0, o = s.length; a < o; a++)
    q_(i, s[a], t, r);
  return i;
}
const H4 = (n) => n;
function wd(n, e, t, r) {
  return n.filter(({ event: i }) => e === i.section && t.includes(i.method)).map((i) => r(i));
}
function F4({ event: { data: [n] } }) {
  return n;
}
function j4({ event: { data: n, method: e } }) {
  return e === "ExtrinsicSuccess" ? n[0] : n[1];
}
function W4(n = []) {
  return wd(n, "system", ["ExtrinsicFailed"], F4)[0];
}
function q4(n = []) {
  return wd(n, "system", ["ExtrinsicFailed", "ExtrinsicSuccess"], j4)[0];
}
class Aa {
  constructor({ blockNumber: e, dispatchError: t, dispatchInfo: r, events: i, internalError: s, status: a, txHash: o, txIndex: c }) {
    b(this, "dispatchError");
    b(this, "dispatchInfo");
    b(this, "internalError");
    b(this, "events");
    b(this, "status");
    b(this, "txHash");
    b(this, "txIndex");
    b(this, "blockNumber");
    this.dispatchError = t || W4(i), this.dispatchInfo = r || q4(i), this.events = i || [], this.internalError = s, this.status = a, this.txHash = o, this.txIndex = c, this.blockNumber = e;
  }
  get isCompleted() {
    return this.isError || this.status.isInBlock || this.status.isFinalized;
  }
  get isError() {
    return this.status.isDropped || this.status.isFinalityTimeout || this.status.isInvalid || this.status.isUsurped;
  }
  get isFinalized() {
    return this.status.isFinalized;
  }
  get isInBlock() {
    return this.status.isInBlock;
  }
  get isWarning() {
    return this.status.isRetracted;
  }
  /**
   * @description Filters EventRecords for the specified method & section (there could be multiple)
   */
  filterRecords(e, t) {
    return wd(this.events, e, Array.isArray(t) ? t : [t], H4);
  }
  /**
   * @description Finds an EventRecord for the specified method & section
   */
  findRecord(e, t) {
    return this.filterRecords(e, t)[0];
  }
  /**
   * @description Creates a human representation of the output
   */
  toHuman(e) {
    var t, r, i;
    return {
      dispatchError: (t = this.dispatchError) == null ? void 0 : t.toHuman(),
      dispatchInfo: (r = this.dispatchInfo) == null ? void 0 : r.toHuman(),
      events: this.events.map((s) => s.toHuman(e)),
      internalError: (i = this.internalError) == null ? void 0 : i.message.toString(),
      status: this.status.toHuman(e)
    };
  }
}
function Xp(n, e, t, { header: r, mortalLength: i, nonce: s }) {
  if (!r) {
    if (t.era && !t.blockHash)
      throw new Error("Expected blockHash to be passed alongside non-immortal era options");
    return xe(t.era) && (delete t.era, delete t.blockHash), Zl(n, t, { nonce: s });
  }
  return Zl(n, t, {
    blockHash: r.hash,
    era: e.createTypeUnsafe("ExtrinsicEra", [{
      current: r.number,
      period: t.era || i
    }]),
    nonce: s
  });
}
function Gp(n, e) {
  let t = {};
  return ue(n) ? e = n : t = J({}, n), [t, e];
}
function Zl(n, e, t) {
  return J({ blockHash: n.genesisHash, genesisHash: n.genesisHash }, e, t, { runtimeVersion: n.runtimeVersion, signedExtensions: n.registry.signedExtensions, version: n.extrinsicType });
}
function z4(n = {}) {
  return Yt(n) || xe(n) ? { nonce: n } : n;
}
function X4({ api: n, apiType: e, blockHash: t, decorateMethod: r }) {
  const i = n.registry.createClass("Extrinsic");
  class s extends i {
    constructor(c, l) {
      super(c, l, { version: n.extrinsicType });
      b(this, "__internal__ignoreStatusCb");
      b(this, "__internal__transformResult", Xr);
      b(this, "__internal__observeSign", (c, l) => {
        const u = Hc(c) ? c.address : c.toString(), f = z4(l);
        return n.derive.tx.signingInfo(u, f.nonce, f.era).pipe(Th(), So(async (m) => {
          const y = Xp(n, this.registry, f, m);
          let _ = -1;
          return Hc(c) ? this.sign(c, y) : _ = await this.__internal__signViaSigner(u, y, m.header), { options: y, updateId: _ };
        }));
      });
      b(this, "__internal__observeStatus", (c, l) => {
        if (!l.isFinalized && !l.isInBlock)
          return fe(this.__internal__transformResult(new Aa({
            status: l,
            txHash: c
          })));
        const u = l.isInBlock ? l.asInBlock : l.asFinalized;
        return n.derive.tx.events(u).pipe(oe(({ block: f, events: m }) => this.__internal__transformResult(new Aa({
          ...B4(c, f, m, l),
          status: l,
          txHash: c
        }))), oi((f) => fe(this.__internal__transformResult(new Aa({
          internalError: f,
          status: l,
          txHash: c
        })))));
      });
      b(this, "__internal__observeSend", (c) => n.rpc.author.submitExtrinsic(this).pipe(Ps((l) => {
        this.__internal__updateSigner(l, c);
      })));
      b(this, "__internal__observeSubscribe", (c) => {
        const l = this.hash;
        return n.rpc.author.submitAndWatchExtrinsic(this).pipe(Ce((u) => this.__internal__observeStatus(l, u)), Ps((u) => {
          this.__internal__updateSigner(u, c);
        }));
      });
      b(this, "__internal__signViaSigner", async (c, l, u) => {
        const f = l.signer || n.signer;
        if (!f)
          throw new Error("No signer specified, either via api.setSigner or via sign options. You possibly need to pass through an explicit keypair for the origin so it can be used for signing.");
        const m = this.registry.createTypeUnsafe("SignerPayload", [J({}, l, {
          address: c,
          blockNumber: u ? u.number : 0,
          method: this.method
        })]);
        let y;
        if (ue(f.signPayload))
          y = await f.signPayload(m.toPayload());
        else if (ue(f.signRaw))
          y = await f.signRaw(m.toRaw());
        else
          throw new Error("Invalid signer interface, it should implement either signPayload or signRaw (or both)");
        return super.addSignature(c, y.signature, m.toPayload()), y.id;
      });
      b(this, "__internal__updateSigner", (c, l) => {
        if (l && l.updateId !== -1) {
          const { options: u, updateId: f } = l, m = u.signer || n.signer;
          m && ue(m.update) && m.update(f, c);
        }
      });
      this.__internal__ignoreStatusCb = e === "rxjs";
    }
    get hasDryRun() {
      var c;
      return ue((c = n.rpc.system) == null ? void 0 : c.dryRun);
    }
    get hasPaymentInfo() {
      var c;
      return ue((c = n.call.transactionPaymentApi) == null ? void 0 : c.queryInfo);
    }
    // dry run an extrinsic
    dryRun(c, l) {
      if (!this.hasDryRun)
        throw new Error("The system.dryRun RPC call is not available in your environment");
      return t || Pe(l) || te(l) ? r(() => n.rpc.system.dryRun(this.toHex(), t || l)) : r(() => this.__internal__observeSign(c, l).pipe(Ce(() => n.rpc.system.dryRun(this.toHex()))))();
    }
    // calculate the payment info for this transaction (if signed and submitted)
    paymentInfo(c, l) {
      if (!this.hasPaymentInfo)
        throw new Error("The transactionPaymentApi.queryInfo runtime call is not available in your environment");
      if (t || Pe(l) || te(l))
        return r(() => n.callAt(t || l).pipe(Ce((m) => {
          const y = this.toU8a();
          return m.transactionPaymentApi.queryInfo(y, y.length);
        })));
      const [u] = Gp(l), f = Hc(c) ? c.address : c.toString();
      return r(() => n.derive.tx.signingInfo(f, u.nonce, u.era).pipe(Th(), Ce((m) => {
        const y = Xp(n, this.registry, u, m), _ = Zl(n, y, {}), v = n.tx(this.toU8a()).signFake(f, _).toU8a();
        return n.call.transactionPaymentApi.queryInfo(v, v.length);
      })))();
    }
    // send implementation for both immediate Hash and statusCb variants
    send(c) {
      const l = n.hasSubscriptions && (this.__internal__ignoreStatusCb || !!c);
      return r(l ? this.__internal__observeSubscribe : this.__internal__observeSend)(c);
    }
    /**
     * @description Signs a transaction, returning `this` to allow chaining. E.g.: `signAsync(...).send()`. Like `.signAndSend` this will retrieve the nonce and blockHash to send the tx with.
     */
    signAsync(c, l) {
      return r(() => this.__internal__observeSign(c, l).pipe(oe(() => this)))();
    }
    // signAndSend implementation for all 3 cases above
    signAndSend(c, l, u) {
      const [f, m] = Gp(l, u), y = n.hasSubscriptions && (this.__internal__ignoreStatusCb || !!m);
      return r(
        () => this.__internal__observeSign(c, f).pipe(Ce((_) => y ? this.__internal__observeSubscribe(_) : this.__internal__observeSend(_)))
        // FIXME This is wrong, SubmittableResult is _not_ a codec
      )(m);
    }
    // adds a transform to the result, applied before result is returned
    withResultTransform(c) {
      return this.__internal__transformResult = c, this;
    }
  }
  return s;
}
function Zp(n, e, t, r, i) {
  const s = X4({ api: e, apiType: n, blockHash: i, decorateMethod: t });
  return (a) => new s(r || e.registry, a);
}
const G4 = Qt("api/augment");
function Jp(n, e, t = []) {
  return e.length ? ` ${e.length} ${n}${t.length ? " and" : ""}` : "";
}
function Kp(n, e) {
  return e.length ? `
	${n.padStart(7)}: ${e.sort().join(", ")}` : "";
}
function Yp(n, e, [t, r]) {
  (t.length || r.length) && G4.warn(`api.${n}: Found${Jp("added", t, r)}${Jp("removed", r)} ${e}:${Kp("added", t)}${Kp("removed", r)}`);
}
function Qp(n, e) {
  return n.filter((t) => !e.includes(t));
}
function Z4(n, e) {
  return n.filter((t) => e.includes(t));
}
function J4(n, e) {
  const t = Object.keys(n), r = Object.keys(e);
  return [
    Qp(t, r),
    Qp(r, t)
  ];
}
function $p(n, e) {
  const t = Object.keys(n), r = Z4(Object.keys(e), t), i = [];
  for (let s = 0, a = r.length; s < a; s++) {
    const o = r[s], c = Object.keys(n[o]), l = Object.keys(e[o]);
    for (let u = 0, f = l.length; u < f; u++) {
      const m = l[u];
      c.includes(m) || i.push(`${o}.${m}`);
    }
  }
  return i;
}
function K4(n, e) {
  return [
    $p(e, n),
    $p(n, e)
  ];
}
function jn(n, e, t, r = !1) {
  r && pg(t), n && Object.keys(t).length && (Yp(n, "modules", J4(e, t)), Yp(n, "calls", K4(e, t)));
  const i = Object.keys(e);
  for (let s = 0, a = i.length; s < a; s++) {
    const o = i[s], c = e[o];
    t[o] || (t[o] = {}), Lr(t[o], Object.keys(c), (l) => c[l]);
  }
  return t;
}
function em({ lookup: n }, { method: e, section: t }, r) {
  return `${t}.${e}(${r.map((i) => n.getTypeDef(i).type).join(", ")})`;
}
function ua(n, e, t) {
  const r = t.filter((i) => !Ne(i));
  if (e.meta.type.isPlain) {
    if (r.length !== 0)
      throw new Error(`${em(n, e, [])} does not take any arguments, ${r.length} found`);
  } else {
    const { hashers: i, key: s } = e.meta.type.asMap, a = i.length === 1 ? [s] : n.lookup.getSiType(s).def.asTuple.map((o) => o);
    if (r.length !== a.length)
      throw new Error(`${em(n, e, a)} is a map, requiring ${a.length} arguments, ${r.length} found`);
  }
  return [e, r];
}
class Y4 {
  constructor() {
    b(this, "__internal__eventemitter", new ev());
  }
  emit(e, ...t) {
    return this.__internal__eventemitter.emit(e, ...t);
  }
  /**
   * @description Attach an eventemitter handler to listen to a specific event
   *
   * @param type The type of event to listen to. Available events are `connected`, `disconnected`, `ready` and `error`
   * @param handler The callback to be called when the event fires. Depending on the event type, it could fire with additional arguments.
   *
   * @example
   * <BR>
   *
   * ```javascript
   * api.on('connected', (): void => {
   *   console.log('API has been connected to the endpoint');
   * });
   *
   * api.on('disconnected', (): void => {
   *   console.log('API has been disconnected from the endpoint');
   * });
   * ```
   */
  on(e, t) {
    return this.__internal__eventemitter.on(e, t), this;
  }
  /**
   * @description Remove the given eventemitter handler
   *
   * @param type The type of event the callback was attached to. Available events are `connected`, `disconnected`, `ready` and `error`
   * @param handler The callback to unregister.
   *
   * @example
   * <BR>
   *
   * ```javascript
   * const handler = (): void => {
   *  console.log('Connected !);
   * };
   *
   * // Start listening
   * api.on('connected', handler);
   *
   * // Stop listening
   * api.off('connected', handler);
   * ```
   */
  off(e, t) {
    return this.__internal__eventemitter.removeListener(e, t), this;
  }
  /**
   * @description Attach an one-time eventemitter handler to listen to a specific event
   *
   * @param type The type of event to listen to. Available events are `connected`, `disconnected`, `ready` and `error`
   * @param handler The callback to be called when the event fires. Depending on the event type, it could fire with additional arguments.
   *
   * @example
   * <BR>
   *
   * ```javascript
   * api.once('connected', (): void => {
   *   console.log('API has been connected to the endpoint');
   * });
   *
   * api.once('disconnected', (): void => {
   *   console.log('API has been disconnected from the endpoint');
   * });
   * ```
   */
  once(e, t) {
    return this.__internal__eventemitter.once(e, t), this;
  }
}
const da = 1e3, Fc = 250, Q4 = 50, jc = Qt("api/init");
let $4 = 0;
function Wc(n, { method: e, section: t }) {
  return zn(n.rx.query[t] && n.rx.query[t][e], () => `query.${t}.${e} is not available in this version of the metadata`);
}
class eR extends Y4 {
  /**
   * @description Create an instance of the class
   *
   * @param options Options object to create API instance or a Provider instance
   *
   * @example
   * <BR>
   *
   * ```javascript
   * import Api from '@polkadot/api/promise';
   *
   * const api = new Api().isReady();
   *
   * api.rpc.subscribeNewHeads((header) => {
   *   console.log(`new block #${header.number.toNumber()}`);
   * });
   * ```
   */
  constructor(t, r, i) {
    var a;
    super();
    b(this, "__internal__instanceId");
    b(this, "__internal__runtimeLog", {});
    b(this, "__internal__registry");
    b(this, "__internal__storageGetQ", []);
    b(this, "__internal__storageSubQ", []);
    // HACK Use BN import so decorateDerive works... yes, wtf.
    b(this, "__phantom", new Z(0));
    b(this, "_type");
    b(this, "_call", {});
    b(this, "_consts", {});
    b(this, "_derive");
    b(this, "_errors", {});
    b(this, "_events", {});
    b(this, "_extrinsics");
    b(this, "_extrinsicType", To.LATEST_EXTRINSIC_VERSION);
    b(this, "_genesisHash");
    b(this, "_isConnected");
    b(this, "_isReady", !1);
    b(this, "_query", {});
    b(this, "_queryMulti");
    b(this, "_rpc");
    b(this, "_rpcCore");
    b(this, "_runtimeMap", {});
    b(this, "_runtimeChain");
    b(this, "_runtimeMetadata");
    b(this, "_runtimeVersion");
    b(this, "_rx", { call: {}, consts: {}, query: {}, tx: {} });
    b(this, "_options");
    /**
     * This is the one and only method concrete children classes need to implement.
     * It's a higher-order function, which takes one argument
     * `method: Method extends (...args: any[]) => Observable<any>`
     * (and one optional `options`), and should return the user facing method.
     * For example:
     * - For ApiRx, `decorateMethod` should just be identity, because the input
     * function is already an Observable
     * - For ApiPromise, `decorateMethod` should return a function that takes all
     * the parameters from `method`, adds an optional `callback` argument, and
     * returns a Promise.
     *
     * We could easily imagine other user-facing interfaces, which are simply
     * implemented by transforming the Observable to Stream/Iterator/Kefir/Bacon
     * via `decorateMethod`.
     */
    b(this, "_decorateMethod");
    /**
     * Put the `this.onCall` function of ApiRx here, because it is needed by
     * `api._rx`.
     */
    b(this, "_rxDecorateMethod", (t) => t);
    this.__internal__instanceId = `${++$4}`, this.__internal__registry = ((a = t.source) == null ? void 0 : a.registry) || t.registry || new vd(), this._rx.callAt = (o, c) => Xn(this.at(o, c)).pipe(oe((l) => l.rx.call)), this._rx.queryAt = (o, c) => Xn(this.at(o, c)).pipe(oe((l) => l.rx.query)), this._rx.registry = this.__internal__registry, this._decorateMethod = i, this._options = t, this._type = r;
    const s = t.source ? t.source._rpcCore.provider.isClonable ? t.source._rpcCore.provider.clone() : t.source._rpcCore.provider : t.provider || new Zs();
    this._rpcCore = new u6(this.__internal__instanceId, this.__internal__registry, {
      isPedantic: this._options.isPedantic,
      provider: s,
      userRpc: this._options.rpc
    }), this._isConnected = new Eh(this._rpcCore.provider.isConnected), this._rx.hasSubscriptions = this._rpcCore.provider.hasSubscriptions;
  }
  /**
   * @description Return the current used registry
   */
  get registry() {
    return this.__internal__registry;
  }
  /**
   * @description Creates an instance of a type as registered
   */
  createType(t, ...r) {
    return this.__internal__registry.createType(t, ...r);
  }
  /**
   * @description Register additional user-defined of chain-specific types in the type registry
   */
  registerTypes(t) {
    t && this.__internal__registry.register(t);
  }
  /**
   * @returns `true` if the API operates with subscriptions
   */
  get hasSubscriptions() {
    return this._rpcCore.provider.hasSubscriptions;
  }
  /**
   * @returns `true` if the API decorate multi-key queries
   */
  get supportMulti() {
    return this._rpcCore.provider.hasSubscriptions || !!this._rpcCore.state.queryStorageAt;
  }
  _emptyDecorated(t, r) {
    return {
      call: {},
      consts: {},
      errors: {},
      events: {},
      query: {},
      registry: t,
      rx: {
        call: {},
        query: {}
      },
      tx: Zp(this._type, this._rx, this._decorateMethod, t, r)
    };
  }
  _createDecorated(t, r, i, s) {
    i || (i = this._emptyDecorated(t.registry, s)), (r || !t.decoratedMeta) && (t.decoratedMeta = PN(t.registry, t.metadata));
    const a = this._decorateCalls(t, this._decorateMethod, s), o = this._decorateCalls(t, this._rxDecorateMethod, s), c = this._decorateStorage(t.decoratedMeta, this._decorateMethod, s), l = this._decorateStorage(t.decoratedMeta, this._rxDecorateMethod, s);
    return jn("consts", t.decoratedMeta.consts, i.consts, r), jn("errors", t.decoratedMeta.errors, i.errors, r), jn("events", t.decoratedMeta.events, i.events, r), jn("query", c, i.query, r), jn("query", l, i.rx.query, r), jn("call", a, i.call, r), jn("call", o, i.rx.call, r), i.findCall = (u) => S0(t.registry, u), i.findError = (u) => E0(t.registry, u), i.queryMulti = s ? this._decorateMultiAt(i, this._decorateMethod, s) : this._decorateMulti(this._decorateMethod), i.runtimeVersion = t.runtimeVersion, {
      createdAt: s,
      decoratedApi: i,
      decoratedMeta: t.decoratedMeta
    };
  }
  _injectMetadata(t, r = !1) {
    (r || !t.decoratedApi) && (t.decoratedApi = this._emptyDecorated(t.registry));
    const { decoratedApi: i, decoratedMeta: s } = this._createDecorated(t, r, t.decoratedApi);
    this._call = i.call, this._consts = i.consts, this._errors = i.errors, this._events = i.events, this._query = i.query, this._rx.call = i.rx.call, this._rx.query = i.rx.query;
    const a = this._decorateExtrinsics(s, this._decorateMethod), o = this._decorateExtrinsics(s, this._rxDecorateMethod);
    r || !this._extrinsics ? (this._extrinsics = a, this._rx.tx = o) : (jn("tx", a, this._extrinsics, !1), jn(null, o, this._rx.tx, !1)), jn(null, s.consts, this._rx.consts, r), this.emit("decorated");
  }
  /**
   * @deprecated
   * backwards compatible endpoint for metadata injection, may be removed in the future (However, it is still useful for testing injection)
   */
  injectMetadata(t, r, i) {
    this._injectMetadata({ counter: 0, metadata: t, registry: i || this.__internal__registry, runtimeVersion: this.__internal__registry.createType("RuntimeVersionPartial") }, r);
  }
  _decorateFunctionMeta(t, r) {
    return r.meta = t.meta, r.method = t.method, r.section = t.section, r.toJSON = t.toJSON, t.callIndex && (r.callIndex = t.callIndex), r;
  }
  // Filter all RPC methods based on the results of the rpc_methods call. We do this in the following
  // manner to cater for both old and new:
  //   - when the number of entries are 0, only remove the ones with isOptional (account & contracts)
  //   - when non-zero, remove anything that is not in the array (we don't do this)
  _filterRpc(t, r) {
    Object.keys(r).length !== 0 && (this._rpcCore.addUserInterfaces(r), this._decorateRpc(this._rpcCore, this._decorateMethod, this._rpc), this._decorateRpc(this._rpcCore, this._rxDecorateMethod, this._rx.rpc));
    const i = {};
    for (let a = 0, o = t.length; a < o; a++) {
      const [c] = t[a].split("_");
      i[c] = !0;
    }
    const s = Object.keys(i);
    for (let a = 0, o = s.length; a < o; a++) {
      const c = yg(s[a]), l = `${c}Api`;
      this._runtimeMap[ba(c, 64)] = c, this._runtimeMap[ba(l, 64)] = l;
    }
    this._filterRpcMethods(t);
  }
  _filterRpcMethods(t) {
    const r = t.length !== 0, i = [...this._rpcCore.mapping.entries()], s = [], a = i.length;
    for (let c = 0; c < a; c++) {
      const [, { alias: l, endpoint: u, method: f, pubsub: m, section: y }] = i[c];
      s.push(`${y}_${f}`), m && (s.push(`${y}_${m[1]}`), s.push(`${y}_${m[2]}`)), l && s.push(...l), u && s.push(u);
    }
    const o = t.filter((c) => !s.includes(c) && !c.includes("_unstable_"));
    o.length && !this._options.noInitWarn && jc.warn(`RPC methods not decorated: ${o.join(", ")}`);
    for (let c = 0; c < a; c++) {
      const [l, { method: u, section: f }] = i[c];
      r && !t.includes(l) && l !== "rpc_methods" && this._rpc[f] && (delete this._rpc[f][u], delete this._rx.rpc[f][u]);
    }
  }
  _rpcSubmitter(t) {
    return t((i, ...s) => Xn(this._rpcCore.provider.send(i, s)));
  }
  _decorateRpc(t, r, i = this._rpcSubmitter(r)) {
    const s = i, a = (o, c) => {
      const l = t[o][c], u = r(l, { methodName: c });
      return u.meta = l.meta, u.raw = r(l.raw, { methodName: c }), u;
    };
    for (let o = 0, c = t.sections.length; o < c; o++) {
      const l = t.sections[o];
      if (!Object.prototype.hasOwnProperty.call(s, l)) {
        const u = Object.keys(t[l]), f = (m) => a(l, m);
        for (let m = 0, y = u.length; m < y; m++) {
          const _ = u[m];
          (this.hasSubscriptions || !(_.startsWith("subscribe") || _.startsWith("unsubscribe"))) && (Object.prototype.hasOwnProperty.call(s, l) || (s[l] = {}), Ut(s[l], _, f));
        }
      }
    }
    return s;
  }
  // add all definition entries
  _addRuntimeDef(t, r) {
    if (!r)
      return;
    const i = Object.entries(r);
    for (let s = 0, a = i.length; s < a; s++) {
      const [o, c] = i[s];
      if (t[o])
        for (let l = 0, u = c.length; l < u; l++) {
          const f = c[l], m = t[o].find(({ version: y }) => f.version === y);
          m ? J(m.methods, f.methods) : t[o].push(f);
        }
      else
        t[o] = c;
    }
  }
  // extract all runtime definitions
  _getRuntimeDefs(t, r, i = "") {
    const s = {}, a = Object.values(Ga);
    for (let o = 0, c = a.length; o < c; o++)
      this._addRuntimeDef(s, a[o].runtime);
    return this._addRuntimeDef(s, n6(t, i, r)), this._addRuntimeDef(s, this._options.runtime), Object.entries(s);
  }
  // pre-metadata decoration
  _decorateCalls({ registry: t, runtimeVersion: { apis: r, specName: i, specVersion: s } }, a, o) {
    const c = {}, l = {}, u = {}, f = this._getRuntimeDefs(t, i, this._runtimeChain), m = [], y = `${i.toString()}/${s.toString()}`, _ = this.__internal__runtimeLog[y] || !1;
    this.__internal__runtimeLog[y] = !0;
    for (let I = 0, D = f.length; I < D; I++) {
      const [L, V] = f[I], F = ba(L, 64), U = r.find(([Y]) => Y.eq(F));
      if (u[F] = !0, U) {
        const Y = V.map(({ version: O }) => O).sort(), Q = V.find(({ version: O }) => U[1].eq(O));
        if (Q) {
          const O = Ee(L), B = Object.entries(Q.methods);
          if (B.length) {
            l[O] || (l[O] = {});
            for (let P = 0, d = B.length; P < d; P++) {
              const [h, g] = B[P], E = Ee(h);
              l[O][E] = J({ method: E, name: `${L}_${h}`, section: O, sectionHash: F }, g);
            }
          }
        } else
          m.push(`${L}/${U[1].toString()} (${Y.join("/")} known)`);
      }
    }
    const v = r.map(([I, D]) => [I.toHex(), D.toString()]).filter(([I]) => !u[I]).map(([I, D]) => `${this._runtimeMap[I] || I}/${D}`);
    !this._options.noInitWarn && !_ && (m.length && jc.warn(`${y}: Not decorating runtime apis without matching versions: ${m.join(", ")}`), v.length && jc.warn(`${y}: Not decorating unknown runtime apis: ${v.join(", ")}`));
    const C = o ? (I, D) => this._rpcCore.state.call(I, D, o) : (I, D) => this._rpcCore.state.call(I, D), A = (I) => Lr({}, Object.keys(l[I]), (D) => this._decorateCall(t, l[I][D], C, a)), R = Object.keys(l);
    for (let I = 0, D = R.length; I < D; I++)
      Ut(c, R[I], A);
    return c;
  }
  _decorateCall(t, r, i, s) {
    const a = s((...o) => {
      if (o.length !== r.params.length)
        throw new Error(`${r.name}:: Expected ${r.params.length} arguments, found ${o.length}`);
      const c = t.createType("Raw", Wt(o.map((l, u) => t.createTypeUnsafe(r.params[u].type, [l]).toU8a())));
      return i(r.name, c).pipe(oe((l) => t.createTypeUnsafe(r.type, [l])));
    });
    return a.meta = r, a;
  }
  // only be called if supportMulti is true
  _decorateMulti(t) {
    return t((r) => r.length ? (this.hasSubscriptions ? this._rpcCore.state.subscribeStorage : this._rpcCore.state.queryStorageAt)(r.map((i) => Array.isArray(i) ? i[0].creator.meta.type.isPlain ? [i[0].creator] : i[0].creator.meta.type.asMap.hashers.length === 1 ? [i[0].creator, i.slice(1)] : [i[0].creator, ...i.slice(1)] : [i.creator])) : fe([]));
  }
  _decorateMultiAt(t, r, i) {
    return r((s) => s.length ? this._rpcCore.state.queryStorageAt(s.map((a) => {
      if (Array.isArray(a)) {
        const { creator: o } = Wc(t, a[0].creator);
        return o.meta.type.isPlain ? [o] : o.meta.type.asMap.hashers.length === 1 ? [o, a.slice(1)] : [o, ...a.slice(1)];
      }
      return [Wc(t, a.creator).creator];
    }), i) : fe([]));
  }
  _decorateExtrinsics({ tx: t }, r) {
    const i = Zp(this._type, this._rx, r), s = (o) => Lr({}, Object.keys(t[o]), (c) => c.startsWith("$") ? t[o][c] : this._decorateExtrinsicEntry(t[o][c], i)), a = Object.keys(t);
    for (let o = 0, c = a.length; o < c; o++)
      Ut(i, a[o], s);
    return i;
  }
  _decorateExtrinsicEntry(t, r) {
    const i = (...s) => r(t(...s));
    return i.is = (s) => t.is(s), this._decorateFunctionMeta(t, i);
  }
  _decorateStorage({ query: t, registry: r }, i, s) {
    const a = {}, o = (l) => Lr({}, Object.keys(t[l]), (u) => s ? this._decorateStorageEntryAt(r, t[l][u], i, s) : this._decorateStorageEntry(t[l][u], i)), c = Object.keys(t);
    for (let l = 0, u = c.length; l < u; l++)
      Ut(a, c[l], o);
    return a;
  }
  _decorateStorageEntry(t, r) {
    const i = (o, c) => ua(c || this.__internal__registry, t, o), s = (o) => Xn(this.at(o)).pipe(oe((c) => Wc(c, t))), a = this._decorateStorageCall(t, r);
    return a.creator = t, a.at = r((o, ...c) => s(o).pipe(Ce((l) => l(...c)))), a.hash = r((...o) => this._rpcCore.state.getStorageHash(i(o))), a.is = (o) => o.section === t.section && o.method === t.method, a.key = (...o) => pe(Ri(t(...o))[1]), a.keyPrefix = (...o) => pe(t.keyPrefix(...o)), a.size = r((...o) => this._rpcCore.state.getStorageSize(i(o))), a.sizeAt = r((o, ...c) => s(o).pipe(Ce((l) => this._rpcCore.state.getStorageSize(i(c, l.creator.meta.registry), o)))), t.iterKey && t.meta.type.isMap && (a.entries = r(ve(this.__internal__instanceId, (...o) => this._retrieveMapEntries(t, null, o))), a.entriesAt = r(ve(this.__internal__instanceId, (o, ...c) => s(o).pipe(Ce((l) => this._retrieveMapEntries(l.creator, o, c))))), a.entriesPaged = r(ve(this.__internal__instanceId, (o) => this._retrieveMapEntriesPaged(t, void 0, o))), a.keys = r(ve(this.__internal__instanceId, (...o) => this._retrieveMapKeys(t, null, o))), a.keysAt = r(ve(this.__internal__instanceId, (o, ...c) => s(o).pipe(Ce((l) => this._retrieveMapKeys(l.creator, o, c))))), a.keysPaged = r(ve(this.__internal__instanceId, (o) => this._retrieveMapKeysPaged(t, void 0, o)))), this.supportMulti && t.meta.type.isMap && (a.multi = r((o) => t.meta.type.asMap.hashers.length === 1 ? this._retrieveMulti(o.map((c) => [t, [c]])) : this._retrieveMulti(o.map((c) => [t, c])))), this._decorateFunctionMeta(t, a);
  }
  _decorateStorageEntryAt(t, r, i, s) {
    const a = (c) => ua(t, r, c), o = i((...c) => this._rpcCore.state.getStorage(a(c), s));
    return o.creator = r, o.hash = i((...c) => this._rpcCore.state.getStorageHash(a(c), s)), o.is = (c) => c.section === r.section && c.method === r.method, o.key = (...c) => pe(Ri(r(...c))[1]), o.keyPrefix = (...c) => pe(r.keyPrefix(...c)), o.size = i((...c) => this._rpcCore.state.getStorageSize(a(c), s)), r.iterKey && r.meta.type.isMap && (o.entries = i(ve(this.__internal__instanceId, (...c) => this._retrieveMapEntries(r, s, c))), o.entriesPaged = i(ve(this.__internal__instanceId, (c) => this._retrieveMapEntriesPaged(r, s, c))), o.keys = i(ve(this.__internal__instanceId, (...c) => this._retrieveMapKeys(r, s, c))), o.keysPaged = i(ve(this.__internal__instanceId, (c) => this._retrieveMapKeysPaged(r, s, c)))), this.supportMulti && r.meta.type.isMap && (o.multi = i((c) => r.meta.type.asMap.hashers.length === 1 ? this._retrieveMulti(c.map((l) => [r, [l]]), s) : this._retrieveMulti(c.map((l) => [r, l]), s))), this._decorateFunctionMeta(r, o);
  }
  _queueStorage(t, r) {
    const i = r === this.__internal__storageSubQ ? this._rpcCore.state.subscribeStorage : this._rpcCore.state.queryStorageAt;
    let s = r.length - 1, a = 0, o;
    return s === -1 || !r[s] || r[s][1].length === Q4 ? (s++, o = Xn(
      // we delay the execution until the next tick, this allows
      // any queries made in this timeframe to be added to the same
      // queue for a single query
      new Promise((c) => {
        ws(() => {
          const l = r[s][1];
          delete r[s], c(l);
        });
      })
    ).pipe(Ce((c) => i(c))), r.push([o, [t]])) : (o = r[s][0], a = r[s][1].length, r[s][1].push(t)), o.pipe(
      // return the single value at this index
      oe((c) => c[a])
    );
  }
  // Decorate the base storage call. In the case or rxjs or promise-without-callback (await)
  // we make a subscription, alternatively we push this through a single-shot query
  _decorateStorageCall(t, r) {
    const i = ve(this.__internal__instanceId, (...s) => {
      const a = ua(this.__internal__registry, t, s);
      return this.hasSubscriptions ? this._queueStorage(a, this.__internal__storageSubQ) : this._rpcCore.state.getStorage(a);
    });
    return r(i, {
      methodName: t.method,
      overrideNoSub: (...s) => this._queueStorage(ua(this.__internal__registry, t, s), this.__internal__storageGetQ)
    });
  }
  // retrieve a set of values for a specific set of keys - here we chunk the keys into PAGE_SIZE sizes
  _retrieveMulti(t, r) {
    if (!t.length)
      return fe([]);
    const i = this.hasSubscriptions && !r ? this._rpcCore.state.subscribeStorage : this._rpcCore.state.queryStorageAt;
    return t.length <= Fc ? r ? i(t, r) : i(t) : Oe(Qc(t, Fc).map((s) => r ? i(s, r) : i(s))).pipe(oe(ma));
  }
  _retrieveMapKeys({ iterKey: t, meta: r, method: i, section: s }, a, o) {
    if (!t || !r.type.isMap)
      throw new Error("keys can only be retrieved on maps");
    const c = t(...o).toHex(), l = new Eh(c), u = a ? (m) => this._rpcCore.state.getKeysPaged(c, da, m, a) : (m) => this._rpcCore.state.getKeysPaged(c, da, m), f = (m) => m.setMeta(r, s, i);
    return l.pipe(
      Ce(u),
      oe((m) => m.map(f)),
      Ps((m) => ws(() => {
        m.length === da ? l.next(m[da - 1].toHex()) : l.complete();
      })),
      ZP(),
      // toArray since we want to startSubject to be completed
      oe(ma)
    );
  }
  _retrieveMapKeysPaged({ iterKey: t, meta: r, method: i, section: s }, a, o) {
    if (!t || !r.type.isMap)
      throw new Error("keys can only be retrieved on maps");
    const c = (u) => u.setMeta(r, s, i);
    return (a ? (u) => this._rpcCore.state.getKeysPaged(u, o.pageSize, o.startKey || u, a) : (u) => this._rpcCore.state.getKeysPaged(u, o.pageSize, o.startKey || u))(t(...o.args).toHex()).pipe(oe((u) => u.map(c)));
  }
  _retrieveMapEntries(t, r, i) {
    const s = r ? (a) => this._rpcCore.state.queryStorageAt(a, r) : (a) => this._rpcCore.state.queryStorageAt(a);
    return this._retrieveMapKeys(t, r, i).pipe(Ce((a) => a.length ? Oe(Qc(a, Fc).map(s)).pipe(oe((o) => ma(o).map((c, l) => [a[l], c]))) : fe([])));
  }
  _retrieveMapEntriesPaged(t, r, i) {
    const s = r ? (a) => this._rpcCore.state.queryStorageAt(a, r) : (a) => this._rpcCore.state.queryStorageAt(a);
    return this._retrieveMapKeysPaged(t, r, i).pipe(Ce((a) => a.length ? s(a).pipe(oe((o) => o.map((c, l) => [a[l], c]))) : fe([])));
  }
  _decorateDeriveRx(t) {
    var s, a, o, c;
    const r = (s = this._runtimeVersion) == null ? void 0 : s.specName.toString(), i = x4(this.__internal__instanceId, this._rx, J({}, this._options.derives, (c = (o = (a = this._options.typesBundle) == null ? void 0 : a.spec) == null ? void 0 : o[r || ""]) == null ? void 0 : c.derives));
    return zp(t, i);
  }
  _decorateDerive(t) {
    return zp(t, this._rx.derive);
  }
}
const tR = 1e4, qc = Qt("api/init");
function nR(n) {
  return n.toString();
}
class rR extends eR {
  constructor(t, r, i) {
    super(t, r, i);
    b(this, "__internal__atLast", null);
    b(this, "__internal__healthTimer", null);
    b(this, "__internal__registries", []);
    b(this, "__internal__updateSub", null);
    b(this, "__internal__waitingRegistries", {});
    this.registry.setKnownTypes(t), t.source ? this.__internal__registries = t.source.__internal__registries : this.registerTypes(t.types), this._rpc = this._decorateRpc(this._rpcCore, this._decorateMethod), this._rx.rpc = this._decorateRpc(this._rpcCore, this._rxDecorateMethod), this.supportMulti && (this._queryMulti = this._decorateMulti(this._decorateMethod), this._rx.queryMulti = this._decorateMulti(this._rxDecorateMethod)), this._rx.signer = t.signer, this._rpcCore.setRegistrySwap((s) => this.getBlockRegistry(s)), this._rpcCore.setResolveBlockHash((s) => tn(this._rpcCore.chain.getBlockHash(s))), this.hasSubscriptions ? (this._rpcCore.provider.on("disconnected", () => this.__internal__onProviderDisconnect()), this._rpcCore.provider.on("error", (s) => this.__internal__onProviderError(s)), this._rpcCore.provider.on("connected", () => this.__internal__onProviderConnect())) : this._options.noInitWarn || qc.warn("Api will be available in a limited mode since the provider does not support subscriptions"), this._rpcCore.provider.isConnected && this.__internal__onProviderConnect().catch(Kn);
  }
  /**
   * @description Decorates a registry based on the runtime version
   */
  _initRegistry(t, r, i, s, a) {
    t.clearCache(), t.setChainProperties(a || this.registry.getChainProperties()), t.setKnownTypes(this._options), t.register(e6(t, r, i.specName, i.specVersion)), t.setHasher(t6(t, r, i.specName)), t.knownTypes.typesBundle && (t.knownTypes.typesAlias = r6(t, r, i.specName)), t.setMetadata(s, void 0, J({}, $N(t, r, i.specName), this._options.signedExtensions), this._options.noInitWarn);
  }
  /**
   * @description Returns the default versioned registry
   */
  _getDefaultRegistry() {
    return zn(this.__internal__registries.find(({ isDefault: t }) => t), "Initialization error, cannot find the default registry");
  }
  /**
   * @description Returns a decorated API instance at a specific point in time
   */
  async at(t, r) {
    const i = j(t), s = pe(i), a = await this.getBlockRegistry(i, r);
    return (!this.__internal__atLast || this.__internal__atLast[0] !== s) && (this.__internal__atLast = [s, this._createDecorated(a, !0, null, i).decoratedApi]), this.__internal__atLast[1];
  }
  async _createBlockRegistry(t, r, i) {
    const s = new vd(t), a = new eo(s, await tn(this._rpcCore.state.getMetadata.raw(r.parentHash))), o = this._runtimeChain;
    if (!o)
      throw new Error("Invalid initializion order, runtimeChain is not available");
    this._initRegistry(s, o, i, a);
    const c = { counter: 0, lastBlockHash: t, metadata: a, registry: s, runtimeVersion: i };
    return this.__internal__registries.push(c), c;
  }
  _cacheBlockRegistryProgress(t, r) {
    let i = this.__internal__waitingRegistries[t];
    return Ne(i) && (i = this.__internal__waitingRegistries[t] = new Promise((s, a) => {
      r().then((o) => {
        delete this.__internal__waitingRegistries[t], s(o);
      }).catch((o) => {
        delete this.__internal__waitingRegistries[t], a(o);
      });
    })), i;
  }
  _getBlockRegistryViaVersion(t, r) {
    if (r) {
      const i = this.__internal__registries.find(({ runtimeVersion: { specName: s, specVersion: a } }) => s.eq(r.specName) && a.eq(r.specVersion));
      if (i)
        return i.counter++, i.lastBlockHash = t, i;
    }
    return null;
  }
  async _getBlockRegistryViaHash(t) {
    if (!this._genesisHash || !this._runtimeVersion)
      throw new Error("Cannot retrieve data on an uninitialized chain");
    const r = this.registry.createType("HeaderPartial", this._genesisHash.eq(t) ? { number: At, parentHash: this._genesisHash } : await tn(this._rpcCore.chain.getHeader.raw(t)));
    if (r.parentHash.isEmpty)
      throw new Error("Unable to retrieve header and parent from supplied hash");
    i6(this._genesisHash, r.number);
    const i = this.registry.createType("RuntimeVersionPartial", await tn(this._rpcCore.state.getRuntimeVersion.raw(r.parentHash)));
    return (
      // try to find via version
      this._getBlockRegistryViaVersion(t, i) || // return new or in-flight result
      await this._cacheBlockRegistryProgress(i.toHex(), () => this._createBlockRegistry(t, r, i))
    );
  }
  /**
   * @description Sets up a registry based on the block hash defined
   */
  async getBlockRegistry(t, r) {
    return (
      // try to find via blockHash
      this.__internal__registries.find(({ lastBlockHash: i }) => i && jt(i, t)) || // try to find via version
      this._getBlockRegistryViaVersion(t, r) || // return new or in-flight result
      await this._cacheBlockRegistryProgress(pe(t), () => this._getBlockRegistryViaHash(t))
    );
  }
  async _loadMeta() {
    var t;
    return this._isReady ? !0 : (this._unsubscribeUpdates(), [this._genesisHash, this._runtimeMetadata] = (t = this._options.source) != null && t._isReady ? await this._metaFromSource(this._options.source) : await this._metaFromChain(this._options.metadata), this._initFromMeta(this._runtimeMetadata));
  }
  // eslint-disable-next-line @typescript-eslint/require-await
  async _metaFromSource(t) {
    this._extrinsicType = t.extrinsicVersion, this._runtimeChain = t.runtimeChain, this._runtimeVersion = t.runtimeVersion;
    const r = Object.keys(t.rpc), i = [];
    for (let s = 0, a = r.length; s < a; s++) {
      const o = r[s], c = Object.keys(t.rpc[o]);
      for (let l = 0, u = c.length; l < u; l++)
        i.push(`${o}_${c[l]}`);
    }
    return this._filterRpc(i, Mp(this.registry, t.runtimeChain, t.runtimeVersion.specName)), [t.genesisHash, t.runtimeMetadata];
  }
  // subscribe to metadata updates, inject the types on changes
  _subscribeUpdates() {
    this.__internal__updateSub || !this.hasSubscriptions || (this.__internal__updateSub = this._rpcCore.state.subscribeRuntimeVersion().pipe(Ce((t) => {
      var r;
      return (
        // only retrieve the metadata when the on-chain version has been changed
        (r = this._runtimeVersion) != null && r.specVersion.eq(t.specVersion) ? fe(!1) : this._rpcCore.state.getMetadata().pipe(oe((i) => {
          qc.log(`Runtime version updated to spec=${t.specVersion.toString()}, tx=${t.transactionVersion.toString()}`), this._runtimeMetadata = i, this._runtimeVersion = t, this._rx.runtimeVersion = t;
          const s = this._getDefaultRegistry(), a = this._runtimeChain;
          if (!a)
            throw new Error("Invalid initializion order, runtimeChain is not available");
          return s.metadata = i, s.runtimeVersion = t, this._initRegistry(this.registry, a, t, i), this._injectMetadata(s, !0), !0;
        }))
      );
    })).subscribe());
  }
  async _metaFromChain(t) {
    const [r, i, s, a, o, c] = await Promise.all([
      tn(this._rpcCore.chain.getBlockHash(0)),
      tn(this._rpcCore.state.getRuntimeVersion()),
      tn(this._rpcCore.system.chain()),
      tn(this._rpcCore.system.properties()),
      tn(this._rpcCore.rpc.methods()),
      t ? Promise.resolve(null) : tn(this._rpcCore.state.getMetadata())
    ]);
    this._runtimeChain = s, this._runtimeVersion = i, this._rx.runtimeVersion = i;
    const l = `${r.toHex() || "0x"}-${i.specVersion.toString()}`, u = c || (t != null && t[l] ? new eo(this.registry, t[l]) : await tn(this._rpcCore.state.getMetadata()));
    return this._initRegistry(this.registry, s, i, u, a), this._filterRpc(o.methods.map(nR), Mp(this.registry, s, i.specName)), this._subscribeUpdates(), this.__internal__registries.length || this.__internal__registries.push({ counter: 0, isDefault: !0, metadata: u, registry: this.registry, runtimeVersion: i }), u.getUniqTypes(this._options.throwOnUnknown || !1), [r, u];
  }
  _initFromMeta(t) {
    const r = this._runtimeVersion;
    if (!r)
      throw new Error("Invalid initializion order, runtimeVersion is not available");
    return this._extrinsicType = t.asLatest.extrinsic.version.toNumber(), this._rx.extrinsicType = this._extrinsicType, this._rx.genesisHash = this._genesisHash, this._rx.runtimeVersion = r, this._injectMetadata(this._getDefaultRegistry(), !0), this._rx.derive = this._decorateDeriveRx(this._rxDecorateMethod), this._derive = this._decorateDerive(this._decorateMethod), !0;
  }
  _subscribeHealth() {
    this._unsubscribeHealth(), this.__internal__healthTimer = this.hasSubscriptions ? setInterval(() => {
      tn(this._rpcCore.system.health.raw()).catch(Kn);
    }, tR) : null;
  }
  _unsubscribeHealth() {
    this.__internal__healthTimer && (clearInterval(this.__internal__healthTimer), this.__internal__healthTimer = null);
  }
  _unsubscribeUpdates() {
    this.__internal__updateSub && (this.__internal__updateSub.unsubscribe(), this.__internal__updateSub = null);
  }
  _unsubscribe() {
    this._unsubscribeHealth(), this._unsubscribeUpdates();
  }
  async __internal__onProviderConnect() {
    this._isConnected.next(!0), this.emit("connected");
    try {
      const t = this._options.initWasm === !1 ? !0 : await LE(), r = await this._loadMeta();
      this._subscribeHealth(), r && !this._isReady && t && (this._isReady = !0, this.emit("ready", this));
    } catch (t) {
      const r = new Error(`FATAL: Unable to initialize the API: ${t.message}`);
      qc.error(r), this.emit("error", r);
    }
  }
  __internal__onProviderDisconnect() {
    this._isConnected.next(!1), this._unsubscribe(), this.emit("disconnected");
  }
  __internal__onProviderError(t) {
    this.emit("error", t);
  }
}
function en(n) {
  if (n === void 0)
    throw new Error("Api interfaces needs to be initialized before using, wait for 'isReady'");
  return n;
}
class iR extends rR {
  /**
   * @description Runtime call interfaces (currently untyped, only decorated via API options)
   */
  get call() {
    return en(this._call);
  }
  /**
   * @description Contains the parameter types (constants) of all modules.
   *
   * The values are instances of the appropriate type and are accessible using `section`.`constantName`,
   *
   * @example
   * <BR>
   *
   * ```javascript
   * console.log(api.consts.democracy.enactmentPeriod.toString())
   * ```
   */
  get consts() {
    return en(this._consts);
  }
  /**
   * @description Derived results that are injected into the API, allowing for combinations of various query results.
   *
   * @example
   * <BR>
   *
   * ```javascript
   * api.derive.chain.bestNumber((number) => {
   *   console.log('best number', number);
   * });
   * ```
   */
  get derive() {
    return en(this._derive);
  }
  /**
   * @description Errors from metadata
   */
  get errors() {
    return en(this._errors);
  }
  /**
   * @description Events from metadata
   */
  get events() {
    return en(this._events);
  }
  /**
   * @description  Returns the version of extrinsics in-use on this chain
   */
  get extrinsicVersion() {
    return this._extrinsicType;
  }
  /**
   * @description Contains the genesis Hash of the attached chain. Apart from being useful to determine the actual chain, it can also be used to sign immortal transactions.
   */
  get genesisHash() {
    return en(this._genesisHash);
  }
  /**
   * @description true is the underlying provider is connected
   */
  get isConnected() {
    return this._isConnected.getValue();
  }
  /**
   * @description The library information name & version (from package.json)
   */
  get libraryInfo() {
    return `${vh.name} v${vh.version}`;
  }
  /**
   * @description Contains all the chain state modules and their subsequent methods in the API. These are attached dynamically from the runtime metadata.
   *
   * All calls inside the namespace, is denoted by `section`.`method` and may take an optional query parameter. As an example, `api.query.timestamp.now()` (current block timestamp) does not take parameters, while `api.query.system.account(<accountId>)` (retrieving the associated nonce & balances for an account), takes the `AccountId` as a parameter.
   *
   * @example
   * <BR>
   *
   * ```javascript
   * api.query.system.account(<accountId>, ([nonce, balance]) => {
   *   console.log('new free balance', balance.free, 'new nonce', nonce);
   * });
   * ```
   */
  get query() {
    return en(this._query);
  }
  /**
   * @description Allows for the querying of multiple storage entries and the combination thereof into a single result. This is a very optimal way to make multiple queries since it only makes a single connection to the node and retrieves the data over one subscription.
   *
   * @example
   * <BR>
   *
   * ```javascript
   * const unsub = await api.queryMulti(
   *   [
   *     // you can include the storage without any parameters
   *     api.query.balances.totalIssuance,
   *     // or you can pass parameters to the storage query
   *     [api.query.system.account, '5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY']
   *   ],
   *   ([existential, [, { free }]]) => {
   *     console.log(`You have ${free.sub(existential)} more than the existential deposit`);
   *
   *     unsub();
   *   }
   * );
   * ```
   */
  get queryMulti() {
    return en(this._queryMulti);
  }
  /**
   * @description Contains all the raw rpc sections and their subsequent methods in the API as defined by the jsonrpc interface definitions. Unlike the dynamic `api.query` and `api.tx` sections, these methods are fixed (although extensible with node upgrades) and not determined by the runtime.
   *
   * RPC endpoints available here allow for the query of chain, node and system information, in addition to providing interfaces for the raw queries of state (using known keys) and the submission of transactions.
   *
   * @example
   * <BR>
   *
   * ```javascript
   * api.rpc.chain.subscribeNewHeads((header) => {
   *   console.log('new header', header);
   * });
   * ```
   */
  get rpc() {
    return en(this._rpc);
  }
  /**
   * @description Contains the chain information for the current node.
   */
  get runtimeChain() {
    return en(this._runtimeChain);
  }
  /**
   * @description Yields the current attached runtime metadata. Generally this is only used to construct extrinsics & storage, but is useful for current runtime inspection.
   */
  get runtimeMetadata() {
    return en(this._runtimeMetadata);
  }
  /**
   * @description Contains the version information for the current runtime.
   */
  get runtimeVersion() {
    return en(this._runtimeVersion);
  }
  /**
   * @description The underlying Rx API interface
   */
  get rx() {
    return en(this._rx);
  }
  /**
   * @description Returns the underlying provider stats
   */
  get stats() {
    return this._rpcCore.stats;
  }
  /**
   * @description The type of this API instance, either 'rxjs' or 'promise'
   */
  get type() {
    return this._type;
  }
  /**
   * @description Contains all the extrinsic modules and their subsequent methods in the API. It allows for the construction of transactions and the submission thereof. These are attached dynamically from the runtime metadata.
   *
   * @example
   * <BR>
   *
   * ```javascript
   * api.tx.balances
   *   .transferAllowDeath(<recipientId>, <balance>)
   *   .signAndSend(<keyPair>, ({status}) => {
   *     console.log('tx status', status.asFinalized.toHex());
   *   });
   * ```
   */
  get tx() {
    return en(this._extrinsics);
  }
  /**
   * @description Finds the definition for a specific [[CallFunction]] based on the index supplied
   */
  findCall(e) {
    return S0(this.registry, e);
  }
  /**
   * @description Finds the definition for a specific [[RegistryError]] based on the index supplied
   */
  findError(e) {
    return E0(this.registry, e);
  }
}
class sR extends iR {
  /**
   * @description Create an instance of the class
   *
   * @param options Options object to create API instance or a Provider instance
   *
   * @example
   * <BR>
   *
   * ```javascript
   * import Api from '@polkadot/api/promise';
   *
   * const api = new Api().isReady();
   *
   * api.rpc.subscribeNewHeads((header) => {
   *   console.log(`new block #${header.number.toNumber()}`);
   * });
   * ```
   */
  constructor(e = {}, t, r) {
    super(e, t, r);
  }
  /**
   * @description Connect from the underlying provider, halting all network traffic
   */
  connect() {
    return this._rpcCore.connect();
  }
  /**
   * @description Disconnect from the underlying provider, halting all network traffic
   */
  disconnect() {
    return this._unsubscribe(), this._rpcCore.disconnect();
  }
  /**
   * @description Set an external signer which will be used to sign extrinsic when account passed in is not KeyringPair
   */
  setSigner(e) {
    this._rx.signer = e;
  }
  /**
   * @description Signs a raw signer payload, string or Uint8Array
   */
  async sign(e, t, { signer: r } = {}) {
    if (Pe(e)) {
      const i = r || this._rx.signer;
      if (!(i != null && i.signRaw))
        throw new Error("No signer exists with a signRaw interface. You possibly need to pass through an explicit keypair for the origin so it can be used for signing.");
      return (await i.signRaw(J({ type: "bytes" }, t, { address: e }))).signature;
    }
    return pe(e.sign(j(t.data)));
  }
}
class aR {
  constructor(e, t) {
    b(this, "__internal__allHasFired", !1);
    b(this, "__internal__callback");
    b(this, "__internal__fired", []);
    b(this, "__internal__fns", []);
    b(this, "__internal__isActive", !0);
    b(this, "__internal__results", []);
    b(this, "__internal__subscriptions", []);
    this.__internal__callback = t, this.__internal__subscriptions = e.map(async (r, i) => {
      const [s, ...a] = Array.isArray(r) ? r : [r];
      return this.__internal__fired.push(!1), this.__internal__fns.push(s), s(...a, this._createCallback(i));
    });
  }
  _allHasFired() {
    return this.__internal__allHasFired || (this.__internal__allHasFired = this.__internal__fired.filter((e) => !e).length === 0), this.__internal__allHasFired;
  }
  _createCallback(e) {
    return (t) => {
      this.__internal__fired[e] = !0, this.__internal__results[e] = t, this._triggerUpdate();
    };
  }
  _triggerUpdate() {
    if (!(!this.__internal__isActive || !ue(this.__internal__callback) || !this._allHasFired()))
      try {
        Promise.resolve(this.__internal__callback(this.__internal__results)).catch(Kn);
      } catch {
      }
  }
  unsubscribe() {
    this.__internal__isActive && (this.__internal__isActive = !1, this.__internal__subscriptions.map(async (e) => {
      try {
        const t = await e;
        ue(t) && t();
      } catch {
      }
    }));
  }
}
function xd(n, e) {
  let t = !1;
  return {
    reject: (r) => (t || (t = !0, e(r)), R0),
    resolve: (r) => {
      t || (t = !0, n(r));
    }
  };
}
function oR(n, e) {
  const t = n.slice(), r = n.length && ue(n[n.length - 1]) ? t.pop() : void 0;
  if (e && !ue(r))
    throw new Error("Expected a callback to be passed with subscriptions");
  return [t, r];
}
function cR(n, e) {
  return new Promise((t, r) => {
    const i = xd(t, r), s = n(...e).pipe(oi((a) => i.reject(a))).subscribe((a) => {
      i.resolve(a), ws(() => s.unsubscribe());
    });
  });
}
function lR(n, e, t) {
  return new Promise((r, i) => {
    const s = xd(r, i), a = n(...e).pipe(oi((o) => s.reject(o)), Ps(() => s.resolve(() => a.unsubscribe()))).subscribe((o) => {
      ws(() => t(o));
    });
  });
}
function tv(n, e) {
  const t = !!(e != null && e.methodName && e.methodName.includes("subscribe"));
  return function(...r) {
    const [i, s] = oR(r, t);
    return s ? lR(n, i, s) : cR((e == null ? void 0 : e.overrideNoSub) || n, i);
  };
}
class Is extends sR {
  /**
   * @description Creates an instance of the ApiPromise class
   * @param options Options to create an instance. This can be either [[ApiOptions]] or
   * an [[WsProvider]].
   * @example
   * <BR>
   *
   * ```javascript
   * import Api from '@polkadot/api/promise';
   *
   * new Api().isReady.then((api) => {
   *   api.rpc.subscribeNewHeads((header) => {
   *     console.log(`new block #${header.number.toNumber()}`);
   *   });
   * });
   * ```
   */
  constructor(t) {
    super(t, "promise", tv);
    b(this, "__internal__isReadyPromise");
    b(this, "__internal__isReadyOrErrorPromise");
    this.__internal__isReadyPromise = new Promise((r) => {
      super.once("ready", () => r(this));
    }), this.__internal__isReadyOrErrorPromise = new Promise((r, i) => {
      const s = xd(r, i);
      super.once("ready", () => s.resolve(this)), super.once("error", (a) => s.reject(a));
    });
  }
  /**
   * @description Creates an ApiPromise instance using the supplied provider. Returns an Promise containing the actual Api instance.
   * @param options options that is passed to the class contructor. Can be either [[ApiOptions]] or a
   * provider (see the constructor arguments)
   * @example
   * <BR>
   *
   * ```javascript
   * import Api from '@polkadot/api/promise';
   *
   * Api.create().then(async (api) => {
   *   const timestamp = await api.query.timestamp.now();
   *
   *   console.log(`lastest block timestamp ${timestamp}`);
   * });
   * ```
   */
  static create(t) {
    const r = new Is(t);
    return t && t.throwOnConnect ? r.isReadyOrError : (r.isReadyOrError.catch(Kn), r.isReady);
  }
  /**
   * @description Promise that resolves the first time we are connected and loaded
   */
  get isReady() {
    return this.__internal__isReadyPromise;
  }
  /**
   * @description Promise that resolves if we can connect, or reject if there is an error
   */
  get isReadyOrError() {
    return this.__internal__isReadyOrErrorPromise;
  }
  /**
   * @description Returns a clone of this ApiPromise instance (new underlying provider connection)
   */
  clone() {
    return new Is(J({}, this._options, { source: this }));
  }
  /**
   * @description Creates a combinator that can be used to combine the latest results from multiple subscriptions
   * @param fns An array of function to combine, each in the form of `(cb: (value: void)) => void`
   * @param callback A callback that will return an Array of all the values this combinator has been applied to
   * @example
   * <BR>
   *
   * ```javascript
   * const address = '5DTestUPts3kjeXSTMyerHihn1uwMfLj8vU8sqF7qYrFacT7';
   *
   * // combines values from balance & nonce as it updates
   * api.combineLatest([
   *   api.rpc.chain.subscribeNewHeads,
   *   (cb) => api.query.system.account(address, cb)
   * ], ([head, [balance, nonce]]) => {
   *   console.log(`#${head.number}: You have ${balance.free} units, with ${nonce} transactions sent`);
   * });
   * ```
   */
  // eslint-disable-next-line @typescript-eslint/require-await
  async combineLatest(t, r) {
    const i = new aR(t, r);
    return () => {
      i.unsubscribe();
    };
  }
}
const vi = new Uint8Array([161, 35, 3, 33, 0]), ro = new Uint8Array([48, 83, 2, 1, 1, 48, 5, 6, 3, 43, 101, 112, 4, 34, 4, 32]), uR = 32, tm = 64, dR = 32, as = ro.length;
function fR(n, e, t) {
  const r = Array.isArray(t) || t === void 0 ? t : [t], i = CA(e, n, r), s = i.subarray(0, ro.length);
  if (!jt(s, ro))
    throw new Error("Invalid Pkcs8 header found in body");
  let a = i.subarray(as, as + tm), o = as + tm, c = i.subarray(o, o + vi.length);
  if (!jt(c, vi) && (o = as + dR, a = i.subarray(as, o), c = i.subarray(o, o + vi.length), !jt(c, vi)))
    throw new Error("Invalid Pkcs8 divider found in body");
  const l = o + vi.length;
  return {
    publicKey: i.subarray(l, l + uR),
    secretKey: a
  };
}
function hR({ publicKey: n, secretKey: e }, t) {
  if (!e)
    throw new Error("Expected a valid secretKey to be passed to encode");
  const r = Me(ro, e, vi, n);
  if (!t)
    return r;
  const { params: i, password: s, salt: a } = y0(t), { encrypted: o, nonce: c } = gA(r, s.subarray(0, 32));
  return Me(wA(a, i), c, o);
}
function pR(n, { address: e, meta: t }, r, i) {
  return J(AA(r, ["pkcs8", n], i), {
    address: e,
    meta: t
  });
}
const mR = new Uint8Array(), gR = {
  ecdsa: Hi,
  ed25519: Wu,
  ethereum: Hi,
  sr25519: Ky
}, nm = {
  ecdsa: new Uint8Array([2]),
  ed25519: new Uint8Array([0]),
  ethereum: new Uint8Array([2]),
  sr25519: new Uint8Array([1])
}, rm = {
  ecdsa: (n, e) => ch(n, e, "blake2"),
  ed25519: d3,
  ethereum: (n, e) => ch(n, e, "keccak"),
  sr25519: v3
}, fa = {
  ecdsa: (n) => n.length > 32 ? hn(n) : n,
  ed25519: (n) => n,
  ethereum: (n) => n.length === 20 ? n : zs(Xu(n)),
  sr25519: (n) => n
};
function os(n) {
  return !n || fu(n);
}
function im(n, e, t) {
  return hn(Me(e || "", t || "", n));
}
function bi({ toSS58: n, type: e }, { publicKey: t, secretKey: r }, i = {}, s = null, a) {
  const o = (u, f) => {
    const m = fR(u, f || s, a);
    if (m.secretKey.length === 64)
      t = m.publicKey, r = m.secretKey;
    else {
      const y = gR[e](m.secretKey);
      t = y.publicKey, r = y.secretKey;
    }
  }, c = (u) => (os(r) && s && o(u, s), s = hR({ publicKey: t, secretKey: r }, u), a = void 0, s), l = () => {
    const u = fa[e](t);
    return e === "ethereum" ? Gu(u) : n(u);
  };
  return {
    get address() {
      return l();
    },
    get addressRaw() {
      const u = fa[e](t);
      return e === "ethereum" ? u.slice(-20) : u;
    },
    get isLocked() {
      return os(r);
    },
    get meta() {
      return i;
    },
    get publicKey() {
      return t;
    },
    get type() {
      return e;
    },
    // eslint-disable-next-line sort-keys
    decodePkcs8: o,
    derive: (u, f) => {
      if (e === "ethereum")
        throw new Error("Unable to derive on this keypair");
      if (os(r))
        throw new Error("Cannot derive on a locked keypair");
      const { path: m } = Iy(u), y = Jy({ publicKey: t, secretKey: r }, m, e);
      return bi({ toSS58: n, type: e }, y, f, null);
    },
    encodePkcs8: (u) => c(u),
    lock: () => {
      r = new Uint8Array();
    },
    setMeta: (u) => {
      i = J({}, i, u);
    },
    sign: (u, f = {}) => {
      if (os(r))
        throw new Error("Cannot sign with a locked key pair");
      return Me(f.withType ? nm[e] : mR, rm[e](j(u), { publicKey: t, secretKey: r }));
    },
    toJson: (u) => {
      const f = ["ecdsa", "ethereum"].includes(e) ? t.length === 20 ? pe(t) : pe(n0(t)) : l();
      return pR(e, { address: f, meta: i }, c(u), !!u);
    },
    unlock: (u) => o(u),
    verify: (u, f, m) => ph(u, f, fa[e](j(m))).isValid,
    vrfSign: (u, f, m) => {
      if (os(r))
        throw new Error("Cannot sign with a locked key pair");
      if (e === "sr25519")
        return b3(u, { secretKey: r }, f, m);
      const y = rm[e](j(u), { publicKey: t, secretKey: r });
      return Me(im(y, f, m), y);
    },
    vrfVerify: (u, f, m, y, _) => e === "sr25519" ? w3(u, f, t, y, _) : ph(u, Me(nm[e], f.subarray(32)), fa[e](j(m))).isValid && jt(f.subarray(0, 32), im(f.subarray(32), y, _))
  };
}
const yR = "bottom drive obey lake curtain smoke basket hold race lonely fit walk";
class _R {
  constructor() {
    b(this, "__internal__map", {});
  }
  add(e) {
    return this.__internal__map[rn(e.address).toString()] = e, e;
  }
  all() {
    return Object.values(this.__internal__map);
  }
  get(e) {
    const t = this.__internal__map[rn(e).toString()];
    if (!t)
      throw new Error(`Unable to retrieve keypair '${te(e) || ye(e) ? pe(j(e)) : e}'`);
    return t;
  }
  remove(e) {
    delete this.__internal__map[rn(e).toString()];
  }
}
const zc = {
  ecdsa: (n) => Hi(n),
  ed25519: (n) => Wu(n),
  ethereum: (n) => Hi(n),
  sr25519: (n) => Ky(n)
};
function vR({ publicKey: n }) {
  return n;
}
class io {
  constructor(e = {}) {
    b(this, "__internal__pairs");
    b(this, "__internal__type");
    b(this, "__internal__ss58");
    b(this, "decodeAddress", rn);
    /**
     * @name encodeAddress
     * @description Encodes the input into an ss58 representation
     */
    b(this, "encodeAddress", (e, t) => this.type === "ethereum" ? Gu(e) : bo(e, t ?? this.__internal__ss58));
    if (e.type = e.type || "ed25519", !["ecdsa", "ethereum", "ed25519", "sr25519"].includes(e.type || "undefined"))
      throw new Error(`Expected a keyring type of either 'ed25519', 'sr25519', 'ethereum' or 'ecdsa', found '${e.type || "unknown"}`);
    this.__internal__pairs = new _R(), this.__internal__ss58 = e.ss58Format, this.__internal__type = e.type;
  }
  /**
   * @description retrieve the pairs (alias for getPairs)
   */
  get pairs() {
    return this.getPairs();
  }
  /**
   * @description retrieve the publicKeys (alias for getPublicKeys)
   */
  get publicKeys() {
    return this.getPublicKeys();
  }
  /**
   * @description Returns the type of the keyring, ed25519, sr25519 or ecdsa
   */
  get type() {
    return this.__internal__type;
  }
  /**
   * @name addPair
   * @summary Stores an account, given a keyring pair, as a Key/Value (public key, pair) in Keyring Pair Dictionary
   */
  addPair(e) {
    return this.__internal__pairs.add(e);
  }
  /**
   * @name addFromAddress
   * @summary Stores an account, given an account address, as a Key/Value (public key, pair) in Keyring Pair Dictionary
   * @description Allows user to explicitly provide separate inputs including account address or public key, and optionally
   * the associated account metadata, and the default encoded value as arguments (that may be obtained from the json file
   * of an account backup), and then generates a keyring pair from them that it passes to
   * `addPair` to stores in a keyring pair dictionary the public key of the generated pair as a key and the pair as the associated value.
   */
  addFromAddress(e, t = {}, r = null, i = this.type, s, a) {
    const o = this.decodeAddress(e, s);
    return this.addPair(bi({ toSS58: this.encodeAddress, type: i }, { publicKey: o, secretKey: new Uint8Array() }, t, r, a));
  }
  /**
   * @name addFromJson
   * @summary Stores an account, given JSON data, as a Key/Value (public key, pair) in Keyring Pair Dictionary
   * @description Allows user to provide a json object argument that contains account information (that may be obtained from the json file
   * of an account backup), and then generates a keyring pair from it that it passes to
   * `addPair` to stores in a keyring pair dictionary the public key of the generated pair as a key and the pair as the associated value.
   */
  addFromJson(e, t) {
    return this.addPair(this.createFromJson(e, t));
  }
  /**
   * @name addFromMnemonic
   * @summary Stores an account, given a mnemonic, as a Key/Value (public key, pair) in Keyring Pair Dictionary
   * @description Allows user to provide a mnemonic (seed phrase that is provided when account is originally created)
   * argument and a metadata argument that contains account information (that may be obtained from the json file
   * of an account backup), and then generates a keyring pair from it that it passes to
   * `addPair` to stores in a keyring pair dictionary the public key of the generated pair as a key and the pair as the associated value.
   */
  addFromMnemonic(e, t = {}, r = this.type) {
    return this.addFromUri(e, t, r);
  }
  /**
   * @name addFromPair
   * @summary Stores an account created from an explicit publicKey/secreteKey combination
   */
  addFromPair(e, t = {}, r = this.type) {
    return this.addPair(this.createFromPair(e, t, r));
  }
  /**
   * @name addFromSeed
   * @summary Stores an account, given seed data, as a Key/Value (public key, pair) in Keyring Pair Dictionary
   * @description Stores in a keyring pair dictionary the public key of the pair as a key and the pair as the associated value.
   * Allows user to provide the account seed as an argument, and then generates a keyring pair from it that it passes to
   * `addPair` to store in a keyring pair dictionary the public key of the generated pair as a key and the pair as the associated value.
   */
  addFromSeed(e, t = {}, r = this.type) {
    return this.addPair(bi({ toSS58: this.encodeAddress, type: r }, zc[r](e), t, null));
  }
  /**
   * @name addFromUri
   * @summary Creates an account via an suri
   * @description Extracts the phrase, path and password from a SURI format for specifying secret keys `<secret>/<soft-key>//<hard-key>///<password>` (the `///password` may be omitted, and `/<soft-key>` and `//<hard-key>` maybe repeated and mixed). The secret can be a hex string, mnemonic phrase or a string (to be padded)
   */
  addFromUri(e, t = {}, r = this.type) {
    return this.addPair(this.createFromUri(e, t, r));
  }
  /**
   * @name createFromJson
   * @description Creates a pair from a JSON keyfile
   */
  createFromJson({ address: e, encoded: t, encoding: { content: r, type: i, version: s }, meta: a }, o) {
    if (s === "3" && r[0] !== "pkcs8")
      throw new Error(`Unable to decode non-pkcs8 type, [${r.join(",")}] found}`);
    const c = s === "0" || !Array.isArray(r) ? this.type : r[1], l = Array.isArray(i) ? i : [i];
    if (!["ed25519", "sr25519", "ecdsa", "ethereum"].includes(c))
      throw new Error(`Unknown crypto type ${c}`);
    const u = ye(e) ? Mt(e) : this.decodeAddress(e, o), f = ye(t) ? Mt(t) : O3(t);
    return bi({ toSS58: this.encodeAddress, type: c }, { publicKey: u, secretKey: new Uint8Array() }, a, f, l);
  }
  /**
   * @name createFromPair
   * @summary Creates a pair from an explicit publicKey/secreteKey combination
   */
  createFromPair(e, t = {}, r = this.type) {
    return bi({ toSS58: this.encodeAddress, type: r }, e, t, null);
  }
  /**
   * @name createFromUri
   * @summary Creates a Keypair from an suri
   * @description This creates a pair from the suri, but does not add it to the keyring
   */
  createFromUri(e, t = {}, r = this.type) {
    const i = e.startsWith("//") ? `${yR}${e}` : e, { derivePath: s, password: a, path: o, phrase: c } = cC(i);
    let l;
    const u = ye(c, 256);
    if (u)
      l = Mt(c);
    else {
      const m = c.split(" ");
      if ([12, 15, 18, 21, 24].includes(m.length))
        l = r === "ethereum" ? rA(c, "", !1, 64) : iA(c, a);
      else {
        if (c.length > 32)
          throw new Error("specified phrase is not a valid mnemonic and is invalid as a raw seed at > 32 bytes");
        l = Ze(c.padEnd(32));
      }
    }
    const f = r === "ethereum" ? u ? zc[r](l) : Z3(l, s.substring(1)) : Jy(zc[r](l), o, r);
    return bi({ toSS58: this.encodeAddress, type: r }, f, t, null);
  }
  /**
   * @name getPair
   * @summary Retrieves an account keyring pair from the Keyring Pair Dictionary, given an account address
   * @description Returns a keyring pair value from the keyring pair dictionary by performing
   * a key lookup using the provided account address or public key (after decoding it).
   */
  getPair(e) {
    return this.__internal__pairs.get(e);
  }
  /**
   * @name getPairs
   * @summary Retrieves all account keyring pairs from the Keyring Pair Dictionary
   * @description Returns an array list of all the keyring pair values that are stored in the keyring pair dictionary.
   */
  getPairs() {
    return this.__internal__pairs.all();
  }
  /**
   * @name getPublicKeys
   * @summary Retrieves Public Keys of all Keyring Pairs stored in the Keyring Pair Dictionary
   * @description Returns an array list of all the public keys associated with each of the keyring pair values that are stored in the keyring pair dictionary.
   */
  getPublicKeys() {
    return this.__internal__pairs.all().map(vR);
  }
  /**
   * @name removePair
   * @description Deletes the provided input address or public key from the stored Keyring Pair Dictionary.
   */
  removePair(e) {
    this.__internal__pairs.remove(e);
  }
  /**
   * @name setSS58Format;
   * @description Sets the ss58 format for the keyring
   */
  setSS58Format(e) {
    this.__internal__ss58 = e;
  }
  /**
   * @name toJson
   * @summary Returns a JSON object associated with the input argument that contains metadata assocated with an account
   * @description Returns a JSON object containing the metadata associated with an account
   * when valid address or public key and when the account passphrase is provided if the account secret
   * is not already unlocked and available in memory. Note that in [Polkadot-JS Apps](https://github.com/polkadot-js/apps) the user
   * may backup their account to a JSON file that contains this information.
   */
  toJson(e, t) {
    return this.__internal__pairs.get(e).toJson(t);
  }
}
class Xc extends Error {
  constructor(e, t, r) {
    super(`HTTP error! status: ${e} (${t}) for URL: ${r}`), this.status = e, this.statusText = t, this.url = r, this.name = "HttpError";
  }
}
class bR {
  constructor(e, t = "") {
    this.baseURL = e + t;
  }
  async fetch(e, t) {
    try {
      const r = await fetch(this.baseURL + e, t);
      if (!r.ok)
        throw new Xc(r.status, r.statusText, r.url);
      return this.responseHandler(r);
    } catch (r) {
      return this.errorHandler(r);
    }
  }
  async post(e, t, r) {
    const i = { "Content-Type": "application/json", ...(r == null ? void 0 : r.headers) || {} };
    try {
      const s = await fetch(this.baseURL + e, {
        method: "POST",
        body: JSON.stringify(t),
        headers: i,
        ...r
      });
      if (!s.ok)
        throw new Xc(s.status, s.statusText, s.url);
      return this.responseHandler(s);
    } catch (s) {
      return this.errorHandler(s);
    }
  }
  async responseHandler(e) {
    try {
      return await e.json();
    } catch (t) {
      throw console.error("Error parsing JSON:", t), t;
    }
  }
  errorHandler(e) {
    return e instanceof Xc ? console.error("HTTP error:", e) : console.error("API request error:", e), Promise.reject(e);
  }
}
const wR = bR;
class xR extends wR {
  constructor(e, t, r) {
    t.startsWith("http") || (t = `https://${t}`), super(t), this.network = e, this.account = r;
  }
  getCaptchaChallenge(e, t) {
    const { provider: r } = t, { blockNumber: i } = t, s = this.account, a = `${li.GetCaptchaChallenge}/${r.datasetId}/${e}/${s}/${i.toString().replace(/,/g, "")}`;
    return this.fetch(a);
  }
  submitCaptchaSolution(e, t, r, i, s) {
    const a = Mv.parse({
      captchas: e,
      requestHash: t,
      user: r,
      dapp: this.account,
      salt: i,
      signature: s
    });
    return this.post(li.SubmitCaptchaSolution, a);
  }
  verifyDappUser(e, t, r, i) {
    const s = { dapp: e, user: t };
    return r && (s.commitmentId = r), i && (s.maxVerifiedTime = i), this.post(li.VerifyCaptchaSolution, s);
  }
  submitUserEvents(e, t) {
    return this.post(li.SubmitUserEvents, { events: e, accountId: t });
  }
  getProviderStatus() {
    return this.fetch(li.GetProviderStatus);
  }
  getProviderDetails() {
    return this.fetch(li.GetProviderDetails);
  }
}
function SR(n, e, t, r, i) {
  if (n)
    r = n.pairType, i = n.ss58Format;
  else if (!r || !i)
    throw new Kt("GENERAL.NO_PAIR_TYPE_OR_SS58_FORMAT");
  const s = new io({ type: r, ss58Format: i });
  if (!e && t)
    return s.addFromAddress(t);
  if (e) {
    if (Ku(e))
      return s.addFromUri(e);
    if (ye(e))
      return s.addFromSeed(Mt(e));
    if (e.startsWith("//"))
      return s.addFromUri(e);
    try {
      const a = JSON.parse(e), { encoding: { content: o } } = a;
      return new io({ type: o[1], ss58Format: i }).addFromJson(a);
    } catch {
      throw new Kt("GENERAL.NO_MNEMONIC_OR_SEED");
    }
  } else
    throw new Kt("GENERAL.NO_MNEMONIC_OR_SEED");
}
function ER(n, e) {
  return SR(void 0, void 0, e || CR(n).toHex(), Lv.parse("sr25519"), n.registry.chainSS58);
}
function CR(n) {
  return n.registry.createType("AccountId", new Uint8Array(new Array(32).fill(0)));
}
var N = {}, nv = {}, Jt = {}, mr = {}, AR = Ie && Ie.__importDefault || function(n) {
  return n && n.__esModule ? n : { default: n };
};
Object.defineProperty(mr, "__esModule", { value: !0 });
mr.ReturnNumber = mr.ResultBuilder = mr.Result = void 0;
var sm = AR(su), Jl = (
  /** @class */
  function() {
    function n(e, t) {
      this.ok = e, this.err = t;
    }
    return n.prototype.unwrap = function() {
      if (this.ok)
        return this.ok;
      throw this.err;
    }, n.prototype.unwrapRecursively = function() {
      if (this.ok)
        return this.ok instanceof n ? this.ok.unwrapRecursively() : this.ok;
      if (this.err)
        throw this.err;
      return this.ok;
    }, n.prototype.unwrapErr = function() {
      if (this.err)
        return this.err;
    }, n;
  }()
);
mr.Result = Jl;
var PR = (
  /** @class */
  function() {
    function n() {
    }
    return n.Ok = function(e) {
      return new Jl(e, void 0);
    }, n.Err = function(e) {
      return new Jl(void 0, e);
    }, n;
  }()
);
mr.ResultBuilder = PR;
var kR = (
  /** @class */
  function() {
    function n(e) {
      typeof e == "string" ? this.rawNumber = new sm.default(e.substring(2), 16) : this.rawNumber = new sm.default(e);
    }
    return n.prototype.toString = function() {
      return this.rawNumber.toString();
    }, n.prototype.toHuman = function() {
      return this.toString();
    }, n.prototype.toNumber = function() {
      return this.rawNumber.toNumber();
    }, n.ToBN = function(e) {
      return new n(e).rawNumber;
    }, n;
  }()
);
mr.ReturnNumber = kR;
const rv = /* @__PURE__ */ tu(Zb), iv = new Uint8Array();
function Oo(n, e) {
  return e.meta = n, e;
}
function TR(n, e) {
  return Oo(n, (t, ...r) => e(t, r));
}
function NR(n) {
  return (e, t, ...r) => n(e, t, r);
}
function RR(n = Ws()) {
  return n instanceof Xs ? n : n != null && n.length ? wn(j(n)) : iv;
}
function ar(n) {
  const [e, t] = sv(n) ? [n.refTime.toBn(), n.proofSize.toBn()] : [Tt(n), void 0];
  return {
    v1Weight: e,
    v2Weight: { proofSize: t, refTime: e }
  };
}
function sv(n) {
  return !!n.proofSize;
}
const IR = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  EMPTY_SALT: iv,
  convertWeight: ar,
  createBluePrintTx: TR,
  createBluePrintWithId: NR,
  encodeSalt: RR,
  isWeightV2: sv,
  withMeta: Oo
}, Symbol.toStringTag, { value: "Module" })), OR = /* @__PURE__ */ tu(IR);
var Mo = Ie && Ie.__awaiter || function(n, e, t, r) {
  function i(s) {
    return s instanceof t ? s : new t(function(a) {
      a(s);
    });
  }
  return new (t || (t = Promise))(function(s, a) {
    function o(u) {
      try {
        l(r.next(u));
      } catch (f) {
        a(f);
      }
    }
    function c(u) {
      try {
        l(r.throw(u));
      } catch (f) {
        a(f);
      }
    }
    function l(u) {
      u.done ? s(u.value) : i(u.value).then(o, c);
    }
    l((r = r.apply(n, e || [])).next());
  });
}, Lo = Ie && Ie.__generator || function(n, e) {
  var t = { label: 0, sent: function() {
    if (s[0] & 1)
      throw s[1];
    return s[1];
  }, trys: [], ops: [] }, r, i, s, a;
  return a = { next: o(0), throw: o(1), return: o(2) }, typeof Symbol == "function" && (a[Symbol.iterator] = function() {
    return this;
  }), a;
  function o(l) {
    return function(u) {
      return c([l, u]);
    };
  }
  function c(l) {
    if (r)
      throw new TypeError("Generator is already executing.");
    for (; a && (a = 0, l[0] && (t = 0)), t; )
      try {
        if (r = 1, i && (s = l[0] & 2 ? i.return : l[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, l[1])).done)
          return s;
        switch (i = 0, s && (l = [l[0] & 2, s.value]), l[0]) {
          case 0:
          case 1:
            s = l;
            break;
          case 4:
            return t.label++, { value: l[1], done: !1 };
          case 5:
            t.label++, i = l[1], l = [0];
            continue;
          case 7:
            l = t.ops.pop(), t.trys.pop();
            continue;
          default:
            if (s = t.trys, !(s = s.length > 0 && s[s.length - 1]) && (l[0] === 6 || l[0] === 2)) {
              t = 0;
              continue;
            }
            if (l[0] === 3 && (!s || l[1] > s[0] && l[1] < s[3])) {
              t.label = l[1];
              break;
            }
            if (l[0] === 6 && t.label < s[1]) {
              t.label = s[1], s = l;
              break;
            }
            if (s && t.label < s[2]) {
              t.label = s[2], t.ops.push(l);
              break;
            }
            s[2] && t.ops.pop(), t.trys.pop();
            continue;
        }
        l = e.call(n, t);
      } catch (u) {
        l = [6, u], i = 0;
      } finally {
        r = s = 0;
      }
    if (l[0] & 5)
      throw l[1];
    return { value: l[0] ? l[1] : void 0, done: !0 };
  }
}, MR = Ie && Ie.__spreadArray || function(n, e, t) {
  if (t || arguments.length === 2)
    for (var r = 0, i = e.length, s; r < i; r++)
      (s || !(r in e)) && (s || (s = Array.prototype.slice.call(e, 0, r)), s[r] = e[r]);
  return n.concat(s || Array.prototype.slice.call(e));
};
Object.defineProperty(Jt, "__esModule", { value: !0 });
Jt.handleEventReturn = Jt.handleReturnType = Jt.queryOutput = Jt.queryOkJSON = Jt.queryJSON = Jt._genValidGasLimitAndValue = void 0;
var am = mr, hs = rv, LR = su, om = OR, cm = new LR.BN(5e12).isub(hs.BN_ONE);
function DR(n, e, t, r, i, s, a) {
  return a === void 0 && (a = function(o) {
    return o;
  }), Mo(this, void 0, void 0, function() {
    var o, c, l, u, f, m;
    return Lo(this, function(y) {
      switch (y.label) {
        case 0:
          return [4, Sd(n, e, t, r, i, s)];
        case 1:
          if (o = y.sent(), c = o.output, l = o.gasConsumed, u = o.gasRequired, f = c.toJSON(), f && typeof f == "object") {
            if ("err" in f)
              throw m = {
                issue: "READ_ERR_IN_BODY",
                _err: f.err
              }, m;
            "ok" in f && (f = f.ok);
          }
          return [2, {
            value: a(c.toJSON()),
            gasConsumed: l,
            gasRequired: u
          }];
      }
    });
  });
}
Jt.queryJSON = DR;
function UR(n, e, t, r, i, s, a) {
  return a === void 0 && (a = function(o) {
    return o;
  }), Mo(this, void 0, void 0, function() {
    var o, c, l, u, f, m;
    return Lo(this, function(y) {
      switch (y.label) {
        case 0:
          return [4, Sd(n, e, t, r, i, s)];
        case 1:
          if (o = y.sent(), c = o.output, l = o.gasConsumed, u = o.gasRequired, f = c.toJSON(), f == null || typeof f != "object")
            throw m = {
              issue: "BODY_ISNT_OKERR",
              value: f
            }, m;
          return [2, {
            value: a(f),
            gasConsumed: l,
            gasRequired: u
          }];
      }
    });
  });
}
Jt.queryOkJSON = UR;
function Sd(n, e, t, r, i, s) {
  return Mo(this, void 0, void 0, function() {
    var a, o, c, l, u, f, m, y, _, v, C;
    return Lo(this, function(A) {
      switch (A.label) {
        case 0:
          if (e.address.toString(), e.query[r] == null)
            throw a = {
              issue: "METHOD_DOESNT_EXIST",
              texts: ["Method name: '".concat(r, "'")]
            }, a;
          return o = i || [], [4, av(n, s)];
        case 1:
          c = A.sent(), A.label = 2;
        case 2:
          return A.trys.push([2, 4, , 5]), [4, (C = e.query)[r].apply(C, MR([
            t,
            c
          ], o, !1))];
        case 3:
          return l = A.sent(), [3, 5];
        case 4:
          throw f = A.sent(), u = {
            issue: "FAIL_AT_CALL",
            caughtError: f
          }, console.error(`
Contract.queryString(`.concat(r, ") error:"), `
 > error:`, u, `
`), u;
        case 5:
          if (m = l.gasConsumed, y = l.result, _ = l.output, v = l.gasRequired, _ && _.toString(), _ && _.toJSON(), y.isErr && (u = {
            issue: "FAIL_AFTER_CALL::IS_ERROR",
            _resultIsOk: y.isOk,
            _asError: y.isErr ? y.asErr : void 0
          }), y.isOk === !1 && (u = {
            issue: "FAIL_AFTER_CALL::RESULT_NOT_OK",
            _asError: y.isErr ? y.asErr : void 0
          }), u)
            throw u;
          return [2, {
            output: _,
            gasConsumed: m,
            gasRequired: v
          }];
      }
    });
  });
}
Jt.queryOutput = Sd;
function av(n, e) {
  return Mo(this, void 0, void 0, function() {
    var t, r;
    return Lo(this, function(i) {
      return e == null ? [2, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        gasLimit: n.registry.createType("WeightV2", {
          refTime: (0, om.convertWeight)(n.consts.system.blockWeights ? n.consts.system.blockWeights.maxBlock : n.consts.system.maximumBlockWeight).v1Weight.muln(64).div(hs.BN_HUNDRED),
          proofSize: cm
        }),
        value: hs.BN_ZERO
      }] : (t = e.value, r = e.gasLimit, t || (t = hs.BN_ZERO), r == null && (r = n.registry.createType("WeightV2", {
        refTime: (0, om.convertWeight)(n.consts.system.blockWeights ? n.consts.system.blockWeights.maxBlock : n.consts.system.maximumBlockWeight).v1Weight.muln(64).div(hs.BN_HUNDRED),
        proofSize: cm
      })), [2, { value: t, gasLimit: r }]);
    });
  });
}
Jt._genValidGasLimitAndValue = av;
function Si(n, e) {
  return typeof n > "u" || typeof e > "u" || n === null || e == null ? n : e.isResult ? new am.Result(Si(n.ok, e.body.ok), Si(n.err, e.body.err)) : e.name === "ReturnNumber" ? new am.ReturnNumber(n) : typeof n != "object" || typeof e != "object" || e.isPrimitive ? n : e.name === "Array" ? (Object.entries(n).forEach(function(t) {
    var r = t[0], i = t[1];
    n[r] = Si(i, e.body[0]);
  }), n) : (Object.entries(n).forEach(function(t) {
    n[t[0]] = Si(t[1], e.body[t[0]]);
  }), n);
}
Jt.handleReturnType = Si;
function VR(n, e) {
  return typeof n > "u" || Object.entries(n).forEach(function(t) {
    n[t[0]] = Si(t[1], e.body[t[0]]);
  }), n;
}
Jt.handleEventReturn = VR;
var Vr = {}, ov = Ie && Ie.__awaiter || function(n, e, t, r) {
  function i(s) {
    return s instanceof t ? s : new t(function(a) {
      a(s);
    });
  }
  return new (t || (t = Promise))(function(s, a) {
    function o(u) {
      try {
        l(r.next(u));
      } catch (f) {
        a(f);
      }
    }
    function c(u) {
      try {
        l(r.throw(u));
      } catch (f) {
        a(f);
      }
    }
    function l(u) {
      u.done ? s(u.value) : i(u.value).then(o, c);
    }
    l((r = r.apply(n, e || [])).next());
  });
}, cv = Ie && Ie.__generator || function(n, e) {
  var t = { label: 0, sent: function() {
    if (s[0] & 1)
      throw s[1];
    return s[1];
  }, trys: [], ops: [] }, r, i, s, a;
  return a = { next: o(0), throw: o(1), return: o(2) }, typeof Symbol == "function" && (a[Symbol.iterator] = function() {
    return this;
  }), a;
  function o(l) {
    return function(u) {
      return c([l, u]);
    };
  }
  function c(l) {
    if (r)
      throw new TypeError("Generator is already executing.");
    for (; a && (a = 0, l[0] && (t = 0)), t; )
      try {
        if (r = 1, i && (s = l[0] & 2 ? i.return : l[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, l[1])).done)
          return s;
        switch (i = 0, s && (l = [l[0] & 2, s.value]), l[0]) {
          case 0:
          case 1:
            s = l;
            break;
          case 4:
            return t.label++, { value: l[1], done: !1 };
          case 5:
            t.label++, i = l[1], l = [0];
            continue;
          case 7:
            l = t.ops.pop(), t.trys.pop();
            continue;
          default:
            if (s = t.trys, !(s = s.length > 0 && s[s.length - 1]) && (l[0] === 6 || l[0] === 2)) {
              t = 0;
              continue;
            }
            if (l[0] === 3 && (!s || l[1] > s[0] && l[1] < s[3])) {
              t.label = l[1];
              break;
            }
            if (l[0] === 6 && t.label < s[1]) {
              t.label = s[1], s = l;
              break;
            }
            if (s && t.label < s[2]) {
              t.label = s[2], t.ops.push(l);
              break;
            }
            s[2] && t.ops.pop(), t.trys.pop();
            continue;
        }
        l = e.call(n, t);
      } catch (u) {
        l = [6, u], i = 0;
      } finally {
        r = s = 0;
      }
    if (l[0] & 5)
      throw l[1];
    return { value: l[0] ? l[1] : void 0, done: !0 };
  }
}, lv = Ie && Ie.__spreadArray || function(n, e, t) {
  if (t || arguments.length === 2)
    for (var r = 0, i = e.length, s; r < i; r++)
      (s || !(r in e)) && (s || (s = Array.prototype.slice.call(e, 0, r)), s[r] = e[r]);
  return n.concat(s || Array.prototype.slice.call(e));
};
Object.defineProperty(Vr, "__esModule", { value: !0 });
Vr._signAndSend = Vr.buildSubmittableExtrinsic = Vr.txSignAndSend = void 0;
var BR = Jt, HR = rv;
function FR(n, e, t, r, i, s, a) {
  return ov(this, void 0, void 0, function() {
    var o, c, l, u, f, m;
    return cv(this, function(y) {
      switch (y.label) {
        case 0:
          return [4, (0, BR._genValidGasLimitAndValue)(n, a)];
        case 1:
          return o = y.sent(), c = a || { gasLimit: void 0, value: void 0 }, [4, (m = e.query)[r].apply(m, lv([
            t.address,
            o
          ], s, !1))];
        case 2:
          return l = y.sent().gasRequired, u = {
            gasLimit: c.gasLimit || l,
            value: c.value || HR.BN_ZERO
          }, f = uv(n, e, r, s, u), [2, dv(n.registry, f, t, i)];
      }
    });
  });
}
Vr.txSignAndSend = FR;
function uv(n, e, t, r, i) {
  var s;
  if (e.tx[t] == null) {
    var a = {
      issue: "METHOD_DOESNT_EXIST",
      texts: ["Method name: '".concat(t, "'")]
    };
    throw a;
  }
  var o = r || [], c = (s = e.tx)[t].apply(s, lv([i], o, !1));
  return c;
}
Vr.buildSubmittableExtrinsic = uv;
function dv(n, e, t, r) {
  return ov(this, void 0, void 0, function() {
    var i;
    return cv(this, function(s) {
      return i = t.address, [2, new Promise(function(a, o) {
        var c = {
          from: i.toString(),
          txHash: e.hash.toHex()
        };
        e.signAndSend(t, function(l) {
          l.status.isInBlock && (c.blockHash = l.status.asInBlock.toHex()), l.status.isFinalized || l.status.isInBlock ? (c.events = r(l.events), l.events.filter(function(u) {
            var f = u.event.section;
            return f === "system";
          }).forEach(function(u) {
            var f = u.event, m = f.data, y = f.method;
            if (y === "ExtrinsicFailed") {
              var _ = m[0], v = _.type;
              if (_.isModule)
                try {
                  var C = _.asModule, A = n.findMetaError(new Uint8Array([
                    C.index.toNumber(),
                    C.error.toNumber()
                  ]));
                  v = "".concat(A.section, ".").concat(A.name).concat(Array.isArray(A.docs) ? "(".concat(A.docs.join(""), ")") : A.docs || "");
                } catch {
                }
              c.error = {
                message: v
              }, o(c);
            } else
              y === "ExtrinsicSuccess" && (c.result = l, a(c));
          })) : l.isError && (c.error = {
            data: l
          }, c.events = void 0, o(c));
        }).catch(function(l) {
          c.error = {
            message: l.message
          }, o(c);
        });
      })];
    });
  });
}
Vr._signAndSend = dv;
(function(n) {
  var e = Ie && Ie.__createBinding || (Object.create ? function(r, i, s, a) {
    a === void 0 && (a = s);
    var o = Object.getOwnPropertyDescriptor(i, s);
    (!o || ("get" in o ? !i.__esModule : o.writable || o.configurable)) && (o = { enumerable: !0, get: function() {
      return i[s];
    } }), Object.defineProperty(r, a, o);
  } : function(r, i, s, a) {
    a === void 0 && (a = s), r[a] = i[s];
  }), t = Ie && Ie.__exportStar || function(r, i) {
    for (var s in r)
      s !== "default" && !Object.prototype.hasOwnProperty.call(i, s) && e(i, r, s);
  };
  Object.defineProperty(n, "__esModule", { value: !0 }), t(Jt, n), t(Vr, n), t(mr, n);
})(nv);
(function(n) {
  var e = Ie && Ie.__createBinding || (Object.create ? function(r, i, s, a) {
    a === void 0 && (a = s);
    var o = Object.getOwnPropertyDescriptor(i, s);
    (!o || ("get" in o ? !i.__esModule : o.writable || o.configurable)) && (o = { enumerable: !0, get: function() {
      return i[s];
    } }), Object.defineProperty(r, a, o);
  } : function(r, i, s, a) {
    a === void 0 && (a = s), r[a] = i[s];
  }), t = Ie && Ie.__exportStar || function(r, i) {
    for (var s in r)
      s !== "default" && !Object.prototype.hasOwnProperty.call(i, s) && e(i, r, s);
  };
  Object.defineProperty(n, "__esModule", { value: !0 }), t(nv, n);
})(N);
let jR = class {
  constructor(e, t) {
    this.__nativeContract = e, this.__apiPromise = t;
  }
  getGitCommitId(e) {
    return N.buildSubmittableExtrinsic(this.__apiPromise, this.__nativeContract, "getGitCommitId", [], e);
  }
  getAdmin(e) {
    return N.buildSubmittableExtrinsic(this.__apiPromise, this.__nativeContract, "getAdmin", [], e);
  }
  getPayees(e) {
    return N.buildSubmittableExtrinsic(this.__apiPromise, this.__nativeContract, "getPayees", [], e);
  }
  getDappPayees(e) {
    return N.buildSubmittableExtrinsic(this.__apiPromise, this.__nativeContract, "getDappPayees", [], e);
  }
  getStatuses(e) {
    return N.buildSubmittableExtrinsic(this.__apiPromise, this.__nativeContract, "getStatuses", [], e);
  }
  getProviderStakeThreshold(e) {
    return N.buildSubmittableExtrinsic(this.__apiPromise, this.__nativeContract, "getProviderStakeThreshold", [], e);
  }
  getDappStakeThreshold(e) {
    return N.buildSubmittableExtrinsic(this.__apiPromise, this.__nativeContract, "getDappStakeThreshold", [], e);
  }
  getMaxProviderFee(e) {
    return N.buildSubmittableExtrinsic(this.__apiPromise, this.__nativeContract, "getMaxProviderFee", [], e);
  }
  getMinNumActiveProviders(e) {
    return N.buildSubmittableExtrinsic(this.__apiPromise, this.__nativeContract, "getMinNumActiveProviders", [], e);
  }
  getBlockTime(e) {
    return N.buildSubmittableExtrinsic(this.__apiPromise, this.__nativeContract, "getBlockTime", [], e);
  }
  getMaxUserHistoryAgeSeconds(e) {
    return N.buildSubmittableExtrinsic(this.__apiPromise, this.__nativeContract, "getMaxUserHistoryAgeSeconds", [], e);
  }
  getMaxUserHistoryLen(e) {
    return N.buildSubmittableExtrinsic(this.__apiPromise, this.__nativeContract, "getMaxUserHistoryLen", [], e);
  }
  getMaxUserHistoryAgeBlocks(e) {
    return N.buildSubmittableExtrinsic(this.__apiPromise, this.__nativeContract, "getMaxUserHistoryAgeBlocks", [], e);
  }
  providerRegister(e, t, r, i) {
    return N.buildSubmittableExtrinsic(this.__apiPromise, this.__nativeContract, "providerRegister", [e, t, r], i);
  }
  providerUpdate(e, t, r, i) {
    return N.buildSubmittableExtrinsic(this.__apiPromise, this.__nativeContract, "providerUpdate", [e, t, r], i);
  }
  providerDeactivate(e) {
    return N.buildSubmittableExtrinsic(this.__apiPromise, this.__nativeContract, "providerDeactivate", [], e);
  }
  providerDeregister(e) {
    return N.buildSubmittableExtrinsic(this.__apiPromise, this.__nativeContract, "providerDeregister", [], e);
  }
  getProvider(e, t) {
    return N.buildSubmittableExtrinsic(this.__apiPromise, this.__nativeContract, "getProvider", [e], t);
  }
  providerFund(e) {
    return N.buildSubmittableExtrinsic(this.__apiPromise, this.__nativeContract, "providerFund", [], e);
  }
  providerSetDataset(e, t, r) {
    return N.buildSubmittableExtrinsic(this.__apiPromise, this.__nativeContract, "providerSetDataset", [e, t], r);
  }
  getDapp(e, t) {
    return N.buildSubmittableExtrinsic(this.__apiPromise, this.__nativeContract, "getDapp", [e], t);
  }
  dappRegister(e, t, r) {
    return N.buildSubmittableExtrinsic(this.__apiPromise, this.__nativeContract, "dappRegister", [e, t], r);
  }
  dappUpdate(e, t, r, i) {
    return N.buildSubmittableExtrinsic(this.__apiPromise, this.__nativeContract, "dappUpdate", [e, t, r], i);
  }
  dappFund(e, t) {
    return N.buildSubmittableExtrinsic(this.__apiPromise, this.__nativeContract, "dappFund", [e], t);
  }
  dappDeregister(e, t) {
    return N.buildSubmittableExtrinsic(this.__apiPromise, this.__nativeContract, "dappDeregister", [e], t);
  }
  dappDeactivate(e, t) {
    return N.buildSubmittableExtrinsic(this.__apiPromise, this.__nativeContract, "dappDeactivate", [e], t);
  }
  getUserHistorySummary(e, t) {
    return N.buildSubmittableExtrinsic(this.__apiPromise, this.__nativeContract, "getUserHistorySummary", [e], t);
  }
  providerCommit(e, t) {
    return N.buildSubmittableExtrinsic(this.__apiPromise, this.__nativeContract, "providerCommit", [e], t);
  }
  providerCommitMany(e, t) {
    return N.buildSubmittableExtrinsic(this.__apiPromise, this.__nativeContract, "providerCommitMany", [e], t);
  }
  dappOperatorIsHumanUser(e, t, r) {
    return N.buildSubmittableExtrinsic(this.__apiPromise, this.__nativeContract, "dappOperatorIsHumanUser", [e, t], r);
  }
  dappOperatorLastCorrectCaptcha(e, t) {
    return N.buildSubmittableExtrinsic(this.__apiPromise, this.__nativeContract, "dappOperatorLastCorrectCaptcha", [e], t);
  }
  getUser(e, t) {
    return N.buildSubmittableExtrinsic(this.__apiPromise, this.__nativeContract, "getUser", [e], t);
  }
  getCommit(e, t) {
    return N.buildSubmittableExtrinsic(this.__apiPromise, this.__nativeContract, "getCommit", [e], t);
  }
  listProvidersByAccounts(e, t) {
    return N.buildSubmittableExtrinsic(this.__apiPromise, this.__nativeContract, "listProvidersByAccounts", [e], t);
  }
  listProvidersByStatus(e, t) {
    return N.buildSubmittableExtrinsic(this.__apiPromise, this.__nativeContract, "listProvidersByStatus", [e], t);
  }
  getRandomActiveProvider(e, t, r) {
    return N.buildSubmittableExtrinsic(this.__apiPromise, this.__nativeContract, "getRandomActiveProvider", [e, t], r);
  }
  getAllProviderAccounts(e) {
    return N.buildSubmittableExtrinsic(this.__apiPromise, this.__nativeContract, "getAllProviderAccounts", [], e);
  }
  getRandomNumber(e, t, r, i) {
    return N.buildSubmittableExtrinsic(this.__apiPromise, this.__nativeContract, "getRandomNumber", [e, t, r], i);
  }
  terminate(e) {
    return N.buildSubmittableExtrinsic(this.__apiPromise, this.__nativeContract, "terminate", [], e);
  }
  withdraw(e, t) {
    return N.buildSubmittableExtrinsic(this.__apiPromise, this.__nativeContract, "withdraw", [e], t);
  }
  setCodeHash(e, t) {
    return N.buildSubmittableExtrinsic(this.__apiPromise, this.__nativeContract, "setCodeHash", [e], t);
  }
};
const Kl = '{"source":{"hash":"0x47ccf93a15772e2794acf525ebaa5e374d11453a4edb0bbdf9ce229e9b6bdc88","language":"ink! 4.3.0","compiler":"rustc 1.69.0","build_info":{"build_mode":"Debug","cargo_contract_version":"3.0.1","rust_toolchain":"stable-x86_64-unknown-linux-gnu","wasm_opt_settings":{"keep_debug_symbols":false,"optimization_passes":"Z"}}},"contract":{"name":"captcha","version":"0.2.41","authors":["Chris Taylor <chris@prosopo.io>","George Oastler <george@prosopo.io>","Vincenzo Ferrara","Sinia anak"]},"spec":{"constructors":[{"args":[],"default":false,"docs":["Constructor"],"label":"new","payable":true,"returnType":{"displayName":["ink_primitives","ConstructorResult"],"type":10},"selector":"0x9bae9d5e"},{"args":[],"default":false,"docs":[],"label":"new_panic","payable":false,"returnType":{"displayName":["ink_primitives","ConstructorResult"],"type":15},"selector":"0x794560e8"}],"docs":[],"environment":{"accountId":{"displayName":["AccountId"],"type":7},"balance":{"displayName":["Balance"],"type":0},"blockNumber":{"displayName":["BlockNumber"],"type":1},"chainExtension":{"displayName":["ChainExtension"],"type":65},"hash":{"displayName":["Hash"],"type":4},"maxEventTopics":4,"timestamp":{"displayName":["Timestamp"],"type":64}},"events":[],"lang_error":{"displayName":["ink","LangError"],"type":14},"messages":[{"args":[],"default":false,"docs":[" Get the git commit id from when this contract was built"],"label":"get_git_commit_id","mutates":false,"payable":false,"returnType":{"displayName":["ink","MessageResult"],"type":16},"selector":"0x3685e994"},{"args":[],"default":false,"docs":[" the admin which can control this contract. set to author/instantiator by default"],"label":"get_admin","mutates":false,"payable":false,"returnType":{"displayName":["ink","MessageResult"],"type":18},"selector":"0x57b8a8a7"},{"args":[],"default":false,"docs":[" Get all payee options"],"label":"get_payees","mutates":false,"payable":false,"returnType":{"displayName":["ink","MessageResult"],"type":19},"selector":"0xf334a6d7"},{"args":[],"default":false,"docs":[" Get all dapp payee options"],"label":"get_dapp_payees","mutates":false,"payable":false,"returnType":{"displayName":["ink","MessageResult"],"type":22},"selector":"0xcce851af"},{"args":[],"default":false,"docs":[" Get all status options"],"label":"get_statuses","mutates":false,"payable":false,"returnType":{"displayName":["ink","MessageResult"],"type":25},"selector":"0xd39608f0"},{"args":[],"default":false,"docs":[" Get contract provider minimum stake default."],"label":"get_provider_stake_threshold","mutates":false,"payable":false,"returnType":{"displayName":["ink","MessageResult"],"type":28},"selector":"0x3e7e8941"},{"args":[],"default":false,"docs":[" Get contract dapp minimum stake default."],"label":"get_dapp_stake_threshold","mutates":false,"payable":false,"returnType":{"displayName":["ink","MessageResult"],"type":28},"selector":"0xc9834fee"},{"args":[],"default":false,"docs":[" the maximum fee a provider can charge for a commit"],"label":"get_max_provider_fee","mutates":false,"payable":false,"returnType":{"displayName":["ink","MessageResult"],"type":29},"selector":"0xd799cf93"},{"args":[],"default":false,"docs":[" the minimum number of providers needed for the contract to function"],"label":"get_min_num_active_providers","mutates":false,"payable":false,"returnType":{"displayName":["ink","MessageResult"],"type":30},"selector":"0xa200bea1"},{"args":[],"default":false,"docs":[" the time to complete a block, 6 seconds by default"],"label":"get_block_time","mutates":false,"payable":false,"returnType":{"displayName":["ink","MessageResult"],"type":30},"selector":"0x8d3f151d"},{"args":[],"default":false,"docs":[" the max age of a commit for a user before it is removed from the history, in seconds"],"label":"get_max_user_history_age_seconds","mutates":false,"payable":false,"returnType":{"displayName":["ink","MessageResult"],"type":29},"selector":"0xcab4fa0a"},{"args":[],"default":false,"docs":[" the max number of commits stored for a single user"],"label":"get_max_user_history_len","mutates":false,"payable":false,"returnType":{"displayName":["ink","MessageResult"],"type":30},"selector":"0xfb715e71"},{"args":[],"default":false,"docs":[" the max age of a commit for a user before it is removed from the history, in blocks"],"label":"get_max_user_history_age_blocks","mutates":false,"payable":false,"returnType":{"displayName":["ink","MessageResult"],"type":29},"selector":"0x6f3337c3"},{"args":[{"label":"url","type":{"displayName":["Vec"],"type":2}},{"label":"fee","type":{"displayName":["u32"],"type":1}},{"label":"payee","type":{"displayName":["Payee"],"type":21}}],"default":false,"docs":[" Register a provider, their url and fee"],"label":"provider_register","mutates":true,"payable":true,"returnType":{"displayName":["ink","MessageResult"],"type":10},"selector":"0xc66f9a2a"},{"args":[{"label":"url","type":{"displayName":["Vec"],"type":2}},{"label":"fee","type":{"displayName":["u32"],"type":1}},{"label":"payee","type":{"displayName":["Payee"],"type":21}}],"default":false,"docs":[" Update an existing provider, their url, fee and deposit funds"],"label":"provider_update","mutates":true,"payable":true,"returnType":{"displayName":["ink","MessageResult"],"type":10},"selector":"0xd2f70de8"},{"args":[],"default":false,"docs":[" De-activate a provider by setting their status to Deactivated"],"label":"provider_deactivate","mutates":true,"payable":false,"returnType":{"displayName":["ink","MessageResult"],"type":10},"selector":"0xa65232da"},{"args":[],"default":false,"docs":[" Unstake and deactivate the provider\'s service, returning stake"],"label":"provider_deregister","mutates":true,"payable":false,"returnType":{"displayName":["ink","MessageResult"],"type":10},"selector":"0x5eff53cf"},{"args":[{"label":"account","type":{"displayName":["AccountId"],"type":7}}],"default":false,"docs":[" Get an existing provider"],"label":"get_provider","mutates":false,"payable":false,"returnType":{"displayName":["ink","MessageResult"],"type":32},"selector":"0x457c7444"},{"args":[],"default":false,"docs":[" Fund a provider"],"label":"provider_fund","mutates":true,"payable":true,"returnType":{"displayName":["ink","MessageResult"],"type":10},"selector":"0x54ee83bb"},{"args":[{"label":"dataset_id","type":{"displayName":["Hash"],"type":4}},{"label":"dataset_id_content","type":{"displayName":["Hash"],"type":4}}],"default":false,"docs":[" Add a new data set"],"label":"provider_set_dataset","mutates":true,"payable":true,"returnType":{"displayName":["ink","MessageResult"],"type":10},"selector":"0xb0e7ab99"},{"args":[{"label":"contract","type":{"displayName":["AccountId"],"type":7}}],"default":false,"docs":[" Get an existing dapp"],"label":"get_dapp","mutates":false,"payable":false,"returnType":{"displayName":["ink","MessageResult"],"type":35},"selector":"0xf96477c0"},{"args":[{"label":"contract","type":{"displayName":["AccountId"],"type":7}},{"label":"payee","type":{"displayName":["DappPayee"],"type":24}}],"default":false,"docs":[" Register a dapp"],"label":"dapp_register","mutates":true,"payable":true,"returnType":{"displayName":["ink","MessageResult"],"type":10},"selector":"0x42b45efa"},{"args":[{"label":"contract","type":{"displayName":["AccountId"],"type":7}},{"label":"payee","type":{"displayName":["DappPayee"],"type":24}},{"label":"owner","type":{"displayName":["AccountId"],"type":7}}],"default":false,"docs":[" Update a dapp with new funds, setting status as appropriate"],"label":"dapp_update","mutates":true,"payable":true,"returnType":{"displayName":["ink","MessageResult"],"type":10},"selector":"0x5dbfa904"},{"args":[{"label":"contract","type":{"displayName":["AccountId"],"type":7}}],"default":false,"docs":[" Fund dapp account to pay for services, if the Dapp caller is registered in self.dapps"],"label":"dapp_fund","mutates":true,"payable":true,"returnType":{"displayName":["ink","MessageResult"],"type":10},"selector":"0x55da62a9"},{"args":[{"label":"contract","type":{"displayName":["AccountId"],"type":7}}],"default":false,"docs":[" Cancel services as a dapp, returning remaining tokens"],"label":"dapp_deregister","mutates":true,"payable":false,"returnType":{"displayName":["ink","MessageResult"],"type":10},"selector":"0xdc7da4d5"},{"args":[{"label":"contract","type":{"displayName":["AccountId"],"type":7}}],"default":false,"docs":[" Deactivate a dapp, leaving stake intact"],"label":"dapp_deactivate","mutates":true,"payable":false,"returnType":{"displayName":["ink","MessageResult"],"type":10},"selector":"0x94718d6f"},{"args":[{"label":"user_account","type":{"displayName":["AccountId"],"type":7}}],"default":false,"docs":[],"label":"get_user_history_summary","mutates":false,"payable":false,"returnType":{"displayName":["ink","MessageResult"],"type":38},"selector":"0x3be12ad6"},{"args":[{"label":"commit","type":{"displayName":["Commit"],"type":41}}],"default":false,"docs":[" Provider submits a captcha solution commitment"],"label":"provider_commit","mutates":true,"payable":false,"returnType":{"displayName":["ink","MessageResult"],"type":10},"selector":"0x57876316"},{"args":[{"label":"commits","type":{"displayName":["Vec"],"type":44}}],"default":false,"docs":[" Provider submits 0-many captcha solution commitments"],"label":"provider_commit_many","mutates":true,"payable":false,"returnType":{"displayName":["ink","MessageResult"],"type":10},"selector":"0xc8d4b3b2"},{"args":[{"label":"user_account","type":{"displayName":["AccountId"],"type":7}},{"label":"threshold","type":{"displayName":["u8"],"type":3}}],"default":false,"docs":[" Checks if the user is a human (true) as they have a solution rate higher than a % threshold or a bot (false)"," Threshold is decided by the calling user"," Threshold is between 0-200, i.e. 0-100% in 0.5% increments. E.g. 100 = 50%, 200 = 100%, 0 = 0%, 50 = 25%, etc."],"label":"dapp_operator_is_human_user","mutates":false,"payable":false,"returnType":{"displayName":["ink","MessageResult"],"type":45},"selector":"0xbe7b6ef9"},{"args":[{"label":"user_account","type":{"displayName":["AccountId"],"type":7}}],"default":false,"docs":[" Get the last correct captcha for a user"],"label":"dapp_operator_last_correct_captcha","mutates":false,"payable":false,"returnType":{"displayName":["ink","MessageResult"],"type":48},"selector":"0xbe930f18"},{"args":[{"label":"user_account","type":{"displayName":["AccountId"],"type":7}}],"default":false,"docs":[" Get a dapp user",""," Returns an error if the user does not exist"],"label":"get_user","mutates":false,"payable":false,"returnType":{"displayName":["ink","MessageResult"],"type":51},"selector":"0xa4ca534e"},{"args":[{"label":"commit_id","type":{"displayName":["Hash"],"type":4}}],"default":false,"docs":[" Get a solution commitment",""," Returns an error if the commitment does not exist"],"label":"get_commit","mutates":false,"payable":false,"returnType":{"displayName":["ink","MessageResult"],"type":54},"selector":"0x5329f551"},{"args":[{"label":"provider_accounts","type":{"displayName":["Vec"],"type":8}}],"default":false,"docs":[" List providers given an array of account id",""," Returns empty if none were matched"],"label":"list_providers_by_accounts","mutates":false,"payable":false,"returnType":{"displayName":["ink","MessageResult"],"type":56},"selector":"0x52f0d2cb"},{"args":[{"label":"statuses","type":{"displayName":["Vec"],"type":26}}],"default":false,"docs":[" List providers given an array of status",""," Returns empty if none were matched"],"label":"list_providers_by_status","mutates":false,"payable":false,"returnType":{"displayName":["ink","MessageResult"],"type":56},"selector":"0x54b28ab4"},{"args":[{"label":"user_account","type":{"displayName":["AccountId"],"type":7}},{"label":"dapp_contract","type":{"displayName":["AccountId"],"type":7}}],"default":false,"docs":[" Get a random active provider",""," Returns error if no active provider is found"],"label":"get_random_active_provider","mutates":false,"payable":false,"returnType":{"displayName":["ink","MessageResult"],"type":59},"selector":"0x4aee5bad"},{"args":[],"default":false,"docs":[" Get the AccountIds of all Providers ever registered",""," Returns {Vec<AccountId>}"],"label":"get_all_provider_accounts","mutates":false,"payable":false,"returnType":{"displayName":["ink","MessageResult"],"type":62},"selector":"0x5052021f"},{"args":[{"label":"len","type":{"displayName":["u128"],"type":0}},{"label":"user_account","type":{"displayName":["AccountId"],"type":7}},{"label":"dapp_contract","type":{"displayName":["AccountId"],"type":7}}],"default":false,"docs":[" Get a random number from 0 to `len` - 1 inclusive. The user account is added to the seed for additional random entropy."],"label":"get_random_number","mutates":false,"payable":false,"returnType":{"displayName":["ink","MessageResult"],"type":28},"selector":"0x2306aecd"},{"args":[],"default":false,"docs":[" Terminate this contract and return any/all funds in this contract to the destination"],"label":"terminate","mutates":true,"payable":false,"returnType":{"displayName":["ink","MessageResult"],"type":10},"selector":"0x476d839f"},{"args":[{"label":"amount","type":{"displayName":["Balance"],"type":0}}],"default":false,"docs":[" Withdraw some funds from the contract to the specified destination"],"label":"withdraw","mutates":true,"payable":false,"returnType":{"displayName":["ink","MessageResult"],"type":10},"selector":"0x410fcc9d"},{"args":[{"label":"code_hash","type":{"displayName":[],"type":5}}],"default":false,"docs":[" Set the code hash for this contract"],"label":"set_code_hash","mutates":true,"payable":false,"returnType":{"displayName":["ink","MessageResult"],"type":10},"selector":"0x9e5c5758"}]},"storage":{"root":{"layout":{"struct":{"fields":[{"layout":{"root":{"layout":{"struct":{"fields":[{"layout":{"enum":{"dispatchKey":"0x31f906a7","name":"GovernanceStatus","variants":{"0":{"fields":[],"name":"Active"},"1":{"fields":[],"name":"Inactive"}}}},"name":"status"},{"layout":{"leaf":{"key":"0x31f906a7","ty":0}},"name":"balance"},{"layout":{"leaf":{"key":"0x31f906a7","ty":1}},"name":"fee"},{"layout":{"enum":{"dispatchKey":"0x31f906a7","name":"Payee","variants":{"0":{"fields":[],"name":"Provider"},"1":{"fields":[],"name":"Dapp"}}}},"name":"payee"},{"layout":{"leaf":{"key":"0x31f906a7","ty":2}},"name":"url"},{"layout":{"leaf":{"key":"0x31f906a7","ty":4}},"name":"dataset_id"},{"layout":{"leaf":{"key":"0x31f906a7","ty":4}},"name":"dataset_id_content"}],"name":"Provider"}},"root_key":"0x31f906a7"}},"name":"providers"},{"layout":{"root":{"layout":{"leaf":{"key":"0x25c2603c","ty":6}},"root_key":"0x25c2603c"}},"name":"provider_accounts"},{"layout":{"root":{"layout":{"leaf":{"key":"0xd1b08cc7","ty":7}},"root_key":"0xd1b08cc7"}},"name":"urls"},{"layout":{"root":{"layout":{"struct":{"fields":[{"layout":{"enum":{"dispatchKey":"0x14493d1d","name":"GovernanceStatus","variants":{"0":{"fields":[],"name":"Active"},"1":{"fields":[],"name":"Inactive"}}}},"name":"status"},{"layout":{"leaf":{"key":"0x14493d1d","ty":0}},"name":"balance"},{"layout":{"leaf":{"key":"0x14493d1d","ty":7}},"name":"owner"},{"layout":{"enum":{"dispatchKey":"0x14493d1d","name":"DappPayee","variants":{"0":{"fields":[],"name":"Provider"},"1":{"fields":[],"name":"Dapp"},"2":{"fields":[],"name":"Any"}}}},"name":"payee"}],"name":"Dapp"}},"root_key":"0x14493d1d"}},"name":"dapps"},{"layout":{"root":{"layout":{"leaf":{"key":"0x455ca62f","ty":6}},"root_key":"0x455ca62f"}},"name":"dapp_contracts"},{"layout":{"root":{"layout":{"struct":{"fields":[{"layout":{"leaf":{"key":"0x81a766df","ty":4}},"name":"id"},{"layout":{"leaf":{"key":"0x81a766df","ty":7}},"name":"user_account"},{"layout":{"leaf":{"key":"0x81a766df","ty":4}},"name":"dataset_id"},{"layout":{"enum":{"dispatchKey":"0x81a766df","name":"CaptchaStatus","variants":{"0":{"fields":[],"name":"Pending"},"1":{"fields":[],"name":"Approved"},"2":{"fields":[],"name":"Disapproved"}}}},"name":"status"},{"layout":{"leaf":{"key":"0x81a766df","ty":7}},"name":"dapp_contract"},{"layout":{"leaf":{"key":"0x81a766df","ty":7}},"name":"provider_account"},{"layout":{"leaf":{"key":"0x81a766df","ty":1}},"name":"requested_at"},{"layout":{"leaf":{"key":"0x81a766df","ty":1}},"name":"completed_at"},{"layout":{"array":{"layout":{"leaf":{"key":"0x81a766df","ty":3}},"len":64,"offset":"0x81a766df"}},"name":"user_signature"}],"name":"Commit"}},"root_key":"0x81a766df"}},"name":"commits"},{"layout":{"root":{"layout":{"struct":{"fields":[{"layout":{"leaf":{"key":"0x5a3119c3","ty":9}},"name":"history"}],"name":"User"}},"root_key":"0x5a3119c3"}},"name":"users"},{"layout":{"root":{"layout":{"leaf":{"key":"0x43f9649b","ty":6}},"root_key":"0x43f9649b"}},"name":"user_accounts"}],"name":"Captcha"}},"root_key":"0xabcdef01"}},"types":[{"id":0,"type":{"def":{"primitive":"u128"}}},{"id":1,"type":{"def":{"primitive":"u32"}}},{"id":2,"type":{"def":{"sequence":{"type":3}}}},{"id":3,"type":{"def":{"primitive":"u8"}}},{"id":4,"type":{"def":{"composite":{"fields":[{"type":5,"typeName":"[u8; 32]"}]}},"path":["ink_primitives","types","Hash"]}},{"id":5,"type":{"def":{"array":{"len":32,"type":3}}}},{"id":6,"type":{"def":{"composite":{"fields":[{"type":8}]}},"params":[{"name":"T","type":7}],"path":["BTreeSet"]}},{"id":7,"type":{"def":{"composite":{"fields":[{"type":5,"typeName":"[u8; 32]"}]}},"path":["ink_primitives","types","AccountId"]}},{"id":8,"type":{"def":{"sequence":{"type":7}}}},{"id":9,"type":{"def":{"sequence":{"type":4}}}},{"id":10,"type":{"def":{"variant":{"variants":[{"fields":[{"type":11}],"index":0,"name":"Ok"},{"fields":[{"type":14}],"index":1,"name":"Err"}]}},"params":[{"name":"T","type":11},{"name":"E","type":14}],"path":["Result"]}},{"id":11,"type":{"def":{"variant":{"variants":[{"fields":[{"type":12}],"index":0,"name":"Ok"},{"fields":[{"type":13}],"index":1,"name":"Err"}]}},"params":[{"name":"T","type":12},{"name":"E","type":13}],"path":["Result"]}},{"id":12,"type":{"def":{"tuple":[]}}},{"id":13,"type":{"def":{"variant":{"variants":[{"index":0,"name":"NotAuthorised"},{"index":1,"name":"TransferFailed"},{"index":2,"name":"SetCodeHashFailed"},{"index":3,"name":"InvalidDestination"},{"index":4,"name":"UnknownMessage"},{"index":5,"name":"ProviderAccountExists"},{"index":6,"name":"ProviderExists"},{"index":7,"name":"ProviderAccountDoesNotExist"},{"index":8,"name":"ProviderDoesNotExist"},{"index":9,"name":"ProviderInsufficientFunds"},{"index":10,"name":"ProviderInactive"},{"index":11,"name":"ProviderUrlUsed"},{"index":12,"name":"DappExists"},{"index":13,"name":"DappDoesNotExist"},{"index":14,"name":"DappInactive"},{"index":15,"name":"DappInsufficientFunds"},{"index":16,"name":"CaptchaDataDoesNotExist"},{"index":17,"name":"CommitDoesNotExist"},{"index":18,"name":"DappUserDoesNotExist"},{"index":19,"name":"NoActiveProviders"},{"index":20,"name":"DatasetIdSolutionsSame"},{"index":21,"name":"CodeNotFound"},{"index":22,"name":"Unknown"},{"index":23,"name":"InvalidContract"},{"index":24,"name":"InvalidPayee"},{"index":25,"name":"InvalidCaptchaStatus"},{"index":26,"name":"NoCorrectCaptcha"},{"index":27,"name":"NotEnoughActiveProviders"},{"index":28,"name":"ProviderFeeTooHigh"},{"index":29,"name":"CommitAlreadyExists"},{"index":30,"name":"NotAuthor"},{"index":31,"name":"Math"}]}},"path":["common","common","Error"]}},{"id":14,"type":{"def":{"variant":{"variants":[{"index":1,"name":"CouldNotReadInput"}]}},"path":["ink_primitives","LangError"]}},{"id":15,"type":{"def":{"variant":{"variants":[{"fields":[{"type":12}],"index":0,"name":"Ok"},{"fields":[{"type":14}],"index":1,"name":"Err"}]}},"params":[{"name":"T","type":12},{"name":"E","type":14}],"path":["Result"]}},{"id":16,"type":{"def":{"variant":{"variants":[{"fields":[{"type":17}],"index":0,"name":"Ok"},{"fields":[{"type":14}],"index":1,"name":"Err"}]}},"params":[{"name":"T","type":17},{"name":"E","type":14}],"path":["Result"]}},{"id":17,"type":{"def":{"array":{"len":20,"type":3}}}},{"id":18,"type":{"def":{"variant":{"variants":[{"fields":[{"type":7}],"index":0,"name":"Ok"},{"fields":[{"type":14}],"index":1,"name":"Err"}]}},"params":[{"name":"T","type":7},{"name":"E","type":14}],"path":["Result"]}},{"id":19,"type":{"def":{"variant":{"variants":[{"fields":[{"type":20}],"index":0,"name":"Ok"},{"fields":[{"type":14}],"index":1,"name":"Err"}]}},"params":[{"name":"T","type":20},{"name":"E","type":14}],"path":["Result"]}},{"id":20,"type":{"def":{"sequence":{"type":21}}}},{"id":21,"type":{"def":{"variant":{"variants":[{"index":0,"name":"Provider"},{"index":1,"name":"Dapp"}]}},"path":["captcha","captcha","Payee"]}},{"id":22,"type":{"def":{"variant":{"variants":[{"fields":[{"type":23}],"index":0,"name":"Ok"},{"fields":[{"type":14}],"index":1,"name":"Err"}]}},"params":[{"name":"T","type":23},{"name":"E","type":14}],"path":["Result"]}},{"id":23,"type":{"def":{"sequence":{"type":24}}}},{"id":24,"type":{"def":{"variant":{"variants":[{"index":0,"name":"Provider"},{"index":1,"name":"Dapp"},{"index":2,"name":"Any"}]}},"path":["captcha","captcha","DappPayee"]}},{"id":25,"type":{"def":{"variant":{"variants":[{"fields":[{"type":26}],"index":0,"name":"Ok"},{"fields":[{"type":14}],"index":1,"name":"Err"}]}},"params":[{"name":"T","type":26},{"name":"E","type":14}],"path":["Result"]}},{"id":26,"type":{"def":{"sequence":{"type":27}}}},{"id":27,"type":{"def":{"variant":{"variants":[{"index":0,"name":"Active"},{"index":1,"name":"Inactive"}]}},"path":["captcha","captcha","GovernanceStatus"]}},{"id":28,"type":{"def":{"variant":{"variants":[{"fields":[{"type":0}],"index":0,"name":"Ok"},{"fields":[{"type":14}],"index":1,"name":"Err"}]}},"params":[{"name":"T","type":0},{"name":"E","type":14}],"path":["Result"]}},{"id":29,"type":{"def":{"variant":{"variants":[{"fields":[{"type":1}],"index":0,"name":"Ok"},{"fields":[{"type":14}],"index":1,"name":"Err"}]}},"params":[{"name":"T","type":1},{"name":"E","type":14}],"path":["Result"]}},{"id":30,"type":{"def":{"variant":{"variants":[{"fields":[{"type":31}],"index":0,"name":"Ok"},{"fields":[{"type":14}],"index":1,"name":"Err"}]}},"params":[{"name":"T","type":31},{"name":"E","type":14}],"path":["Result"]}},{"id":31,"type":{"def":{"primitive":"u16"}}},{"id":32,"type":{"def":{"variant":{"variants":[{"fields":[{"type":33}],"index":0,"name":"Ok"},{"fields":[{"type":14}],"index":1,"name":"Err"}]}},"params":[{"name":"T","type":33},{"name":"E","type":14}],"path":["Result"]}},{"id":33,"type":{"def":{"variant":{"variants":[{"fields":[{"type":34}],"index":0,"name":"Ok"},{"fields":[{"type":13}],"index":1,"name":"Err"}]}},"params":[{"name":"T","type":34},{"name":"E","type":13}],"path":["Result"]}},{"id":34,"type":{"def":{"composite":{"fields":[{"name":"status","type":27,"typeName":"GovernanceStatus"},{"name":"balance","type":0,"typeName":"Balance"},{"name":"fee","type":1,"typeName":"u32"},{"name":"payee","type":21,"typeName":"Payee"},{"name":"url","type":2,"typeName":"Vec<u8>"},{"name":"dataset_id","type":4,"typeName":"Hash"},{"name":"dataset_id_content","type":4,"typeName":"Hash"}]}},"path":["captcha","captcha","Provider"]}},{"id":35,"type":{"def":{"variant":{"variants":[{"fields":[{"type":36}],"index":0,"name":"Ok"},{"fields":[{"type":14}],"index":1,"name":"Err"}]}},"params":[{"name":"T","type":36},{"name":"E","type":14}],"path":["Result"]}},{"id":36,"type":{"def":{"variant":{"variants":[{"fields":[{"type":37}],"index":0,"name":"Ok"},{"fields":[{"type":13}],"index":1,"name":"Err"}]}},"params":[{"name":"T","type":37},{"name":"E","type":13}],"path":["Result"]}},{"id":37,"type":{"def":{"composite":{"fields":[{"name":"status","type":27,"typeName":"GovernanceStatus"},{"name":"balance","type":0,"typeName":"Balance"},{"name":"owner","type":7,"typeName":"AccountId"},{"name":"payee","type":24,"typeName":"DappPayee"}]}},"path":["captcha","captcha","Dapp"]}},{"id":38,"type":{"def":{"variant":{"variants":[{"fields":[{"type":39}],"index":0,"name":"Ok"},{"fields":[{"type":14}],"index":1,"name":"Err"}]}},"params":[{"name":"T","type":39},{"name":"E","type":14}],"path":["Result"]}},{"id":39,"type":{"def":{"variant":{"variants":[{"fields":[{"type":40}],"index":0,"name":"Ok"},{"fields":[{"type":13}],"index":1,"name":"Err"}]}},"params":[{"name":"T","type":40},{"name":"E","type":13}],"path":["Result"]}},{"id":40,"type":{"def":{"composite":{"fields":[{"name":"correct","type":31,"typeName":"u16"},{"name":"incorrect","type":31,"typeName":"u16"},{"name":"score","type":3,"typeName":"u8"}]}},"path":["captcha","captcha","UserHistorySummary"]}},{"id":41,"type":{"def":{"composite":{"fields":[{"name":"id","type":4,"typeName":"Hash"},{"name":"user_account","type":7,"typeName":"AccountId"},{"name":"dataset_id","type":4,"typeName":"Hash"},{"name":"status","type":42,"typeName":"CaptchaStatus"},{"name":"dapp_contract","type":7,"typeName":"AccountId"},{"name":"provider_account","type":7,"typeName":"AccountId"},{"name":"requested_at","type":1,"typeName":"BlockNumber"},{"name":"completed_at","type":1,"typeName":"BlockNumber"},{"name":"user_signature","type":43,"typeName":"[u8; 64]"}]}},"path":["captcha","captcha","Commit"]}},{"id":42,"type":{"def":{"variant":{"variants":[{"index":0,"name":"Pending"},{"index":1,"name":"Approved"},{"index":2,"name":"Disapproved"}]}},"path":["captcha","captcha","CaptchaStatus"]}},{"id":43,"type":{"def":{"array":{"len":64,"type":3}}}},{"id":44,"type":{"def":{"sequence":{"type":41}}}},{"id":45,"type":{"def":{"variant":{"variants":[{"fields":[{"type":46}],"index":0,"name":"Ok"},{"fields":[{"type":14}],"index":1,"name":"Err"}]}},"params":[{"name":"T","type":46},{"name":"E","type":14}],"path":["Result"]}},{"id":46,"type":{"def":{"variant":{"variants":[{"fields":[{"type":47}],"index":0,"name":"Ok"},{"fields":[{"type":13}],"index":1,"name":"Err"}]}},"params":[{"name":"T","type":47},{"name":"E","type":13}],"path":["Result"]}},{"id":47,"type":{"def":{"primitive":"bool"}}},{"id":48,"type":{"def":{"variant":{"variants":[{"fields":[{"type":49}],"index":0,"name":"Ok"},{"fields":[{"type":14}],"index":1,"name":"Err"}]}},"params":[{"name":"T","type":49},{"name":"E","type":14}],"path":["Result"]}},{"id":49,"type":{"def":{"variant":{"variants":[{"fields":[{"type":50}],"index":0,"name":"Ok"},{"fields":[{"type":13}],"index":1,"name":"Err"}]}},"params":[{"name":"T","type":50},{"name":"E","type":13}],"path":["Result"]}},{"id":50,"type":{"def":{"composite":{"fields":[{"name":"before","type":1,"typeName":"BlockNumber"},{"name":"dapp_contract","type":7,"typeName":"AccountId"}]}},"path":["captcha","captcha","LastCorrectCaptcha"]}},{"id":51,"type":{"def":{"variant":{"variants":[{"fields":[{"type":52}],"index":0,"name":"Ok"},{"fields":[{"type":14}],"index":1,"name":"Err"}]}},"params":[{"name":"T","type":52},{"name":"E","type":14}],"path":["Result"]}},{"id":52,"type":{"def":{"variant":{"variants":[{"fields":[{"type":53}],"index":0,"name":"Ok"},{"fields":[{"type":13}],"index":1,"name":"Err"}]}},"params":[{"name":"T","type":53},{"name":"E","type":13}],"path":["Result"]}},{"id":53,"type":{"def":{"composite":{"fields":[{"name":"history","type":9,"typeName":"Vec<Hash>"}]}},"path":["captcha","captcha","User"]}},{"id":54,"type":{"def":{"variant":{"variants":[{"fields":[{"type":55}],"index":0,"name":"Ok"},{"fields":[{"type":14}],"index":1,"name":"Err"}]}},"params":[{"name":"T","type":55},{"name":"E","type":14}],"path":["Result"]}},{"id":55,"type":{"def":{"variant":{"variants":[{"fields":[{"type":41}],"index":0,"name":"Ok"},{"fields":[{"type":13}],"index":1,"name":"Err"}]}},"params":[{"name":"T","type":41},{"name":"E","type":13}],"path":["Result"]}},{"id":56,"type":{"def":{"variant":{"variants":[{"fields":[{"type":57}],"index":0,"name":"Ok"},{"fields":[{"type":14}],"index":1,"name":"Err"}]}},"params":[{"name":"T","type":57},{"name":"E","type":14}],"path":["Result"]}},{"id":57,"type":{"def":{"variant":{"variants":[{"fields":[{"type":58}],"index":0,"name":"Ok"},{"fields":[{"type":13}],"index":1,"name":"Err"}]}},"params":[{"name":"T","type":58},{"name":"E","type":13}],"path":["Result"]}},{"id":58,"type":{"def":{"sequence":{"type":34}}}},{"id":59,"type":{"def":{"variant":{"variants":[{"fields":[{"type":60}],"index":0,"name":"Ok"},{"fields":[{"type":14}],"index":1,"name":"Err"}]}},"params":[{"name":"T","type":60},{"name":"E","type":14}],"path":["Result"]}},{"id":60,"type":{"def":{"variant":{"variants":[{"fields":[{"type":61}],"index":0,"name":"Ok"},{"fields":[{"type":13}],"index":1,"name":"Err"}]}},"params":[{"name":"T","type":61},{"name":"E","type":13}],"path":["Result"]}},{"id":61,"type":{"def":{"composite":{"fields":[{"name":"provider_account","type":7,"typeName":"AccountId"},{"name":"provider","type":34,"typeName":"Provider"},{"name":"block_number","type":1,"typeName":"BlockNumber"}]}},"path":["captcha","captcha","RandomProvider"]}},{"id":62,"type":{"def":{"variant":{"variants":[{"fields":[{"type":63}],"index":0,"name":"Ok"},{"fields":[{"type":14}],"index":1,"name":"Err"}]}},"params":[{"name":"T","type":63},{"name":"E","type":14}],"path":["Result"]}},{"id":63,"type":{"def":{"variant":{"variants":[{"fields":[{"type":8}],"index":0,"name":"Ok"},{"fields":[{"type":13}],"index":1,"name":"Err"}]}},"params":[{"name":"T","type":8},{"name":"E","type":13}],"path":["Result"]}},{"id":64,"type":{"def":{"primitive":"u64"}}},{"id":65,"type":{"def":{"variant":{}},"path":["ink_env","types","NoChainExtension"]}}],"version":"4"}';
function lm(n) {
  return n.map((e) => J({}, e, {
    name: Array.isArray(e.name) ? e.name : [e.name]
  }));
}
function WR(n, e) {
  if (!e.metadataVersion.length)
    throw new Error("Invalid format for V0 (detected) contract metadata");
  return n.createType("ContractMetadataV1", J({}, e, {
    spec: J({}, e.spec, {
      constructors: lm(e.spec.constructors),
      messages: lm(e.spec.messages)
    }),
    types: u8(n, e.types)
  }));
}
const qR = {
  ContractConstructorSpec: "ContractMessageParamSpecV2",
  ContractEventSpec: "ContractEventParamSpecV2",
  ContractMessageSpec: "ContractMessageParamSpecV2"
};
function um(n) {
  return J({}, n, {
    label: Array.isArray(n.name) ? n.name.join("::") : n.name
  });
}
function Gc(n, e, t) {
  return t.map((r) => n.createType(`${e}V2`, J(um(r), {
    args: r.args.map((i) => n.createType(qR[e], um(i)))
  })));
}
function zR(n, e) {
  return n.createType("ContractMetadataV2", J({}, e, {
    spec: J({}, e.spec, {
      constructors: Gc(n, "ContractConstructorSpec", e.spec.constructors),
      events: Gc(n, "ContractEventSpec", e.spec.events),
      messages: Gc(n, "ContractMessageSpec", e.spec.messages)
    })
  }));
}
function XR(n, e) {
  return n.createType("ContractMetadataV3", J({}, e, {
    spec: J({}, e.spec, {
      constructors: e.spec.constructors.map((t) => (
        // V3 introduces the payable flag on constructors, for <V3, it is always true
        n.createType("ContractConstructorSpecV3", J({}, t, { payable: !0 }))
      ))
    })
  }));
}
function GR(n, e) {
  return n.createType("ContractMetadataV4", J({}, e, {
    spec: J({}, e.spec, {
      constructors: e.spec.constructors.map((t) => n.createType("ContractConstructorSpecV4", J({}, t))),
      messages: e.spec.messages.map((t) => n.createType("ContractMessageSpecV3", J({}, t)))
    })
  }));
}
const dm = ["V4", "V3", "V2", "V1"];
function Do(n, e) {
  return (t, r) => n(t, e(t, r));
}
function fv(n, e) {
  return e;
}
const hv = /* @__PURE__ */ Do(fv, GR), pv = /* @__PURE__ */ Do(hv, XR), mv = /* @__PURE__ */ Do(pv, zR), ZR = /* @__PURE__ */ Do(mv, WR), JR = [
  ["V4", fv],
  ["V3", hv],
  ["V2", pv],
  ["V1", mv],
  ["V0", ZR]
], KR = Qt("Abi"), YR = ["AccountId", "AccountIndex", "Address", "Balance"];
function fm(n, e) {
  const t = xe(e) ? n[e] : Pe(e) ? n.find(({ identifier: r }) => [r, Ee(r)].includes(e.toString())) : e;
  return zn(t, () => `Attempted to call an invalid contract interface, ${_e(e)}`);
}
function QR(n, e) {
  const t = dm.find((a) => qt(e[a])), r = e.version;
  if (!t && r && !dm.find((a) => a === `V${r}`))
    throw new Error(`Unable to handle version ${r}`);
  const i = n.createType("ContractMetadata", t ? { [t]: e[t] } : r ? { [`V${r}`]: e } : { V0: e }), s = JR.find(([a]) => i[`is${a}`]);
  if (!s)
    throw new Error(`Unable to convert ABI with version ${i.type} to latest`);
  return s[1](n, i[`as${s[0]}`]);
}
function $R(n, e) {
  const t = new vd(), r = t.createType("ContractProjectInfo", n), i = QR(t, n), s = t.createType("PortableRegistry", { types: i.types }, !0);
  return t.setLookup(s), e && t.setChainProperties(e), s.types.forEach(({ id: a }) => s.getTypeDef(a)), [n, t, i, r];
}
function eI(n) {
  return !!n && n instanceof Map && !Ne(n.type) && !Ne(n.displayName);
}
function tI(n) {
  return !!n && n instanceof yr;
}
class Yl {
  constructor(e, t) {
    b(this, "events");
    b(this, "constructors");
    b(this, "info");
    b(this, "json");
    b(this, "messages");
    b(this, "metadata");
    b(this, "registry");
    b(this, "environment", /* @__PURE__ */ new Map());
    b(this, "__internal__createArgs", (e, t) => e.map(({ label: r, type: i }, s) => {
      try {
        if (!qt(i))
          throw new Error("Invalid type definition found");
        const a = i.displayName.length ? i.displayName[i.displayName.length - 1].toString() : void 0, o = Ee(r);
        if (a && YR.includes(a))
          return {
            name: o,
            type: {
              info: M.Plain,
              type: a
            }
          };
        const c = this.registry.lookup.getTypeDef(i.type);
        return {
          name: o,
          type: a && !c.type.startsWith(a) ? { displayName: a, ...c } : c
        };
      } catch (a) {
        throw KR.error(`Error expanding argument ${s} in ${_e(t)}`), a;
      }
    }));
    b(this, "__internal__createEvent", (e, t) => {
      const r = this.__internal__createArgs(e.args, e), i = {
        args: r,
        docs: e.docs.map((s) => s.toString()),
        fromU8a: (s) => ({
          args: this.__internal__decodeArgs(r, s),
          event: i
        }),
        identifier: e.label.toString(),
        index: t
      };
      return i;
    });
    b(this, "__internal__createMessage", (e, t, r = {}) => {
      const i = this.__internal__createArgs(e.args, e), s = e.label.toString(), a = {
        ...r,
        args: i,
        docs: e.docs.map((o) => o.toString()),
        fromU8a: (o) => ({
          args: this.__internal__decodeArgs(i, o),
          message: a
        }),
        identifier: s,
        index: t,
        isDefault: e.default.isTrue,
        method: Ee(s),
        path: s.split("::").map((o) => Ee(o)),
        selector: e.selector,
        toU8a: (o) => this.__internal__encodeArgs(e, i, o)
      };
      return a;
    });
    b(this, "__internal__decodeArgs", (e, t) => {
      let r = 0;
      return e.map(({ type: { lookupName: i, type: s } }) => {
        const a = this.registry.createType(i || s, t.subarray(r));
        return r += a.encodedLength, a;
      });
    });
    b(this, "__internal__decodeMessage", (e, t, r) => {
      const [, i] = Ri(r), s = i.subarray(0, 4), a = t.find((o) => o.selector.eq(s));
      if (!a)
        throw new Error(`Unable to find ${e} with selector ${pe(s)}`);
      return a.fromU8a(i.subarray(4));
    });
    b(this, "__internal__encodeArgs", ({ label: e, selector: t }, r, i) => {
      if (i.length !== r.length)
        throw new Error(`Expected ${r.length} arguments to contract message '${e.toString()}', found ${i.length}`);
      return wn(Me(this.registry.createType("ContractSelector", t).toU8a(), ...r.map(({ type: { lookupName: s, type: a } }, o) => this.registry.createType(s || a, i[o]).toU8a())));
    });
    [this.json, this.registry, this.metadata, this.info] = $R(Pe(e) ? JSON.parse(e) : e, t), this.constructors = this.metadata.spec.constructors.map((r, i) => this.__internal__createMessage(r, i, {
      isConstructor: !0,
      isDefault: r.default.isTrue,
      isPayable: r.payable.isTrue,
      returnType: r.returnType.isSome ? this.registry.lookup.getTypeDef(r.returnType.unwrap().type) : null
    })), this.events = this.metadata.spec.events.map((r, i) => this.__internal__createEvent(r, i)), this.messages = this.metadata.spec.messages.map((r, i) => this.__internal__createMessage(r, i, {
      isDefault: r.default.isTrue,
      isMutating: r.mutates.isTrue,
      isPayable: r.payable.isTrue,
      returnType: r.returnType.isSome ? this.registry.lookup.getTypeDef(r.returnType.unwrap().type) : null
    }));
    for (const [r, i] of this.metadata.spec.environment.entries())
      if (tI(i)) {
        if (i.isSome) {
          const s = i.unwrap();
          if (Yt(s))
            this.environment.set(r, s);
          else if (eI(s))
            this.environment.set(r, this.registry.lookup.getTypeDef(s.type));
          else
            throw new Error(`Invalid environment definition for ${r}:: Expected either Number or ContractTypeSpec`);
        }
      } else
        throw new Error(`Expected Option<*> definition for ${r} in ContractEnvironment`);
  }
  /**
   * Warning: Unstable API, bound to change
   */
  decodeEvent(e) {
    const t = e[0], r = this.events[t];
    if (!r)
      throw new Error(`Unable to find event with index ${t}`);
    return r.fromU8a(e.subarray(1));
  }
  /**
   * Warning: Unstable API, bound to change
   */
  decodeConstructor(e) {
    return this.__internal__decodeMessage("message", this.constructors, e);
  }
  /**
   * Warning: Unstable API, bound to change
   */
  decodeMessage(e) {
    return this.__internal__decodeMessage("message", this.messages, e);
  }
  findConstructor(e) {
    return fm(this.constructors, e);
  }
  findMessage(e) {
    return fm(this.messages, e);
  }
}
function nI(n, e, t) {
  if (n.isInBlock || n.isFinalized) {
    const r = n.filterRecords("contracts", e);
    if (r.length)
      return t(r);
  }
}
class rI {
  constructor(e, t, r) {
    b(this, "abi");
    b(this, "api");
    b(this, "_decorateMethod");
    b(this, "_isWeightV1");
    if (!e || !e.isConnected || !e.tx)
      throw new Error("Your API has not been initialized correctly and is not connected to a chain");
    if (!e.tx.contracts || !ue(e.tx.contracts.instantiateWithCode) || e.tx.contracts.instantiateWithCode.meta.args.length !== 6)
      throw new Error("The runtime does not expose api.tx.contracts.instantiateWithCode with storageDepositLimit");
    if (!e.call.contractsApi || !ue(e.call.contractsApi.call))
      throw new Error("Your runtime does not expose the api.call.contractsApi.call runtime interfaces");
    this.abi = t instanceof Yl ? t : new Yl(t, e.registry.getChainProperties()), this.api = e, this._decorateMethod = r, this._isWeightV1 = !e.registry.createType("Weight").proofSize;
  }
  get registry() {
    return this.api.registry;
  }
}
const iI = new Z(5e12).isub(_r), sI = Qt("Contract");
function aI(n, e) {
  return Oo(n, (t, r, ...i) => e(t, r, i));
}
function oI(n, e) {
  return Oo(n, (t, ...r) => e(t, r));
}
class cI extends Aa {
  constructor(t, r) {
    super(t);
    b(this, "contractEvents");
    this.contractEvents = r;
  }
}
let lI = class extends rI {
  constructor(t, r, i, s) {
    super(t, r, s);
    /**
     * @description The on-chain address for this contract
     */
    b(this, "address");
    b(this, "__internal__query", {});
    b(this, "__internal__tx", {});
    b(this, "__internal__getGas", (t, r = !1) => {
      const i = ar(t);
      return i.v1Weight.gt(At) ? i : ar(r ? iI : ar(this.api.consts.system.blockWeights ? this.api.consts.system.blockWeights.maxBlock : this.api.consts.system.maximumBlockWeight).v1Weight.muln(64).div(mu));
    });
    b(this, "__internal__exec", (t, { gasLimit: r = At, storageDepositLimit: i = null, value: s = At }, a) => this.api.tx.contracts.call(
      this.address,
      s,
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore jiggle v1 weights, metadata points to latest
      this._isWeightV1 ? ar(r).v1Weight : ar(r).v2Weight,
      i,
      this.abi.findMessage(t).toU8a(a)
    ).withResultTransform((o) => (
      // ContractEmitted is the current generation, ContractExecution is the previous generation
      new cI(o, nI(o, ["ContractEmitted", "ContractExecution"], (c) => c.map(({ event: { data: [, l] } }) => {
        try {
          return this.abi.decodeEvent(l);
        } catch (u) {
          return sI.error(`Unable to decode contract event: ${u.message}`), null;
        }
      }).filter((l) => !!l)))
    )));
    b(this, "__internal__read", (t, { gasLimit: r = At, storageDepositLimit: i = null, value: s = At }, a) => {
      const o = this.abi.findMessage(t);
      return {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        send: this._decorateMethod((c) => this.api.rx.call.contractsApi.call(
          c,
          this.address,
          s,
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-ignore jiggle v1 weights, metadata points to latest
          this._isWeightV1 ? this.__internal__getGas(r, !0).v1Weight : this.__internal__getGas(r, !0).v2Weight,
          i,
          o.toU8a(a)
        ).pipe(oe(({ debugMessage: l, gasConsumed: u, gasRequired: f, result: m, storageDeposit: y }) => ({
          debugMessage: l,
          gasConsumed: u,
          gasRequired: f && !ar(f).v1Weight.isZero() ? f : u,
          output: m.isOk && o.returnType ? this.abi.registry.createTypeUnsafe(o.returnType.lookupName || o.returnType.type, [m.asOk.data.toU8a(!0)], { isPedantic: !0 }) : null,
          result: m,
          storageDeposit: y
        }))))
      };
    });
    this.address = this.registry.createType("AccountId", i), this.abi.messages.forEach((a) => {
      Ne(this.__internal__tx[a.method]) && (this.__internal__tx[a.method] = oI(a, (o, c) => this.__internal__exec(a, o, c))), Ne(this.__internal__query[a.method]) && (this.__internal__query[a.method] = aI(a, (o, c, l) => this.__internal__read(a, c, l).send(o)));
    });
  }
  get query() {
    return this.__internal__query;
  }
  get tx() {
    return this.__internal__tx;
  }
};
class gv extends lI {
  constructor(e, t, r) {
    super(e, t, r, tv);
  }
}
class uI {
  constructor(e, t) {
    this.__nativeContract = e, this.__api = t;
  }
  __subscribeOnEvent(e, t = () => !0) {
    return this.__api.query.system.events((r) => {
      r.forEach((i) => {
        const { event: s } = i;
        if (s.method == "ContractEmitted") {
          const [a, o] = i.event.data;
          if (a.toString() === this.__nativeContract.address.toString()) {
            const { args: c, event: l } = this.__nativeContract.abi.decodeEvent(o);
            t(l.identifier.toString()) && e(c, l);
          }
        }
      });
    });
  }
}
function $(n, e) {
  return e[n];
}
function dI(n, e) {
  return e[n];
}
function re(n, e, t) {
  return n.filter((r) => {
    const { event: i } = r, [s, a] = r.event.data;
    return i.method == "ContractEmitted" && s.toString() === e.address.toString();
  }).map((r) => {
    const [i, s] = r.event.data, { args: a, event: o } = e.abi.decodeEvent(s), c = {};
    for (let l = 0; l < a.length; l++)
      c[o.args[l].name] = a[l].toJSON();
    return N.handleEventReturn(c, dI(o.identifier.toString(), t)), {
      name: o.identifier.toString(),
      args: c
    };
  });
}
const ee = {
  0: {
    name: "ReturnNumber",
    isResult: !1,
    isPrimitive: !1,
    isConvertable: !0
  },
  1: {
    name: "number",
    isResult: !1,
    isPrimitive: !0,
    isConvertable: !1
  },
  2: {
    name: "Array",
    body: {
      0: {
        name: "number",
        isResult: !1,
        isPrimitive: !0,
        isConvertable: !1
      }
    },
    isResult: !1,
    isPrimitive: !1,
    isConvertable: !1
  },
  3: {
    name: "number",
    isResult: !1,
    isPrimitive: !0,
    isConvertable: !1
  },
  4: {
    name: "Hash",
    body: "string | number[]",
    isResult: !1,
    isPrimitive: !0,
    isConvertable: !1
  },
  5: {
    name: "Array",
    body: {
      0: {
        name: "number",
        isResult: !1,
        isPrimitive: !0,
        isConvertable: !1
      }
    },
    isResult: !1,
    isPrimitive: !1,
    isConvertable: !1
  },
  7: {
    name: "AccountId",
    body: "string | number[]",
    isResult: !1,
    isPrimitive: !0,
    isConvertable: !1
  },
  8: {
    name: "Array",
    body: {
      0: {
        name: "AccountId",
        body: "string | number[]",
        isResult: !1,
        isPrimitive: !0,
        isConvertable: !1
      }
    },
    isResult: !1,
    isPrimitive: !1,
    isConvertable: !1
  },
  9: {
    name: "Array",
    body: {
      0: {
        name: "Hash",
        body: "string | number[]",
        isResult: !1,
        isPrimitive: !0,
        isConvertable: !1
      }
    },
    isResult: !1,
    isPrimitive: !1,
    isConvertable: !1
  },
  10: {
    name: "Result<Result<null, Error, LangError",
    body: {
      ok: {
        name: "Result<null, Error",
        body: {
          ok: {
            name: "null",
            isResult: !1,
            isPrimitive: !0,
            isConvertable: !1
          },
          err: {
            name: "Error",
            body: {
              NotAuthorised: null,
              TransferFailed: null,
              SetCodeHashFailed: null,
              InvalidDestination: null,
              UnknownMessage: null,
              ProviderAccountExists: null,
              ProviderExists: null,
              ProviderAccountDoesNotExist: null,
              ProviderDoesNotExist: null,
              ProviderInsufficientFunds: null,
              ProviderInactive: null,
              ProviderUrlUsed: null,
              DappExists: null,
              DappDoesNotExist: null,
              DappInactive: null,
              DappInsufficientFunds: null,
              CaptchaDataDoesNotExist: null,
              CommitDoesNotExist: null,
              DappUserDoesNotExist: null,
              NoActiveProviders: null,
              DatasetIdSolutionsSame: null,
              CodeNotFound: null,
              Unknown: null,
              InvalidContract: null,
              InvalidPayee: null,
              InvalidCaptchaStatus: null,
              NoCorrectCaptcha: null,
              NotEnoughActiveProviders: null,
              ProviderFeeTooHigh: null,
              CommitAlreadyExists: null,
              NotAuthor: null,
              Math: null
            },
            isResult: !1,
            isPrimitive: !1,
            isConvertable: !1
          }
        },
        isResult: !0,
        isPrimitive: !1,
        isConvertable: !1
      },
      err: {
        name: "LangError",
        body: {
          CouldNotReadInput: null
        },
        isResult: !1,
        isPrimitive: !1,
        isConvertable: !1
      }
    },
    isResult: !0,
    isPrimitive: !1,
    isConvertable: !1
  },
  11: {
    name: "Result<null, Error",
    body: {
      ok: {
        name: "null",
        isResult: !1,
        isPrimitive: !0,
        isConvertable: !1
      },
      err: {
        name: "Error",
        body: {
          NotAuthorised: null,
          TransferFailed: null,
          SetCodeHashFailed: null,
          InvalidDestination: null,
          UnknownMessage: null,
          ProviderAccountExists: null,
          ProviderExists: null,
          ProviderAccountDoesNotExist: null,
          ProviderDoesNotExist: null,
          ProviderInsufficientFunds: null,
          ProviderInactive: null,
          ProviderUrlUsed: null,
          DappExists: null,
          DappDoesNotExist: null,
          DappInactive: null,
          DappInsufficientFunds: null,
          CaptchaDataDoesNotExist: null,
          CommitDoesNotExist: null,
          DappUserDoesNotExist: null,
          NoActiveProviders: null,
          DatasetIdSolutionsSame: null,
          CodeNotFound: null,
          Unknown: null,
          InvalidContract: null,
          InvalidPayee: null,
          InvalidCaptchaStatus: null,
          NoCorrectCaptcha: null,
          NotEnoughActiveProviders: null,
          ProviderFeeTooHigh: null,
          CommitAlreadyExists: null,
          NotAuthor: null,
          Math: null
        },
        isResult: !1,
        isPrimitive: !1,
        isConvertable: !1
      }
    },
    isResult: !0,
    isPrimitive: !1,
    isConvertable: !1
  },
  12: {
    name: "null",
    isResult: !1,
    isPrimitive: !0,
    isConvertable: !1
  },
  13: {
    name: "Error",
    body: {
      NotAuthorised: null,
      TransferFailed: null,
      SetCodeHashFailed: null,
      InvalidDestination: null,
      UnknownMessage: null,
      ProviderAccountExists: null,
      ProviderExists: null,
      ProviderAccountDoesNotExist: null,
      ProviderDoesNotExist: null,
      ProviderInsufficientFunds: null,
      ProviderInactive: null,
      ProviderUrlUsed: null,
      DappExists: null,
      DappDoesNotExist: null,
      DappInactive: null,
      DappInsufficientFunds: null,
      CaptchaDataDoesNotExist: null,
      CommitDoesNotExist: null,
      DappUserDoesNotExist: null,
      NoActiveProviders: null,
      DatasetIdSolutionsSame: null,
      CodeNotFound: null,
      Unknown: null,
      InvalidContract: null,
      InvalidPayee: null,
      InvalidCaptchaStatus: null,
      NoCorrectCaptcha: null,
      NotEnoughActiveProviders: null,
      ProviderFeeTooHigh: null,
      CommitAlreadyExists: null,
      NotAuthor: null,
      Math: null
    },
    isResult: !1,
    isPrimitive: !1,
    isConvertable: !1
  },
  14: {
    name: "LangError",
    body: {
      CouldNotReadInput: null
    },
    isResult: !1,
    isPrimitive: !1,
    isConvertable: !1
  },
  15: {
    name: "Result<null, LangError",
    body: {
      ok: {
        name: "null",
        isResult: !1,
        isPrimitive: !0,
        isConvertable: !1
      },
      err: {
        name: "LangError",
        body: {
          CouldNotReadInput: null
        },
        isResult: !1,
        isPrimitive: !1,
        isConvertable: !1
      }
    },
    isResult: !0,
    isPrimitive: !1,
    isConvertable: !1
  },
  16: {
    name: "Result<Array, LangError",
    body: {
      ok: {
        name: "Array",
        body: {
          0: {
            name: "number",
            isResult: !1,
            isPrimitive: !0,
            isConvertable: !1
          }
        },
        isResult: !1,
        isPrimitive: !1,
        isConvertable: !1
      },
      err: {
        name: "LangError",
        body: {
          CouldNotReadInput: null
        },
        isResult: !1,
        isPrimitive: !1,
        isConvertable: !1
      }
    },
    isResult: !0,
    isPrimitive: !1,
    isConvertable: !1
  },
  17: {
    name: "Array",
    body: {
      0: {
        name: "number",
        isResult: !1,
        isPrimitive: !0,
        isConvertable: !1
      }
    },
    isResult: !1,
    isPrimitive: !1,
    isConvertable: !1
  },
  18: {
    name: "Result<AccountId, LangError",
    body: {
      ok: {
        name: "AccountId",
        body: "string | number[]",
        isResult: !1,
        isPrimitive: !0,
        isConvertable: !1
      },
      err: {
        name: "LangError",
        body: {
          CouldNotReadInput: null
        },
        isResult: !1,
        isPrimitive: !1,
        isConvertable: !1
      }
    },
    isResult: !0,
    isPrimitive: !1,
    isConvertable: !1
  },
  19: {
    name: "Result<Array, LangError",
    body: {
      ok: {
        name: "Array",
        body: {
          0: {
            name: "Payee",
            body: {
              Provider: null,
              Dapp: null
            },
            isResult: !1,
            isPrimitive: !1,
            isConvertable: !1
          }
        },
        isResult: !1,
        isPrimitive: !1,
        isConvertable: !1
      },
      err: {
        name: "LangError",
        body: {
          CouldNotReadInput: null
        },
        isResult: !1,
        isPrimitive: !1,
        isConvertable: !1
      }
    },
    isResult: !0,
    isPrimitive: !1,
    isConvertable: !1
  },
  20: {
    name: "Array",
    body: {
      0: {
        name: "Payee",
        body: {
          Provider: null,
          Dapp: null
        },
        isResult: !1,
        isPrimitive: !1,
        isConvertable: !1
      }
    },
    isResult: !1,
    isPrimitive: !1,
    isConvertable: !1
  },
  21: {
    name: "Payee",
    body: {
      Provider: null,
      Dapp: null
    },
    isResult: !1,
    isPrimitive: !1,
    isConvertable: !1
  },
  22: {
    name: "Result<Array, LangError",
    body: {
      ok: {
        name: "Array",
        body: {
          0: {
            name: "DappPayee",
            body: {
              Provider: null,
              Dapp: null,
              Any: null
            },
            isResult: !1,
            isPrimitive: !1,
            isConvertable: !1
          }
        },
        isResult: !1,
        isPrimitive: !1,
        isConvertable: !1
      },
      err: {
        name: "LangError",
        body: {
          CouldNotReadInput: null
        },
        isResult: !1,
        isPrimitive: !1,
        isConvertable: !1
      }
    },
    isResult: !0,
    isPrimitive: !1,
    isConvertable: !1
  },
  23: {
    name: "Array",
    body: {
      0: {
        name: "DappPayee",
        body: {
          Provider: null,
          Dapp: null,
          Any: null
        },
        isResult: !1,
        isPrimitive: !1,
        isConvertable: !1
      }
    },
    isResult: !1,
    isPrimitive: !1,
    isConvertable: !1
  },
  24: {
    name: "DappPayee",
    body: {
      Provider: null,
      Dapp: null,
      Any: null
    },
    isResult: !1,
    isPrimitive: !1,
    isConvertable: !1
  },
  25: {
    name: "Result<Array, LangError",
    body: {
      ok: {
        name: "Array",
        body: {
          0: {
            name: "GovernanceStatus",
            body: {
              Active: null,
              Inactive: null
            },
            isResult: !1,
            isPrimitive: !1,
            isConvertable: !1
          }
        },
        isResult: !1,
        isPrimitive: !1,
        isConvertable: !1
      },
      err: {
        name: "LangError",
        body: {
          CouldNotReadInput: null
        },
        isResult: !1,
        isPrimitive: !1,
        isConvertable: !1
      }
    },
    isResult: !0,
    isPrimitive: !1,
    isConvertable: !1
  },
  26: {
    name: "Array",
    body: {
      0: {
        name: "GovernanceStatus",
        body: {
          Active: null,
          Inactive: null
        },
        isResult: !1,
        isPrimitive: !1,
        isConvertable: !1
      }
    },
    isResult: !1,
    isPrimitive: !1,
    isConvertable: !1
  },
  27: {
    name: "GovernanceStatus",
    body: {
      Active: null,
      Inactive: null
    },
    isResult: !1,
    isPrimitive: !1,
    isConvertable: !1
  },
  28: {
    name: "Result<ReturnNumber, LangError",
    body: {
      ok: {
        name: "ReturnNumber",
        isResult: !1,
        isPrimitive: !1,
        isConvertable: !0
      },
      err: {
        name: "LangError",
        body: {
          CouldNotReadInput: null
        },
        isResult: !1,
        isPrimitive: !1,
        isConvertable: !1
      }
    },
    isResult: !0,
    isPrimitive: !1,
    isConvertable: !1
  },
  29: {
    name: "Result<number, LangError",
    body: {
      ok: {
        name: "number",
        isResult: !1,
        isPrimitive: !0,
        isConvertable: !1
      },
      err: {
        name: "LangError",
        body: {
          CouldNotReadInput: null
        },
        isResult: !1,
        isPrimitive: !1,
        isConvertable: !1
      }
    },
    isResult: !0,
    isPrimitive: !1,
    isConvertable: !1
  },
  30: {
    name: "Result<number, LangError",
    body: {
      ok: {
        name: "number",
        isResult: !1,
        isPrimitive: !0,
        isConvertable: !1
      },
      err: {
        name: "LangError",
        body: {
          CouldNotReadInput: null
        },
        isResult: !1,
        isPrimitive: !1,
        isConvertable: !1
      }
    },
    isResult: !0,
    isPrimitive: !1,
    isConvertable: !1
  },
  31: {
    name: "number",
    isResult: !1,
    isPrimitive: !0,
    isConvertable: !1
  },
  32: {
    name: "Result<Result<Provider, Error, LangError",
    body: {
      ok: {
        name: "Result<Provider, Error",
        body: {
          ok: {
            name: "Provider",
            body: {
              status: {
                name: "GovernanceStatus",
                body: {
                  Active: null,
                  Inactive: null
                },
                isResult: !1,
                isPrimitive: !1,
                isConvertable: !1
              },
              balance: {
                name: "ReturnNumber",
                isResult: !1,
                isPrimitive: !1,
                isConvertable: !0
              },
              fee: {
                name: "number",
                isResult: !1,
                isPrimitive: !0,
                isConvertable: !1
              },
              payee: {
                name: "Payee",
                body: {
                  Provider: null,
                  Dapp: null
                },
                isResult: !1,
                isPrimitive: !1,
                isConvertable: !1
              },
              url: {
                name: "Array",
                body: {
                  0: {
                    name: "number",
                    isResult: !1,
                    isPrimitive: !0,
                    isConvertable: !1
                  }
                },
                isResult: !1,
                isPrimitive: !1,
                isConvertable: !1
              },
              datasetId: {
                name: "Hash",
                body: "string | number[]",
                isResult: !1,
                isPrimitive: !0,
                isConvertable: !1
              },
              datasetIdContent: {
                name: "Hash",
                body: "string | number[]",
                isResult: !1,
                isPrimitive: !0,
                isConvertable: !1
              }
            },
            isResult: !1,
            isPrimitive: !1,
            isConvertable: !1
          },
          err: {
            name: "Error",
            body: {
              NotAuthorised: null,
              TransferFailed: null,
              SetCodeHashFailed: null,
              InvalidDestination: null,
              UnknownMessage: null,
              ProviderAccountExists: null,
              ProviderExists: null,
              ProviderAccountDoesNotExist: null,
              ProviderDoesNotExist: null,
              ProviderInsufficientFunds: null,
              ProviderInactive: null,
              ProviderUrlUsed: null,
              DappExists: null,
              DappDoesNotExist: null,
              DappInactive: null,
              DappInsufficientFunds: null,
              CaptchaDataDoesNotExist: null,
              CommitDoesNotExist: null,
              DappUserDoesNotExist: null,
              NoActiveProviders: null,
              DatasetIdSolutionsSame: null,
              CodeNotFound: null,
              Unknown: null,
              InvalidContract: null,
              InvalidPayee: null,
              InvalidCaptchaStatus: null,
              NoCorrectCaptcha: null,
              NotEnoughActiveProviders: null,
              ProviderFeeTooHigh: null,
              CommitAlreadyExists: null,
              NotAuthor: null,
              Math: null
            },
            isResult: !1,
            isPrimitive: !1,
            isConvertable: !1
          }
        },
        isResult: !0,
        isPrimitive: !1,
        isConvertable: !1
      },
      err: {
        name: "LangError",
        body: {
          CouldNotReadInput: null
        },
        isResult: !1,
        isPrimitive: !1,
        isConvertable: !1
      }
    },
    isResult: !0,
    isPrimitive: !1,
    isConvertable: !1
  },
  33: {
    name: "Result<Provider, Error",
    body: {
      ok: {
        name: "Provider",
        body: {
          status: {
            name: "GovernanceStatus",
            body: {
              Active: null,
              Inactive: null
            },
            isResult: !1,
            isPrimitive: !1,
            isConvertable: !1
          },
          balance: {
            name: "ReturnNumber",
            isResult: !1,
            isPrimitive: !1,
            isConvertable: !0
          },
          fee: {
            name: "number",
            isResult: !1,
            isPrimitive: !0,
            isConvertable: !1
          },
          payee: {
            name: "Payee",
            body: {
              Provider: null,
              Dapp: null
            },
            isResult: !1,
            isPrimitive: !1,
            isConvertable: !1
          },
          url: {
            name: "Array",
            body: {
              0: {
                name: "number",
                isResult: !1,
                isPrimitive: !0,
                isConvertable: !1
              }
            },
            isResult: !1,
            isPrimitive: !1,
            isConvertable: !1
          },
          datasetId: {
            name: "Hash",
            body: "string | number[]",
            isResult: !1,
            isPrimitive: !0,
            isConvertable: !1
          },
          datasetIdContent: {
            name: "Hash",
            body: "string | number[]",
            isResult: !1,
            isPrimitive: !0,
            isConvertable: !1
          }
        },
        isResult: !1,
        isPrimitive: !1,
        isConvertable: !1
      },
      err: {
        name: "Error",
        body: {
          NotAuthorised: null,
          TransferFailed: null,
          SetCodeHashFailed: null,
          InvalidDestination: null,
          UnknownMessage: null,
          ProviderAccountExists: null,
          ProviderExists: null,
          ProviderAccountDoesNotExist: null,
          ProviderDoesNotExist: null,
          ProviderInsufficientFunds: null,
          ProviderInactive: null,
          ProviderUrlUsed: null,
          DappExists: null,
          DappDoesNotExist: null,
          DappInactive: null,
          DappInsufficientFunds: null,
          CaptchaDataDoesNotExist: null,
          CommitDoesNotExist: null,
          DappUserDoesNotExist: null,
          NoActiveProviders: null,
          DatasetIdSolutionsSame: null,
          CodeNotFound: null,
          Unknown: null,
          InvalidContract: null,
          InvalidPayee: null,
          InvalidCaptchaStatus: null,
          NoCorrectCaptcha: null,
          NotEnoughActiveProviders: null,
          ProviderFeeTooHigh: null,
          CommitAlreadyExists: null,
          NotAuthor: null,
          Math: null
        },
        isResult: !1,
        isPrimitive: !1,
        isConvertable: !1
      }
    },
    isResult: !0,
    isPrimitive: !1,
    isConvertable: !1
  },
  34: {
    name: "Provider",
    body: {
      status: {
        name: "GovernanceStatus",
        body: {
          Active: null,
          Inactive: null
        },
        isResult: !1,
        isPrimitive: !1,
        isConvertable: !1
      },
      balance: {
        name: "ReturnNumber",
        isResult: !1,
        isPrimitive: !1,
        isConvertable: !0
      },
      fee: {
        name: "number",
        isResult: !1,
        isPrimitive: !0,
        isConvertable: !1
      },
      payee: {
        name: "Payee",
        body: {
          Provider: null,
          Dapp: null
        },
        isResult: !1,
        isPrimitive: !1,
        isConvertable: !1
      },
      url: {
        name: "Array",
        body: {
          0: {
            name: "number",
            isResult: !1,
            isPrimitive: !0,
            isConvertable: !1
          }
        },
        isResult: !1,
        isPrimitive: !1,
        isConvertable: !1
      },
      datasetId: {
        name: "Hash",
        body: "string | number[]",
        isResult: !1,
        isPrimitive: !0,
        isConvertable: !1
      },
      datasetIdContent: {
        name: "Hash",
        body: "string | number[]",
        isResult: !1,
        isPrimitive: !0,
        isConvertable: !1
      }
    },
    isResult: !1,
    isPrimitive: !1,
    isConvertable: !1
  },
  35: {
    name: "Result<Result<Dapp, Error, LangError",
    body: {
      ok: {
        name: "Result<Dapp, Error",
        body: {
          ok: {
            name: "Dapp",
            body: {
              status: {
                name: "GovernanceStatus",
                body: {
                  Active: null,
                  Inactive: null
                },
                isResult: !1,
                isPrimitive: !1,
                isConvertable: !1
              },
              balance: {
                name: "ReturnNumber",
                isResult: !1,
                isPrimitive: !1,
                isConvertable: !0
              },
              owner: {
                name: "AccountId",
                body: "string | number[]",
                isResult: !1,
                isPrimitive: !0,
                isConvertable: !1
              },
              payee: {
                name: "DappPayee",
                body: {
                  Provider: null,
                  Dapp: null,
                  Any: null
                },
                isResult: !1,
                isPrimitive: !1,
                isConvertable: !1
              }
            },
            isResult: !1,
            isPrimitive: !1,
            isConvertable: !1
          },
          err: {
            name: "Error",
            body: {
              NotAuthorised: null,
              TransferFailed: null,
              SetCodeHashFailed: null,
              InvalidDestination: null,
              UnknownMessage: null,
              ProviderAccountExists: null,
              ProviderExists: null,
              ProviderAccountDoesNotExist: null,
              ProviderDoesNotExist: null,
              ProviderInsufficientFunds: null,
              ProviderInactive: null,
              ProviderUrlUsed: null,
              DappExists: null,
              DappDoesNotExist: null,
              DappInactive: null,
              DappInsufficientFunds: null,
              CaptchaDataDoesNotExist: null,
              CommitDoesNotExist: null,
              DappUserDoesNotExist: null,
              NoActiveProviders: null,
              DatasetIdSolutionsSame: null,
              CodeNotFound: null,
              Unknown: null,
              InvalidContract: null,
              InvalidPayee: null,
              InvalidCaptchaStatus: null,
              NoCorrectCaptcha: null,
              NotEnoughActiveProviders: null,
              ProviderFeeTooHigh: null,
              CommitAlreadyExists: null,
              NotAuthor: null,
              Math: null
            },
            isResult: !1,
            isPrimitive: !1,
            isConvertable: !1
          }
        },
        isResult: !0,
        isPrimitive: !1,
        isConvertable: !1
      },
      err: {
        name: "LangError",
        body: {
          CouldNotReadInput: null
        },
        isResult: !1,
        isPrimitive: !1,
        isConvertable: !1
      }
    },
    isResult: !0,
    isPrimitive: !1,
    isConvertable: !1
  },
  36: {
    name: "Result<Dapp, Error",
    body: {
      ok: {
        name: "Dapp",
        body: {
          status: {
            name: "GovernanceStatus",
            body: {
              Active: null,
              Inactive: null
            },
            isResult: !1,
            isPrimitive: !1,
            isConvertable: !1
          },
          balance: {
            name: "ReturnNumber",
            isResult: !1,
            isPrimitive: !1,
            isConvertable: !0
          },
          owner: {
            name: "AccountId",
            body: "string | number[]",
            isResult: !1,
            isPrimitive: !0,
            isConvertable: !1
          },
          payee: {
            name: "DappPayee",
            body: {
              Provider: null,
              Dapp: null,
              Any: null
            },
            isResult: !1,
            isPrimitive: !1,
            isConvertable: !1
          }
        },
        isResult: !1,
        isPrimitive: !1,
        isConvertable: !1
      },
      err: {
        name: "Error",
        body: {
          NotAuthorised: null,
          TransferFailed: null,
          SetCodeHashFailed: null,
          InvalidDestination: null,
          UnknownMessage: null,
          ProviderAccountExists: null,
          ProviderExists: null,
          ProviderAccountDoesNotExist: null,
          ProviderDoesNotExist: null,
          ProviderInsufficientFunds: null,
          ProviderInactive: null,
          ProviderUrlUsed: null,
          DappExists: null,
          DappDoesNotExist: null,
          DappInactive: null,
          DappInsufficientFunds: null,
          CaptchaDataDoesNotExist: null,
          CommitDoesNotExist: null,
          DappUserDoesNotExist: null,
          NoActiveProviders: null,
          DatasetIdSolutionsSame: null,
          CodeNotFound: null,
          Unknown: null,
          InvalidContract: null,
          InvalidPayee: null,
          InvalidCaptchaStatus: null,
          NoCorrectCaptcha: null,
          NotEnoughActiveProviders: null,
          ProviderFeeTooHigh: null,
          CommitAlreadyExists: null,
          NotAuthor: null,
          Math: null
        },
        isResult: !1,
        isPrimitive: !1,
        isConvertable: !1
      }
    },
    isResult: !0,
    isPrimitive: !1,
    isConvertable: !1
  },
  37: {
    name: "Dapp",
    body: {
      status: {
        name: "GovernanceStatus",
        body: {
          Active: null,
          Inactive: null
        },
        isResult: !1,
        isPrimitive: !1,
        isConvertable: !1
      },
      balance: {
        name: "ReturnNumber",
        isResult: !1,
        isPrimitive: !1,
        isConvertable: !0
      },
      owner: {
        name: "AccountId",
        body: "string | number[]",
        isResult: !1,
        isPrimitive: !0,
        isConvertable: !1
      },
      payee: {
        name: "DappPayee",
        body: {
          Provider: null,
          Dapp: null,
          Any: null
        },
        isResult: !1,
        isPrimitive: !1,
        isConvertable: !1
      }
    },
    isResult: !1,
    isPrimitive: !1,
    isConvertable: !1
  },
  38: {
    name: "Result<Result<UserHistorySummary, Error, LangError",
    body: {
      ok: {
        name: "Result<UserHistorySummary, Error",
        body: {
          ok: {
            name: "UserHistorySummary",
            body: {
              correct: {
                name: "number",
                isResult: !1,
                isPrimitive: !0,
                isConvertable: !1
              },
              incorrect: {
                name: "number",
                isResult: !1,
                isPrimitive: !0,
                isConvertable: !1
              },
              score: {
                name: "number",
                isResult: !1,
                isPrimitive: !0,
                isConvertable: !1
              }
            },
            isResult: !1,
            isPrimitive: !1,
            isConvertable: !1
          },
          err: {
            name: "Error",
            body: {
              NotAuthorised: null,
              TransferFailed: null,
              SetCodeHashFailed: null,
              InvalidDestination: null,
              UnknownMessage: null,
              ProviderAccountExists: null,
              ProviderExists: null,
              ProviderAccountDoesNotExist: null,
              ProviderDoesNotExist: null,
              ProviderInsufficientFunds: null,
              ProviderInactive: null,
              ProviderUrlUsed: null,
              DappExists: null,
              DappDoesNotExist: null,
              DappInactive: null,
              DappInsufficientFunds: null,
              CaptchaDataDoesNotExist: null,
              CommitDoesNotExist: null,
              DappUserDoesNotExist: null,
              NoActiveProviders: null,
              DatasetIdSolutionsSame: null,
              CodeNotFound: null,
              Unknown: null,
              InvalidContract: null,
              InvalidPayee: null,
              InvalidCaptchaStatus: null,
              NoCorrectCaptcha: null,
              NotEnoughActiveProviders: null,
              ProviderFeeTooHigh: null,
              CommitAlreadyExists: null,
              NotAuthor: null,
              Math: null
            },
            isResult: !1,
            isPrimitive: !1,
            isConvertable: !1
          }
        },
        isResult: !0,
        isPrimitive: !1,
        isConvertable: !1
      },
      err: {
        name: "LangError",
        body: {
          CouldNotReadInput: null
        },
        isResult: !1,
        isPrimitive: !1,
        isConvertable: !1
      }
    },
    isResult: !0,
    isPrimitive: !1,
    isConvertable: !1
  },
  39: {
    name: "Result<UserHistorySummary, Error",
    body: {
      ok: {
        name: "UserHistorySummary",
        body: {
          correct: {
            name: "number",
            isResult: !1,
            isPrimitive: !0,
            isConvertable: !1
          },
          incorrect: {
            name: "number",
            isResult: !1,
            isPrimitive: !0,
            isConvertable: !1
          },
          score: {
            name: "number",
            isResult: !1,
            isPrimitive: !0,
            isConvertable: !1
          }
        },
        isResult: !1,
        isPrimitive: !1,
        isConvertable: !1
      },
      err: {
        name: "Error",
        body: {
          NotAuthorised: null,
          TransferFailed: null,
          SetCodeHashFailed: null,
          InvalidDestination: null,
          UnknownMessage: null,
          ProviderAccountExists: null,
          ProviderExists: null,
          ProviderAccountDoesNotExist: null,
          ProviderDoesNotExist: null,
          ProviderInsufficientFunds: null,
          ProviderInactive: null,
          ProviderUrlUsed: null,
          DappExists: null,
          DappDoesNotExist: null,
          DappInactive: null,
          DappInsufficientFunds: null,
          CaptchaDataDoesNotExist: null,
          CommitDoesNotExist: null,
          DappUserDoesNotExist: null,
          NoActiveProviders: null,
          DatasetIdSolutionsSame: null,
          CodeNotFound: null,
          Unknown: null,
          InvalidContract: null,
          InvalidPayee: null,
          InvalidCaptchaStatus: null,
          NoCorrectCaptcha: null,
          NotEnoughActiveProviders: null,
          ProviderFeeTooHigh: null,
          CommitAlreadyExists: null,
          NotAuthor: null,
          Math: null
        },
        isResult: !1,
        isPrimitive: !1,
        isConvertable: !1
      }
    },
    isResult: !0,
    isPrimitive: !1,
    isConvertable: !1
  },
  40: {
    name: "UserHistorySummary",
    body: {
      correct: {
        name: "number",
        isResult: !1,
        isPrimitive: !0,
        isConvertable: !1
      },
      incorrect: {
        name: "number",
        isResult: !1,
        isPrimitive: !0,
        isConvertable: !1
      },
      score: {
        name: "number",
        isResult: !1,
        isPrimitive: !0,
        isConvertable: !1
      }
    },
    isResult: !1,
    isPrimitive: !1,
    isConvertable: !1
  },
  41: {
    name: "Commit",
    body: {
      id: {
        name: "Hash",
        body: "string | number[]",
        isResult: !1,
        isPrimitive: !0,
        isConvertable: !1
      },
      userAccount: {
        name: "AccountId",
        body: "string | number[]",
        isResult: !1,
        isPrimitive: !0,
        isConvertable: !1
      },
      datasetId: {
        name: "Hash",
        body: "string | number[]",
        isResult: !1,
        isPrimitive: !0,
        isConvertable: !1
      },
      status: {
        name: "CaptchaStatus",
        body: {
          Pending: null,
          Approved: null,
          Disapproved: null
        },
        isResult: !1,
        isPrimitive: !1,
        isConvertable: !1
      },
      dappContract: {
        name: "AccountId",
        body: "string | number[]",
        isResult: !1,
        isPrimitive: !0,
        isConvertable: !1
      },
      providerAccount: {
        name: "AccountId",
        body: "string | number[]",
        isResult: !1,
        isPrimitive: !0,
        isConvertable: !1
      },
      requestedAt: {
        name: "number",
        isResult: !1,
        isPrimitive: !0,
        isConvertable: !1
      },
      completedAt: {
        name: "number",
        isResult: !1,
        isPrimitive: !0,
        isConvertable: !1
      },
      userSignature: {
        name: "Array",
        body: {
          0: {
            name: "number",
            isResult: !1,
            isPrimitive: !0,
            isConvertable: !1
          }
        },
        isResult: !1,
        isPrimitive: !1,
        isConvertable: !1
      }
    },
    isResult: !1,
    isPrimitive: !1,
    isConvertable: !1
  },
  42: {
    name: "CaptchaStatus",
    body: {
      Pending: null,
      Approved: null,
      Disapproved: null
    },
    isResult: !1,
    isPrimitive: !1,
    isConvertable: !1
  },
  43: {
    name: "Array",
    body: {
      0: {
        name: "number",
        isResult: !1,
        isPrimitive: !0,
        isConvertable: !1
      }
    },
    isResult: !1,
    isPrimitive: !1,
    isConvertable: !1
  },
  44: {
    name: "Array",
    body: {
      0: {
        name: "Commit",
        body: {
          id: {
            name: "Hash",
            body: "string | number[]",
            isResult: !1,
            isPrimitive: !0,
            isConvertable: !1
          },
          userAccount: {
            name: "AccountId",
            body: "string | number[]",
            isResult: !1,
            isPrimitive: !0,
            isConvertable: !1
          },
          datasetId: {
            name: "Hash",
            body: "string | number[]",
            isResult: !1,
            isPrimitive: !0,
            isConvertable: !1
          },
          status: {
            name: "CaptchaStatus",
            body: {
              Pending: null,
              Approved: null,
              Disapproved: null
            },
            isResult: !1,
            isPrimitive: !1,
            isConvertable: !1
          },
          dappContract: {
            name: "AccountId",
            body: "string | number[]",
            isResult: !1,
            isPrimitive: !0,
            isConvertable: !1
          },
          providerAccount: {
            name: "AccountId",
            body: "string | number[]",
            isResult: !1,
            isPrimitive: !0,
            isConvertable: !1
          },
          requestedAt: {
            name: "number",
            isResult: !1,
            isPrimitive: !0,
            isConvertable: !1
          },
          completedAt: {
            name: "number",
            isResult: !1,
            isPrimitive: !0,
            isConvertable: !1
          },
          userSignature: {
            name: "Array",
            body: {
              0: {
                name: "number",
                isResult: !1,
                isPrimitive: !0,
                isConvertable: !1
              }
            },
            isResult: !1,
            isPrimitive: !1,
            isConvertable: !1
          }
        },
        isResult: !1,
        isPrimitive: !1,
        isConvertable: !1
      }
    },
    isResult: !1,
    isPrimitive: !1,
    isConvertable: !1
  },
  45: {
    name: "Result<Result<boolean, Error, LangError",
    body: {
      ok: {
        name: "Result<boolean, Error",
        body: {
          ok: {
            name: "boolean",
            isResult: !1,
            isPrimitive: !0,
            isConvertable: !1
          },
          err: {
            name: "Error",
            body: {
              NotAuthorised: null,
              TransferFailed: null,
              SetCodeHashFailed: null,
              InvalidDestination: null,
              UnknownMessage: null,
              ProviderAccountExists: null,
              ProviderExists: null,
              ProviderAccountDoesNotExist: null,
              ProviderDoesNotExist: null,
              ProviderInsufficientFunds: null,
              ProviderInactive: null,
              ProviderUrlUsed: null,
              DappExists: null,
              DappDoesNotExist: null,
              DappInactive: null,
              DappInsufficientFunds: null,
              CaptchaDataDoesNotExist: null,
              CommitDoesNotExist: null,
              DappUserDoesNotExist: null,
              NoActiveProviders: null,
              DatasetIdSolutionsSame: null,
              CodeNotFound: null,
              Unknown: null,
              InvalidContract: null,
              InvalidPayee: null,
              InvalidCaptchaStatus: null,
              NoCorrectCaptcha: null,
              NotEnoughActiveProviders: null,
              ProviderFeeTooHigh: null,
              CommitAlreadyExists: null,
              NotAuthor: null,
              Math: null
            },
            isResult: !1,
            isPrimitive: !1,
            isConvertable: !1
          }
        },
        isResult: !0,
        isPrimitive: !1,
        isConvertable: !1
      },
      err: {
        name: "LangError",
        body: {
          CouldNotReadInput: null
        },
        isResult: !1,
        isPrimitive: !1,
        isConvertable: !1
      }
    },
    isResult: !0,
    isPrimitive: !1,
    isConvertable: !1
  },
  46: {
    name: "Result<boolean, Error",
    body: {
      ok: {
        name: "boolean",
        isResult: !1,
        isPrimitive: !0,
        isConvertable: !1
      },
      err: {
        name: "Error",
        body: {
          NotAuthorised: null,
          TransferFailed: null,
          SetCodeHashFailed: null,
          InvalidDestination: null,
          UnknownMessage: null,
          ProviderAccountExists: null,
          ProviderExists: null,
          ProviderAccountDoesNotExist: null,
          ProviderDoesNotExist: null,
          ProviderInsufficientFunds: null,
          ProviderInactive: null,
          ProviderUrlUsed: null,
          DappExists: null,
          DappDoesNotExist: null,
          DappInactive: null,
          DappInsufficientFunds: null,
          CaptchaDataDoesNotExist: null,
          CommitDoesNotExist: null,
          DappUserDoesNotExist: null,
          NoActiveProviders: null,
          DatasetIdSolutionsSame: null,
          CodeNotFound: null,
          Unknown: null,
          InvalidContract: null,
          InvalidPayee: null,
          InvalidCaptchaStatus: null,
          NoCorrectCaptcha: null,
          NotEnoughActiveProviders: null,
          ProviderFeeTooHigh: null,
          CommitAlreadyExists: null,
          NotAuthor: null,
          Math: null
        },
        isResult: !1,
        isPrimitive: !1,
        isConvertable: !1
      }
    },
    isResult: !0,
    isPrimitive: !1,
    isConvertable: !1
  },
  47: {
    name: "boolean",
    isResult: !1,
    isPrimitive: !0,
    isConvertable: !1
  },
  48: {
    name: "Result<Result<LastCorrectCaptcha, Error, LangError",
    body: {
      ok: {
        name: "Result<LastCorrectCaptcha, Error",
        body: {
          ok: {
            name: "LastCorrectCaptcha",
            body: {
              before: {
                name: "number",
                isResult: !1,
                isPrimitive: !0,
                isConvertable: !1
              },
              dappContract: {
                name: "AccountId",
                body: "string | number[]",
                isResult: !1,
                isPrimitive: !0,
                isConvertable: !1
              }
            },
            isResult: !1,
            isPrimitive: !1,
            isConvertable: !1
          },
          err: {
            name: "Error",
            body: {
              NotAuthorised: null,
              TransferFailed: null,
              SetCodeHashFailed: null,
              InvalidDestination: null,
              UnknownMessage: null,
              ProviderAccountExists: null,
              ProviderExists: null,
              ProviderAccountDoesNotExist: null,
              ProviderDoesNotExist: null,
              ProviderInsufficientFunds: null,
              ProviderInactive: null,
              ProviderUrlUsed: null,
              DappExists: null,
              DappDoesNotExist: null,
              DappInactive: null,
              DappInsufficientFunds: null,
              CaptchaDataDoesNotExist: null,
              CommitDoesNotExist: null,
              DappUserDoesNotExist: null,
              NoActiveProviders: null,
              DatasetIdSolutionsSame: null,
              CodeNotFound: null,
              Unknown: null,
              InvalidContract: null,
              InvalidPayee: null,
              InvalidCaptchaStatus: null,
              NoCorrectCaptcha: null,
              NotEnoughActiveProviders: null,
              ProviderFeeTooHigh: null,
              CommitAlreadyExists: null,
              NotAuthor: null,
              Math: null
            },
            isResult: !1,
            isPrimitive: !1,
            isConvertable: !1
          }
        },
        isResult: !0,
        isPrimitive: !1,
        isConvertable: !1
      },
      err: {
        name: "LangError",
        body: {
          CouldNotReadInput: null
        },
        isResult: !1,
        isPrimitive: !1,
        isConvertable: !1
      }
    },
    isResult: !0,
    isPrimitive: !1,
    isConvertable: !1
  },
  49: {
    name: "Result<LastCorrectCaptcha, Error",
    body: {
      ok: {
        name: "LastCorrectCaptcha",
        body: {
          before: {
            name: "number",
            isResult: !1,
            isPrimitive: !0,
            isConvertable: !1
          },
          dappContract: {
            name: "AccountId",
            body: "string | number[]",
            isResult: !1,
            isPrimitive: !0,
            isConvertable: !1
          }
        },
        isResult: !1,
        isPrimitive: !1,
        isConvertable: !1
      },
      err: {
        name: "Error",
        body: {
          NotAuthorised: null,
          TransferFailed: null,
          SetCodeHashFailed: null,
          InvalidDestination: null,
          UnknownMessage: null,
          ProviderAccountExists: null,
          ProviderExists: null,
          ProviderAccountDoesNotExist: null,
          ProviderDoesNotExist: null,
          ProviderInsufficientFunds: null,
          ProviderInactive: null,
          ProviderUrlUsed: null,
          DappExists: null,
          DappDoesNotExist: null,
          DappInactive: null,
          DappInsufficientFunds: null,
          CaptchaDataDoesNotExist: null,
          CommitDoesNotExist: null,
          DappUserDoesNotExist: null,
          NoActiveProviders: null,
          DatasetIdSolutionsSame: null,
          CodeNotFound: null,
          Unknown: null,
          InvalidContract: null,
          InvalidPayee: null,
          InvalidCaptchaStatus: null,
          NoCorrectCaptcha: null,
          NotEnoughActiveProviders: null,
          ProviderFeeTooHigh: null,
          CommitAlreadyExists: null,
          NotAuthor: null,
          Math: null
        },
        isResult: !1,
        isPrimitive: !1,
        isConvertable: !1
      }
    },
    isResult: !0,
    isPrimitive: !1,
    isConvertable: !1
  },
  50: {
    name: "LastCorrectCaptcha",
    body: {
      before: {
        name: "number",
        isResult: !1,
        isPrimitive: !0,
        isConvertable: !1
      },
      dappContract: {
        name: "AccountId",
        body: "string | number[]",
        isResult: !1,
        isPrimitive: !0,
        isConvertable: !1
      }
    },
    isResult: !1,
    isPrimitive: !1,
    isConvertable: !1
  },
  51: {
    name: "Result<Result<User, Error, LangError",
    body: {
      ok: {
        name: "Result<User, Error",
        body: {
          ok: {
            name: "User",
            body: {
              history: {
                name: "Array",
                body: {
                  0: {
                    name: "Hash",
                    body: "string | number[]",
                    isResult: !1,
                    isPrimitive: !0,
                    isConvertable: !1
                  }
                },
                isResult: !1,
                isPrimitive: !1,
                isConvertable: !1
              }
            },
            isResult: !1,
            isPrimitive: !1,
            isConvertable: !1
          },
          err: {
            name: "Error",
            body: {
              NotAuthorised: null,
              TransferFailed: null,
              SetCodeHashFailed: null,
              InvalidDestination: null,
              UnknownMessage: null,
              ProviderAccountExists: null,
              ProviderExists: null,
              ProviderAccountDoesNotExist: null,
              ProviderDoesNotExist: null,
              ProviderInsufficientFunds: null,
              ProviderInactive: null,
              ProviderUrlUsed: null,
              DappExists: null,
              DappDoesNotExist: null,
              DappInactive: null,
              DappInsufficientFunds: null,
              CaptchaDataDoesNotExist: null,
              CommitDoesNotExist: null,
              DappUserDoesNotExist: null,
              NoActiveProviders: null,
              DatasetIdSolutionsSame: null,
              CodeNotFound: null,
              Unknown: null,
              InvalidContract: null,
              InvalidPayee: null,
              InvalidCaptchaStatus: null,
              NoCorrectCaptcha: null,
              NotEnoughActiveProviders: null,
              ProviderFeeTooHigh: null,
              CommitAlreadyExists: null,
              NotAuthor: null,
              Math: null
            },
            isResult: !1,
            isPrimitive: !1,
            isConvertable: !1
          }
        },
        isResult: !0,
        isPrimitive: !1,
        isConvertable: !1
      },
      err: {
        name: "LangError",
        body: {
          CouldNotReadInput: null
        },
        isResult: !1,
        isPrimitive: !1,
        isConvertable: !1
      }
    },
    isResult: !0,
    isPrimitive: !1,
    isConvertable: !1
  },
  52: {
    name: "Result<User, Error",
    body: {
      ok: {
        name: "User",
        body: {
          history: {
            name: "Array",
            body: {
              0: {
                name: "Hash",
                body: "string | number[]",
                isResult: !1,
                isPrimitive: !0,
                isConvertable: !1
              }
            },
            isResult: !1,
            isPrimitive: !1,
            isConvertable: !1
          }
        },
        isResult: !1,
        isPrimitive: !1,
        isConvertable: !1
      },
      err: {
        name: "Error",
        body: {
          NotAuthorised: null,
          TransferFailed: null,
          SetCodeHashFailed: null,
          InvalidDestination: null,
          UnknownMessage: null,
          ProviderAccountExists: null,
          ProviderExists: null,
          ProviderAccountDoesNotExist: null,
          ProviderDoesNotExist: null,
          ProviderInsufficientFunds: null,
          ProviderInactive: null,
          ProviderUrlUsed: null,
          DappExists: null,
          DappDoesNotExist: null,
          DappInactive: null,
          DappInsufficientFunds: null,
          CaptchaDataDoesNotExist: null,
          CommitDoesNotExist: null,
          DappUserDoesNotExist: null,
          NoActiveProviders: null,
          DatasetIdSolutionsSame: null,
          CodeNotFound: null,
          Unknown: null,
          InvalidContract: null,
          InvalidPayee: null,
          InvalidCaptchaStatus: null,
          NoCorrectCaptcha: null,
          NotEnoughActiveProviders: null,
          ProviderFeeTooHigh: null,
          CommitAlreadyExists: null,
          NotAuthor: null,
          Math: null
        },
        isResult: !1,
        isPrimitive: !1,
        isConvertable: !1
      }
    },
    isResult: !0,
    isPrimitive: !1,
    isConvertable: !1
  },
  53: {
    name: "User",
    body: {
      history: {
        name: "Array",
        body: {
          0: {
            name: "Hash",
            body: "string | number[]",
            isResult: !1,
            isPrimitive: !0,
            isConvertable: !1
          }
        },
        isResult: !1,
        isPrimitive: !1,
        isConvertable: !1
      }
    },
    isResult: !1,
    isPrimitive: !1,
    isConvertable: !1
  },
  54: {
    name: "Result<Result<Commit, Error, LangError",
    body: {
      ok: {
        name: "Result<Commit, Error",
        body: {
          ok: {
            name: "Commit",
            body: {
              id: {
                name: "Hash",
                body: "string | number[]",
                isResult: !1,
                isPrimitive: !0,
                isConvertable: !1
              },
              userAccount: {
                name: "AccountId",
                body: "string | number[]",
                isResult: !1,
                isPrimitive: !0,
                isConvertable: !1
              },
              datasetId: {
                name: "Hash",
                body: "string | number[]",
                isResult: !1,
                isPrimitive: !0,
                isConvertable: !1
              },
              status: {
                name: "CaptchaStatus",
                body: {
                  Pending: null,
                  Approved: null,
                  Disapproved: null
                },
                isResult: !1,
                isPrimitive: !1,
                isConvertable: !1
              },
              dappContract: {
                name: "AccountId",
                body: "string | number[]",
                isResult: !1,
                isPrimitive: !0,
                isConvertable: !1
              },
              providerAccount: {
                name: "AccountId",
                body: "string | number[]",
                isResult: !1,
                isPrimitive: !0,
                isConvertable: !1
              },
              requestedAt: {
                name: "number",
                isResult: !1,
                isPrimitive: !0,
                isConvertable: !1
              },
              completedAt: {
                name: "number",
                isResult: !1,
                isPrimitive: !0,
                isConvertable: !1
              },
              userSignature: {
                name: "Array",
                body: {
                  0: {
                    name: "number",
                    isResult: !1,
                    isPrimitive: !0,
                    isConvertable: !1
                  }
                },
                isResult: !1,
                isPrimitive: !1,
                isConvertable: !1
              }
            },
            isResult: !1,
            isPrimitive: !1,
            isConvertable: !1
          },
          err: {
            name: "Error",
            body: {
              NotAuthorised: null,
              TransferFailed: null,
              SetCodeHashFailed: null,
              InvalidDestination: null,
              UnknownMessage: null,
              ProviderAccountExists: null,
              ProviderExists: null,
              ProviderAccountDoesNotExist: null,
              ProviderDoesNotExist: null,
              ProviderInsufficientFunds: null,
              ProviderInactive: null,
              ProviderUrlUsed: null,
              DappExists: null,
              DappDoesNotExist: null,
              DappInactive: null,
              DappInsufficientFunds: null,
              CaptchaDataDoesNotExist: null,
              CommitDoesNotExist: null,
              DappUserDoesNotExist: null,
              NoActiveProviders: null,
              DatasetIdSolutionsSame: null,
              CodeNotFound: null,
              Unknown: null,
              InvalidContract: null,
              InvalidPayee: null,
              InvalidCaptchaStatus: null,
              NoCorrectCaptcha: null,
              NotEnoughActiveProviders: null,
              ProviderFeeTooHigh: null,
              CommitAlreadyExists: null,
              NotAuthor: null,
              Math: null
            },
            isResult: !1,
            isPrimitive: !1,
            isConvertable: !1
          }
        },
        isResult: !0,
        isPrimitive: !1,
        isConvertable: !1
      },
      err: {
        name: "LangError",
        body: {
          CouldNotReadInput: null
        },
        isResult: !1,
        isPrimitive: !1,
        isConvertable: !1
      }
    },
    isResult: !0,
    isPrimitive: !1,
    isConvertable: !1
  },
  55: {
    name: "Result<Commit, Error",
    body: {
      ok: {
        name: "Commit",
        body: {
          id: {
            name: "Hash",
            body: "string | number[]",
            isResult: !1,
            isPrimitive: !0,
            isConvertable: !1
          },
          userAccount: {
            name: "AccountId",
            body: "string | number[]",
            isResult: !1,
            isPrimitive: !0,
            isConvertable: !1
          },
          datasetId: {
            name: "Hash",
            body: "string | number[]",
            isResult: !1,
            isPrimitive: !0,
            isConvertable: !1
          },
          status: {
            name: "CaptchaStatus",
            body: {
              Pending: null,
              Approved: null,
              Disapproved: null
            },
            isResult: !1,
            isPrimitive: !1,
            isConvertable: !1
          },
          dappContract: {
            name: "AccountId",
            body: "string | number[]",
            isResult: !1,
            isPrimitive: !0,
            isConvertable: !1
          },
          providerAccount: {
            name: "AccountId",
            body: "string | number[]",
            isResult: !1,
            isPrimitive: !0,
            isConvertable: !1
          },
          requestedAt: {
            name: "number",
            isResult: !1,
            isPrimitive: !0,
            isConvertable: !1
          },
          completedAt: {
            name: "number",
            isResult: !1,
            isPrimitive: !0,
            isConvertable: !1
          },
          userSignature: {
            name: "Array",
            body: {
              0: {
                name: "number",
                isResult: !1,
                isPrimitive: !0,
                isConvertable: !1
              }
            },
            isResult: !1,
            isPrimitive: !1,
            isConvertable: !1
          }
        },
        isResult: !1,
        isPrimitive: !1,
        isConvertable: !1
      },
      err: {
        name: "Error",
        body: {
          NotAuthorised: null,
          TransferFailed: null,
          SetCodeHashFailed: null,
          InvalidDestination: null,
          UnknownMessage: null,
          ProviderAccountExists: null,
          ProviderExists: null,
          ProviderAccountDoesNotExist: null,
          ProviderDoesNotExist: null,
          ProviderInsufficientFunds: null,
          ProviderInactive: null,
          ProviderUrlUsed: null,
          DappExists: null,
          DappDoesNotExist: null,
          DappInactive: null,
          DappInsufficientFunds: null,
          CaptchaDataDoesNotExist: null,
          CommitDoesNotExist: null,
          DappUserDoesNotExist: null,
          NoActiveProviders: null,
          DatasetIdSolutionsSame: null,
          CodeNotFound: null,
          Unknown: null,
          InvalidContract: null,
          InvalidPayee: null,
          InvalidCaptchaStatus: null,
          NoCorrectCaptcha: null,
          NotEnoughActiveProviders: null,
          ProviderFeeTooHigh: null,
          CommitAlreadyExists: null,
          NotAuthor: null,
          Math: null
        },
        isResult: !1,
        isPrimitive: !1,
        isConvertable: !1
      }
    },
    isResult: !0,
    isPrimitive: !1,
    isConvertable: !1
  },
  56: {
    name: "Result<Result<Array, Error, LangError",
    body: {
      ok: {
        name: "Result<Array, Error",
        body: {
          ok: {
            name: "Array",
            body: {
              0: {
                name: "Provider",
                body: {
                  status: {
                    name: "GovernanceStatus",
                    body: {
                      Active: null,
                      Inactive: null
                    },
                    isResult: !1,
                    isPrimitive: !1,
                    isConvertable: !1
                  },
                  balance: {
                    name: "ReturnNumber",
                    isResult: !1,
                    isPrimitive: !1,
                    isConvertable: !0
                  },
                  fee: {
                    name: "number",
                    isResult: !1,
                    isPrimitive: !0,
                    isConvertable: !1
                  },
                  payee: {
                    name: "Payee",
                    body: {
                      Provider: null,
                      Dapp: null
                    },
                    isResult: !1,
                    isPrimitive: !1,
                    isConvertable: !1
                  },
                  url: {
                    name: "Array",
                    body: {
                      0: {
                        name: "number",
                        isResult: !1,
                        isPrimitive: !0,
                        isConvertable: !1
                      }
                    },
                    isResult: !1,
                    isPrimitive: !1,
                    isConvertable: !1
                  },
                  datasetId: {
                    name: "Hash",
                    body: "string | number[]",
                    isResult: !1,
                    isPrimitive: !0,
                    isConvertable: !1
                  },
                  datasetIdContent: {
                    name: "Hash",
                    body: "string | number[]",
                    isResult: !1,
                    isPrimitive: !0,
                    isConvertable: !1
                  }
                },
                isResult: !1,
                isPrimitive: !1,
                isConvertable: !1
              }
            },
            isResult: !1,
            isPrimitive: !1,
            isConvertable: !1
          },
          err: {
            name: "Error",
            body: {
              NotAuthorised: null,
              TransferFailed: null,
              SetCodeHashFailed: null,
              InvalidDestination: null,
              UnknownMessage: null,
              ProviderAccountExists: null,
              ProviderExists: null,
              ProviderAccountDoesNotExist: null,
              ProviderDoesNotExist: null,
              ProviderInsufficientFunds: null,
              ProviderInactive: null,
              ProviderUrlUsed: null,
              DappExists: null,
              DappDoesNotExist: null,
              DappInactive: null,
              DappInsufficientFunds: null,
              CaptchaDataDoesNotExist: null,
              CommitDoesNotExist: null,
              DappUserDoesNotExist: null,
              NoActiveProviders: null,
              DatasetIdSolutionsSame: null,
              CodeNotFound: null,
              Unknown: null,
              InvalidContract: null,
              InvalidPayee: null,
              InvalidCaptchaStatus: null,
              NoCorrectCaptcha: null,
              NotEnoughActiveProviders: null,
              ProviderFeeTooHigh: null,
              CommitAlreadyExists: null,
              NotAuthor: null,
              Math: null
            },
            isResult: !1,
            isPrimitive: !1,
            isConvertable: !1
          }
        },
        isResult: !0,
        isPrimitive: !1,
        isConvertable: !1
      },
      err: {
        name: "LangError",
        body: {
          CouldNotReadInput: null
        },
        isResult: !1,
        isPrimitive: !1,
        isConvertable: !1
      }
    },
    isResult: !0,
    isPrimitive: !1,
    isConvertable: !1
  },
  57: {
    name: "Result<Array, Error",
    body: {
      ok: {
        name: "Array",
        body: {
          0: {
            name: "Provider",
            body: {
              status: {
                name: "GovernanceStatus",
                body: {
                  Active: null,
                  Inactive: null
                },
                isResult: !1,
                isPrimitive: !1,
                isConvertable: !1
              },
              balance: {
                name: "ReturnNumber",
                isResult: !1,
                isPrimitive: !1,
                isConvertable: !0
              },
              fee: {
                name: "number",
                isResult: !1,
                isPrimitive: !0,
                isConvertable: !1
              },
              payee: {
                name: "Payee",
                body: {
                  Provider: null,
                  Dapp: null
                },
                isResult: !1,
                isPrimitive: !1,
                isConvertable: !1
              },
              url: {
                name: "Array",
                body: {
                  0: {
                    name: "number",
                    isResult: !1,
                    isPrimitive: !0,
                    isConvertable: !1
                  }
                },
                isResult: !1,
                isPrimitive: !1,
                isConvertable: !1
              },
              datasetId: {
                name: "Hash",
                body: "string | number[]",
                isResult: !1,
                isPrimitive: !0,
                isConvertable: !1
              },
              datasetIdContent: {
                name: "Hash",
                body: "string | number[]",
                isResult: !1,
                isPrimitive: !0,
                isConvertable: !1
              }
            },
            isResult: !1,
            isPrimitive: !1,
            isConvertable: !1
          }
        },
        isResult: !1,
        isPrimitive: !1,
        isConvertable: !1
      },
      err: {
        name: "Error",
        body: {
          NotAuthorised: null,
          TransferFailed: null,
          SetCodeHashFailed: null,
          InvalidDestination: null,
          UnknownMessage: null,
          ProviderAccountExists: null,
          ProviderExists: null,
          ProviderAccountDoesNotExist: null,
          ProviderDoesNotExist: null,
          ProviderInsufficientFunds: null,
          ProviderInactive: null,
          ProviderUrlUsed: null,
          DappExists: null,
          DappDoesNotExist: null,
          DappInactive: null,
          DappInsufficientFunds: null,
          CaptchaDataDoesNotExist: null,
          CommitDoesNotExist: null,
          DappUserDoesNotExist: null,
          NoActiveProviders: null,
          DatasetIdSolutionsSame: null,
          CodeNotFound: null,
          Unknown: null,
          InvalidContract: null,
          InvalidPayee: null,
          InvalidCaptchaStatus: null,
          NoCorrectCaptcha: null,
          NotEnoughActiveProviders: null,
          ProviderFeeTooHigh: null,
          CommitAlreadyExists: null,
          NotAuthor: null,
          Math: null
        },
        isResult: !1,
        isPrimitive: !1,
        isConvertable: !1
      }
    },
    isResult: !0,
    isPrimitive: !1,
    isConvertable: !1
  },
  58: {
    name: "Array",
    body: {
      0: {
        name: "Provider",
        body: {
          status: {
            name: "GovernanceStatus",
            body: {
              Active: null,
              Inactive: null
            },
            isResult: !1,
            isPrimitive: !1,
            isConvertable: !1
          },
          balance: {
            name: "ReturnNumber",
            isResult: !1,
            isPrimitive: !1,
            isConvertable: !0
          },
          fee: {
            name: "number",
            isResult: !1,
            isPrimitive: !0,
            isConvertable: !1
          },
          payee: {
            name: "Payee",
            body: {
              Provider: null,
              Dapp: null
            },
            isResult: !1,
            isPrimitive: !1,
            isConvertable: !1
          },
          url: {
            name: "Array",
            body: {
              0: {
                name: "number",
                isResult: !1,
                isPrimitive: !0,
                isConvertable: !1
              }
            },
            isResult: !1,
            isPrimitive: !1,
            isConvertable: !1
          },
          datasetId: {
            name: "Hash",
            body: "string | number[]",
            isResult: !1,
            isPrimitive: !0,
            isConvertable: !1
          },
          datasetIdContent: {
            name: "Hash",
            body: "string | number[]",
            isResult: !1,
            isPrimitive: !0,
            isConvertable: !1
          }
        },
        isResult: !1,
        isPrimitive: !1,
        isConvertable: !1
      }
    },
    isResult: !1,
    isPrimitive: !1,
    isConvertable: !1
  },
  59: {
    name: "Result<Result<RandomProvider, Error, LangError",
    body: {
      ok: {
        name: "Result<RandomProvider, Error",
        body: {
          ok: {
            name: "RandomProvider",
            body: {
              providerAccount: {
                name: "AccountId",
                body: "string | number[]",
                isResult: !1,
                isPrimitive: !0,
                isConvertable: !1
              },
              provider: {
                name: "Provider",
                body: {
                  status: {
                    name: "GovernanceStatus",
                    body: {
                      Active: null,
                      Inactive: null
                    },
                    isResult: !1,
                    isPrimitive: !1,
                    isConvertable: !1
                  },
                  balance: {
                    name: "ReturnNumber",
                    isResult: !1,
                    isPrimitive: !1,
                    isConvertable: !0
                  },
                  fee: {
                    name: "number",
                    isResult: !1,
                    isPrimitive: !0,
                    isConvertable: !1
                  },
                  payee: {
                    name: "Payee",
                    body: {
                      Provider: null,
                      Dapp: null
                    },
                    isResult: !1,
                    isPrimitive: !1,
                    isConvertable: !1
                  },
                  url: {
                    name: "Array",
                    body: {
                      0: {
                        name: "number",
                        isResult: !1,
                        isPrimitive: !0,
                        isConvertable: !1
                      }
                    },
                    isResult: !1,
                    isPrimitive: !1,
                    isConvertable: !1
                  },
                  datasetId: {
                    name: "Hash",
                    body: "string | number[]",
                    isResult: !1,
                    isPrimitive: !0,
                    isConvertable: !1
                  },
                  datasetIdContent: {
                    name: "Hash",
                    body: "string | number[]",
                    isResult: !1,
                    isPrimitive: !0,
                    isConvertable: !1
                  }
                },
                isResult: !1,
                isPrimitive: !1,
                isConvertable: !1
              },
              blockNumber: {
                name: "number",
                isResult: !1,
                isPrimitive: !0,
                isConvertable: !1
              }
            },
            isResult: !1,
            isPrimitive: !1,
            isConvertable: !1
          },
          err: {
            name: "Error",
            body: {
              NotAuthorised: null,
              TransferFailed: null,
              SetCodeHashFailed: null,
              InvalidDestination: null,
              UnknownMessage: null,
              ProviderAccountExists: null,
              ProviderExists: null,
              ProviderAccountDoesNotExist: null,
              ProviderDoesNotExist: null,
              ProviderInsufficientFunds: null,
              ProviderInactive: null,
              ProviderUrlUsed: null,
              DappExists: null,
              DappDoesNotExist: null,
              DappInactive: null,
              DappInsufficientFunds: null,
              CaptchaDataDoesNotExist: null,
              CommitDoesNotExist: null,
              DappUserDoesNotExist: null,
              NoActiveProviders: null,
              DatasetIdSolutionsSame: null,
              CodeNotFound: null,
              Unknown: null,
              InvalidContract: null,
              InvalidPayee: null,
              InvalidCaptchaStatus: null,
              NoCorrectCaptcha: null,
              NotEnoughActiveProviders: null,
              ProviderFeeTooHigh: null,
              CommitAlreadyExists: null,
              NotAuthor: null,
              Math: null
            },
            isResult: !1,
            isPrimitive: !1,
            isConvertable: !1
          }
        },
        isResult: !0,
        isPrimitive: !1,
        isConvertable: !1
      },
      err: {
        name: "LangError",
        body: {
          CouldNotReadInput: null
        },
        isResult: !1,
        isPrimitive: !1,
        isConvertable: !1
      }
    },
    isResult: !0,
    isPrimitive: !1,
    isConvertable: !1
  },
  60: {
    name: "Result<RandomProvider, Error",
    body: {
      ok: {
        name: "RandomProvider",
        body: {
          providerAccount: {
            name: "AccountId",
            body: "string | number[]",
            isResult: !1,
            isPrimitive: !0,
            isConvertable: !1
          },
          provider: {
            name: "Provider",
            body: {
              status: {
                name: "GovernanceStatus",
                body: {
                  Active: null,
                  Inactive: null
                },
                isResult: !1,
                isPrimitive: !1,
                isConvertable: !1
              },
              balance: {
                name: "ReturnNumber",
                isResult: !1,
                isPrimitive: !1,
                isConvertable: !0
              },
              fee: {
                name: "number",
                isResult: !1,
                isPrimitive: !0,
                isConvertable: !1
              },
              payee: {
                name: "Payee",
                body: {
                  Provider: null,
                  Dapp: null
                },
                isResult: !1,
                isPrimitive: !1,
                isConvertable: !1
              },
              url: {
                name: "Array",
                body: {
                  0: {
                    name: "number",
                    isResult: !1,
                    isPrimitive: !0,
                    isConvertable: !1
                  }
                },
                isResult: !1,
                isPrimitive: !1,
                isConvertable: !1
              },
              datasetId: {
                name: "Hash",
                body: "string | number[]",
                isResult: !1,
                isPrimitive: !0,
                isConvertable: !1
              },
              datasetIdContent: {
                name: "Hash",
                body: "string | number[]",
                isResult: !1,
                isPrimitive: !0,
                isConvertable: !1
              }
            },
            isResult: !1,
            isPrimitive: !1,
            isConvertable: !1
          },
          blockNumber: {
            name: "number",
            isResult: !1,
            isPrimitive: !0,
            isConvertable: !1
          }
        },
        isResult: !1,
        isPrimitive: !1,
        isConvertable: !1
      },
      err: {
        name: "Error",
        body: {
          NotAuthorised: null,
          TransferFailed: null,
          SetCodeHashFailed: null,
          InvalidDestination: null,
          UnknownMessage: null,
          ProviderAccountExists: null,
          ProviderExists: null,
          ProviderAccountDoesNotExist: null,
          ProviderDoesNotExist: null,
          ProviderInsufficientFunds: null,
          ProviderInactive: null,
          ProviderUrlUsed: null,
          DappExists: null,
          DappDoesNotExist: null,
          DappInactive: null,
          DappInsufficientFunds: null,
          CaptchaDataDoesNotExist: null,
          CommitDoesNotExist: null,
          DappUserDoesNotExist: null,
          NoActiveProviders: null,
          DatasetIdSolutionsSame: null,
          CodeNotFound: null,
          Unknown: null,
          InvalidContract: null,
          InvalidPayee: null,
          InvalidCaptchaStatus: null,
          NoCorrectCaptcha: null,
          NotEnoughActiveProviders: null,
          ProviderFeeTooHigh: null,
          CommitAlreadyExists: null,
          NotAuthor: null,
          Math: null
        },
        isResult: !1,
        isPrimitive: !1,
        isConvertable: !1
      }
    },
    isResult: !0,
    isPrimitive: !1,
    isConvertable: !1
  },
  61: {
    name: "RandomProvider",
    body: {
      providerAccount: {
        name: "AccountId",
        body: "string | number[]",
        isResult: !1,
        isPrimitive: !0,
        isConvertable: !1
      },
      provider: {
        name: "Provider",
        body: {
          status: {
            name: "GovernanceStatus",
            body: {
              Active: null,
              Inactive: null
            },
            isResult: !1,
            isPrimitive: !1,
            isConvertable: !1
          },
          balance: {
            name: "ReturnNumber",
            isResult: !1,
            isPrimitive: !1,
            isConvertable: !0
          },
          fee: {
            name: "number",
            isResult: !1,
            isPrimitive: !0,
            isConvertable: !1
          },
          payee: {
            name: "Payee",
            body: {
              Provider: null,
              Dapp: null
            },
            isResult: !1,
            isPrimitive: !1,
            isConvertable: !1
          },
          url: {
            name: "Array",
            body: {
              0: {
                name: "number",
                isResult: !1,
                isPrimitive: !0,
                isConvertable: !1
              }
            },
            isResult: !1,
            isPrimitive: !1,
            isConvertable: !1
          },
          datasetId: {
            name: "Hash",
            body: "string | number[]",
            isResult: !1,
            isPrimitive: !0,
            isConvertable: !1
          },
          datasetIdContent: {
            name: "Hash",
            body: "string | number[]",
            isResult: !1,
            isPrimitive: !0,
            isConvertable: !1
          }
        },
        isResult: !1,
        isPrimitive: !1,
        isConvertable: !1
      },
      blockNumber: {
        name: "number",
        isResult: !1,
        isPrimitive: !0,
        isConvertable: !1
      }
    },
    isResult: !1,
    isPrimitive: !1,
    isConvertable: !1
  },
  62: {
    name: "Result<Result<Array, Error, LangError",
    body: {
      ok: {
        name: "Result<Array, Error",
        body: {
          ok: {
            name: "Array",
            body: {
              0: {
                name: "AccountId",
                body: "string | number[]",
                isResult: !1,
                isPrimitive: !0,
                isConvertable: !1
              }
            },
            isResult: !1,
            isPrimitive: !1,
            isConvertable: !1
          },
          err: {
            name: "Error",
            body: {
              NotAuthorised: null,
              TransferFailed: null,
              SetCodeHashFailed: null,
              InvalidDestination: null,
              UnknownMessage: null,
              ProviderAccountExists: null,
              ProviderExists: null,
              ProviderAccountDoesNotExist: null,
              ProviderDoesNotExist: null,
              ProviderInsufficientFunds: null,
              ProviderInactive: null,
              ProviderUrlUsed: null,
              DappExists: null,
              DappDoesNotExist: null,
              DappInactive: null,
              DappInsufficientFunds: null,
              CaptchaDataDoesNotExist: null,
              CommitDoesNotExist: null,
              DappUserDoesNotExist: null,
              NoActiveProviders: null,
              DatasetIdSolutionsSame: null,
              CodeNotFound: null,
              Unknown: null,
              InvalidContract: null,
              InvalidPayee: null,
              InvalidCaptchaStatus: null,
              NoCorrectCaptcha: null,
              NotEnoughActiveProviders: null,
              ProviderFeeTooHigh: null,
              CommitAlreadyExists: null,
              NotAuthor: null,
              Math: null
            },
            isResult: !1,
            isPrimitive: !1,
            isConvertable: !1
          }
        },
        isResult: !0,
        isPrimitive: !1,
        isConvertable: !1
      },
      err: {
        name: "LangError",
        body: {
          CouldNotReadInput: null
        },
        isResult: !1,
        isPrimitive: !1,
        isConvertable: !1
      }
    },
    isResult: !0,
    isPrimitive: !1,
    isConvertable: !1
  },
  63: {
    name: "Result<Array, Error",
    body: {
      ok: {
        name: "Array",
        body: {
          0: {
            name: "AccountId",
            body: "string | number[]",
            isResult: !1,
            isPrimitive: !0,
            isConvertable: !1
          }
        },
        isResult: !1,
        isPrimitive: !1,
        isConvertable: !1
      },
      err: {
        name: "Error",
        body: {
          NotAuthorised: null,
          TransferFailed: null,
          SetCodeHashFailed: null,
          InvalidDestination: null,
          UnknownMessage: null,
          ProviderAccountExists: null,
          ProviderExists: null,
          ProviderAccountDoesNotExist: null,
          ProviderDoesNotExist: null,
          ProviderInsufficientFunds: null,
          ProviderInactive: null,
          ProviderUrlUsed: null,
          DappExists: null,
          DappDoesNotExist: null,
          DappInactive: null,
          DappInsufficientFunds: null,
          CaptchaDataDoesNotExist: null,
          CommitDoesNotExist: null,
          DappUserDoesNotExist: null,
          NoActiveProviders: null,
          DatasetIdSolutionsSame: null,
          CodeNotFound: null,
          Unknown: null,
          InvalidContract: null,
          InvalidPayee: null,
          InvalidCaptchaStatus: null,
          NoCorrectCaptcha: null,
          NotEnoughActiveProviders: null,
          ProviderFeeTooHigh: null,
          CommitAlreadyExists: null,
          NotAuthor: null,
          Math: null
        },
        isResult: !1,
        isPrimitive: !1,
        isConvertable: !1
      }
    },
    isResult: !0,
    isPrimitive: !1,
    isConvertable: !1
  }
}, ie = {};
let yv = class {
  constructor(e, t, r) {
    this.__apiPromise = e, this.__nativeContract = t, this.__keyringPair = r, this.__callerAddress = r.address;
  }
  getGitCommitId(e) {
    return N.queryOkJSON(this.__apiPromise, this.__nativeContract, this.__callerAddress, "getGitCommitId", [], e, (t) => N.handleReturnType(t, $(16, ee)));
  }
  getAdmin(e) {
    return N.queryOkJSON(this.__apiPromise, this.__nativeContract, this.__callerAddress, "getAdmin", [], e, (t) => N.handleReturnType(t, $(18, ee)));
  }
  getPayees(e) {
    return N.queryOkJSON(this.__apiPromise, this.__nativeContract, this.__callerAddress, "getPayees", [], e, (t) => N.handleReturnType(t, $(19, ee)));
  }
  getDappPayees(e) {
    return N.queryOkJSON(this.__apiPromise, this.__nativeContract, this.__callerAddress, "getDappPayees", [], e, (t) => N.handleReturnType(t, $(22, ee)));
  }
  getStatuses(e) {
    return N.queryOkJSON(this.__apiPromise, this.__nativeContract, this.__callerAddress, "getStatuses", [], e, (t) => N.handleReturnType(t, $(25, ee)));
  }
  getProviderStakeThreshold(e) {
    return N.queryOkJSON(this.__apiPromise, this.__nativeContract, this.__callerAddress, "getProviderStakeThreshold", [], e, (t) => N.handleReturnType(t, $(28, ee)));
  }
  getDappStakeThreshold(e) {
    return N.queryOkJSON(this.__apiPromise, this.__nativeContract, this.__callerAddress, "getDappStakeThreshold", [], e, (t) => N.handleReturnType(t, $(28, ee)));
  }
  getMaxProviderFee(e) {
    return N.queryOkJSON(this.__apiPromise, this.__nativeContract, this.__callerAddress, "getMaxProviderFee", [], e, (t) => N.handleReturnType(t, $(29, ee)));
  }
  getMinNumActiveProviders(e) {
    return N.queryOkJSON(this.__apiPromise, this.__nativeContract, this.__callerAddress, "getMinNumActiveProviders", [], e, (t) => N.handleReturnType(t, $(30, ee)));
  }
  getBlockTime(e) {
    return N.queryOkJSON(this.__apiPromise, this.__nativeContract, this.__callerAddress, "getBlockTime", [], e, (t) => N.handleReturnType(t, $(30, ee)));
  }
  getMaxUserHistoryAgeSeconds(e) {
    return N.queryOkJSON(this.__apiPromise, this.__nativeContract, this.__callerAddress, "getMaxUserHistoryAgeSeconds", [], e, (t) => N.handleReturnType(t, $(29, ee)));
  }
  getMaxUserHistoryLen(e) {
    return N.queryOkJSON(this.__apiPromise, this.__nativeContract, this.__callerAddress, "getMaxUserHistoryLen", [], e, (t) => N.handleReturnType(t, $(30, ee)));
  }
  getMaxUserHistoryAgeBlocks(e) {
    return N.queryOkJSON(this.__apiPromise, this.__nativeContract, this.__callerAddress, "getMaxUserHistoryAgeBlocks", [], e, (t) => N.handleReturnType(t, $(29, ee)));
  }
  providerRegister(e, t, r, i) {
    return N.txSignAndSend(this.__apiPromise, this.__nativeContract, this.__keyringPair, "providerRegister", (s) => re(s, this.__nativeContract, ie), [e, t, r], i);
  }
  providerUpdate(e, t, r, i) {
    return N.txSignAndSend(this.__apiPromise, this.__nativeContract, this.__keyringPair, "providerUpdate", (s) => re(s, this.__nativeContract, ie), [e, t, r], i);
  }
  providerDeactivate(e) {
    return N.txSignAndSend(this.__apiPromise, this.__nativeContract, this.__keyringPair, "providerDeactivate", (t) => re(t, this.__nativeContract, ie), [], e);
  }
  providerDeregister(e) {
    return N.txSignAndSend(this.__apiPromise, this.__nativeContract, this.__keyringPair, "providerDeregister", (t) => re(t, this.__nativeContract, ie), [], e);
  }
  getProvider(e, t) {
    return N.queryOkJSON(this.__apiPromise, this.__nativeContract, this.__callerAddress, "getProvider", [e], t, (r) => N.handleReturnType(r, $(32, ee)));
  }
  providerFund(e) {
    return N.txSignAndSend(this.__apiPromise, this.__nativeContract, this.__keyringPair, "providerFund", (t) => re(t, this.__nativeContract, ie), [], e);
  }
  providerSetDataset(e, t, r) {
    return N.txSignAndSend(this.__apiPromise, this.__nativeContract, this.__keyringPair, "providerSetDataset", (i) => re(i, this.__nativeContract, ie), [e, t], r);
  }
  getDapp(e, t) {
    return N.queryOkJSON(this.__apiPromise, this.__nativeContract, this.__callerAddress, "getDapp", [e], t, (r) => N.handleReturnType(r, $(35, ee)));
  }
  dappRegister(e, t, r) {
    return N.txSignAndSend(this.__apiPromise, this.__nativeContract, this.__keyringPair, "dappRegister", (i) => re(i, this.__nativeContract, ie), [e, t], r);
  }
  dappUpdate(e, t, r, i) {
    return N.txSignAndSend(this.__apiPromise, this.__nativeContract, this.__keyringPair, "dappUpdate", (s) => re(s, this.__nativeContract, ie), [e, t, r], i);
  }
  dappFund(e, t) {
    return N.txSignAndSend(this.__apiPromise, this.__nativeContract, this.__keyringPair, "dappFund", (r) => re(r, this.__nativeContract, ie), [e], t);
  }
  dappDeregister(e, t) {
    return N.txSignAndSend(this.__apiPromise, this.__nativeContract, this.__keyringPair, "dappDeregister", (r) => re(r, this.__nativeContract, ie), [e], t);
  }
  dappDeactivate(e, t) {
    return N.txSignAndSend(this.__apiPromise, this.__nativeContract, this.__keyringPair, "dappDeactivate", (r) => re(r, this.__nativeContract, ie), [e], t);
  }
  getUserHistorySummary(e, t) {
    return N.queryOkJSON(this.__apiPromise, this.__nativeContract, this.__callerAddress, "getUserHistorySummary", [e], t, (r) => N.handleReturnType(r, $(38, ee)));
  }
  providerCommit(e, t) {
    return N.txSignAndSend(this.__apiPromise, this.__nativeContract, this.__keyringPair, "providerCommit", (r) => re(r, this.__nativeContract, ie), [e], t);
  }
  providerCommitMany(e, t) {
    return N.txSignAndSend(this.__apiPromise, this.__nativeContract, this.__keyringPair, "providerCommitMany", (r) => re(r, this.__nativeContract, ie), [e], t);
  }
  dappOperatorIsHumanUser(e, t, r) {
    return N.queryOkJSON(this.__apiPromise, this.__nativeContract, this.__callerAddress, "dappOperatorIsHumanUser", [e, t], r, (i) => N.handleReturnType(i, $(45, ee)));
  }
  dappOperatorLastCorrectCaptcha(e, t) {
    return N.queryOkJSON(this.__apiPromise, this.__nativeContract, this.__callerAddress, "dappOperatorLastCorrectCaptcha", [e], t, (r) => N.handleReturnType(r, $(48, ee)));
  }
  getUser(e, t) {
    return N.queryOkJSON(this.__apiPromise, this.__nativeContract, this.__callerAddress, "getUser", [e], t, (r) => N.handleReturnType(r, $(51, ee)));
  }
  getCommit(e, t) {
    return N.queryOkJSON(this.__apiPromise, this.__nativeContract, this.__callerAddress, "getCommit", [e], t, (r) => N.handleReturnType(r, $(54, ee)));
  }
  listProvidersByAccounts(e, t) {
    return N.queryOkJSON(this.__apiPromise, this.__nativeContract, this.__callerAddress, "listProvidersByAccounts", [e], t, (r) => N.handleReturnType(r, $(56, ee)));
  }
  listProvidersByStatus(e, t) {
    return N.queryOkJSON(this.__apiPromise, this.__nativeContract, this.__callerAddress, "listProvidersByStatus", [e], t, (r) => N.handleReturnType(r, $(56, ee)));
  }
  getRandomActiveProvider(e, t, r) {
    return N.queryOkJSON(this.__apiPromise, this.__nativeContract, this.__callerAddress, "getRandomActiveProvider", [e, t], r, (i) => N.handleReturnType(i, $(59, ee)));
  }
  getAllProviderAccounts(e) {
    return N.queryOkJSON(this.__apiPromise, this.__nativeContract, this.__callerAddress, "getAllProviderAccounts", [], e, (t) => N.handleReturnType(t, $(62, ee)));
  }
  getRandomNumber(e, t, r, i) {
    return N.queryOkJSON(this.__apiPromise, this.__nativeContract, this.__callerAddress, "getRandomNumber", [e, t, r], i, (s) => N.handleReturnType(s, $(28, ee)));
  }
  terminate(e) {
    return N.txSignAndSend(this.__apiPromise, this.__nativeContract, this.__keyringPair, "terminate", (t) => re(t, this.__nativeContract, ie), [], e);
  }
  withdraw(e, t) {
    return N.txSignAndSend(this.__apiPromise, this.__nativeContract, this.__keyringPair, "withdraw", (r) => re(r, this.__nativeContract, ie), [e], t);
  }
  setCodeHash(e, t) {
    return N.txSignAndSend(this.__apiPromise, this.__nativeContract, this.__keyringPair, "setCodeHash", (r) => re(r, this.__nativeContract, ie), [e], t);
  }
}, fI = class {
  constructor(e, t, r) {
    this.__nativeContract = e, this.__callerAddress = r, this.__apiPromise = t;
  }
  getGitCommitId(e) {
    return N.queryOkJSON(this.__apiPromise, this.__nativeContract, this.__callerAddress, "getGitCommitId", [], e, (t) => N.handleReturnType(t, $(16, ee)));
  }
  getAdmin(e) {
    return N.queryOkJSON(this.__apiPromise, this.__nativeContract, this.__callerAddress, "getAdmin", [], e, (t) => N.handleReturnType(t, $(18, ee)));
  }
  getPayees(e) {
    return N.queryOkJSON(this.__apiPromise, this.__nativeContract, this.__callerAddress, "getPayees", [], e, (t) => N.handleReturnType(t, $(19, ee)));
  }
  getDappPayees(e) {
    return N.queryOkJSON(this.__apiPromise, this.__nativeContract, this.__callerAddress, "getDappPayees", [], e, (t) => N.handleReturnType(t, $(22, ee)));
  }
  getStatuses(e) {
    return N.queryOkJSON(this.__apiPromise, this.__nativeContract, this.__callerAddress, "getStatuses", [], e, (t) => N.handleReturnType(t, $(25, ee)));
  }
  getProviderStakeThreshold(e) {
    return N.queryOkJSON(this.__apiPromise, this.__nativeContract, this.__callerAddress, "getProviderStakeThreshold", [], e, (t) => N.handleReturnType(t, $(28, ee)));
  }
  getDappStakeThreshold(e) {
    return N.queryOkJSON(this.__apiPromise, this.__nativeContract, this.__callerAddress, "getDappStakeThreshold", [], e, (t) => N.handleReturnType(t, $(28, ee)));
  }
  getMaxProviderFee(e) {
    return N.queryOkJSON(this.__apiPromise, this.__nativeContract, this.__callerAddress, "getMaxProviderFee", [], e, (t) => N.handleReturnType(t, $(29, ee)));
  }
  getMinNumActiveProviders(e) {
    return N.queryOkJSON(this.__apiPromise, this.__nativeContract, this.__callerAddress, "getMinNumActiveProviders", [], e, (t) => N.handleReturnType(t, $(30, ee)));
  }
  getBlockTime(e) {
    return N.queryOkJSON(this.__apiPromise, this.__nativeContract, this.__callerAddress, "getBlockTime", [], e, (t) => N.handleReturnType(t, $(30, ee)));
  }
  getMaxUserHistoryAgeSeconds(e) {
    return N.queryOkJSON(this.__apiPromise, this.__nativeContract, this.__callerAddress, "getMaxUserHistoryAgeSeconds", [], e, (t) => N.handleReturnType(t, $(29, ee)));
  }
  getMaxUserHistoryLen(e) {
    return N.queryOkJSON(this.__apiPromise, this.__nativeContract, this.__callerAddress, "getMaxUserHistoryLen", [], e, (t) => N.handleReturnType(t, $(30, ee)));
  }
  getMaxUserHistoryAgeBlocks(e) {
    return N.queryOkJSON(this.__apiPromise, this.__nativeContract, this.__callerAddress, "getMaxUserHistoryAgeBlocks", [], e, (t) => N.handleReturnType(t, $(29, ee)));
  }
  providerRegister(e, t, r, i) {
    return N.queryOkJSON(this.__apiPromise, this.__nativeContract, this.__callerAddress, "providerRegister", [e, t, r], i, (s) => N.handleReturnType(s, $(10, ee)));
  }
  providerUpdate(e, t, r, i) {
    return N.queryOkJSON(this.__apiPromise, this.__nativeContract, this.__callerAddress, "providerUpdate", [e, t, r], i, (s) => N.handleReturnType(s, $(10, ee)));
  }
  providerDeactivate(e) {
    return N.queryOkJSON(this.__apiPromise, this.__nativeContract, this.__callerAddress, "providerDeactivate", [], e, (t) => N.handleReturnType(t, $(10, ee)));
  }
  providerDeregister(e) {
    return N.queryOkJSON(this.__apiPromise, this.__nativeContract, this.__callerAddress, "providerDeregister", [], e, (t) => N.handleReturnType(t, $(10, ee)));
  }
  getProvider(e, t) {
    return N.queryOkJSON(this.__apiPromise, this.__nativeContract, this.__callerAddress, "getProvider", [e], t, (r) => N.handleReturnType(r, $(32, ee)));
  }
  providerFund(e) {
    return N.queryOkJSON(this.__apiPromise, this.__nativeContract, this.__callerAddress, "providerFund", [], e, (t) => N.handleReturnType(t, $(10, ee)));
  }
  providerSetDataset(e, t, r) {
    return N.queryOkJSON(this.__apiPromise, this.__nativeContract, this.__callerAddress, "providerSetDataset", [e, t], r, (i) => N.handleReturnType(i, $(10, ee)));
  }
  getDapp(e, t) {
    return N.queryOkJSON(this.__apiPromise, this.__nativeContract, this.__callerAddress, "getDapp", [e], t, (r) => N.handleReturnType(r, $(35, ee)));
  }
  dappRegister(e, t, r) {
    return N.queryOkJSON(this.__apiPromise, this.__nativeContract, this.__callerAddress, "dappRegister", [e, t], r, (i) => N.handleReturnType(i, $(10, ee)));
  }
  dappUpdate(e, t, r, i) {
    return N.queryOkJSON(this.__apiPromise, this.__nativeContract, this.__callerAddress, "dappUpdate", [e, t, r], i, (s) => N.handleReturnType(s, $(10, ee)));
  }
  dappFund(e, t) {
    return N.queryOkJSON(this.__apiPromise, this.__nativeContract, this.__callerAddress, "dappFund", [e], t, (r) => N.handleReturnType(r, $(10, ee)));
  }
  dappDeregister(e, t) {
    return N.queryOkJSON(this.__apiPromise, this.__nativeContract, this.__callerAddress, "dappDeregister", [e], t, (r) => N.handleReturnType(r, $(10, ee)));
  }
  dappDeactivate(e, t) {
    return N.queryOkJSON(this.__apiPromise, this.__nativeContract, this.__callerAddress, "dappDeactivate", [e], t, (r) => N.handleReturnType(r, $(10, ee)));
  }
  getUserHistorySummary(e, t) {
    return N.queryOkJSON(this.__apiPromise, this.__nativeContract, this.__callerAddress, "getUserHistorySummary", [e], t, (r) => N.handleReturnType(r, $(38, ee)));
  }
  providerCommit(e, t) {
    return N.queryOkJSON(this.__apiPromise, this.__nativeContract, this.__callerAddress, "providerCommit", [e], t, (r) => N.handleReturnType(r, $(10, ee)));
  }
  providerCommitMany(e, t) {
    return N.queryOkJSON(this.__apiPromise, this.__nativeContract, this.__callerAddress, "providerCommitMany", [e], t, (r) => N.handleReturnType(r, $(10, ee)));
  }
  dappOperatorIsHumanUser(e, t, r) {
    return N.queryOkJSON(this.__apiPromise, this.__nativeContract, this.__callerAddress, "dappOperatorIsHumanUser", [e, t], r, (i) => N.handleReturnType(i, $(45, ee)));
  }
  dappOperatorLastCorrectCaptcha(e, t) {
    return N.queryOkJSON(this.__apiPromise, this.__nativeContract, this.__callerAddress, "dappOperatorLastCorrectCaptcha", [e], t, (r) => N.handleReturnType(r, $(48, ee)));
  }
  getUser(e, t) {
    return N.queryOkJSON(this.__apiPromise, this.__nativeContract, this.__callerAddress, "getUser", [e], t, (r) => N.handleReturnType(r, $(51, ee)));
  }
  getCommit(e, t) {
    return N.queryOkJSON(this.__apiPromise, this.__nativeContract, this.__callerAddress, "getCommit", [e], t, (r) => N.handleReturnType(r, $(54, ee)));
  }
  listProvidersByAccounts(e, t) {
    return N.queryOkJSON(this.__apiPromise, this.__nativeContract, this.__callerAddress, "listProvidersByAccounts", [e], t, (r) => N.handleReturnType(r, $(56, ee)));
  }
  listProvidersByStatus(e, t) {
    return N.queryOkJSON(this.__apiPromise, this.__nativeContract, this.__callerAddress, "listProvidersByStatus", [e], t, (r) => N.handleReturnType(r, $(56, ee)));
  }
  getRandomActiveProvider(e, t, r) {
    return N.queryOkJSON(this.__apiPromise, this.__nativeContract, this.__callerAddress, "getRandomActiveProvider", [e, t], r, (i) => N.handleReturnType(i, $(59, ee)));
  }
  getAllProviderAccounts(e) {
    return N.queryOkJSON(this.__apiPromise, this.__nativeContract, this.__callerAddress, "getAllProviderAccounts", [], e, (t) => N.handleReturnType(t, $(62, ee)));
  }
  getRandomNumber(e, t, r, i) {
    return N.queryOkJSON(this.__apiPromise, this.__nativeContract, this.__callerAddress, "getRandomNumber", [e, t, r], i, (s) => N.handleReturnType(s, $(28, ee)));
  }
  terminate(e) {
    return N.queryOkJSON(this.__apiPromise, this.__nativeContract, this.__callerAddress, "terminate", [], e, (t) => N.handleReturnType(t, $(10, ee)));
  }
  withdraw(e, t) {
    return N.queryOkJSON(this.__apiPromise, this.__nativeContract, this.__callerAddress, "withdraw", [e], t, (r) => N.handleReturnType(r, $(10, ee)));
  }
  setCodeHash(e, t) {
    return N.queryOkJSON(this.__apiPromise, this.__nativeContract, this.__callerAddress, "setCodeHash", [e], t, (r) => N.handleReturnType(r, $(10, ee)));
  }
};
class hI {
  constructor(e, t, r) {
    this.__apiPromise = e, this.__nativeContract = t, this.__keyringPair = r;
  }
  getGitCommitId(e) {
    return N.txSignAndSend(this.__apiPromise, this.__nativeContract, this.__keyringPair, "getGitCommitId", (t) => re(t, this.__nativeContract, ie), [], e);
  }
  getAdmin(e) {
    return N.txSignAndSend(this.__apiPromise, this.__nativeContract, this.__keyringPair, "getAdmin", (t) => re(t, this.__nativeContract, ie), [], e);
  }
  getPayees(e) {
    return N.txSignAndSend(this.__apiPromise, this.__nativeContract, this.__keyringPair, "getPayees", (t) => re(t, this.__nativeContract, ie), [], e);
  }
  getDappPayees(e) {
    return N.txSignAndSend(this.__apiPromise, this.__nativeContract, this.__keyringPair, "getDappPayees", (t) => re(t, this.__nativeContract, ie), [], e);
  }
  getStatuses(e) {
    return N.txSignAndSend(this.__apiPromise, this.__nativeContract, this.__keyringPair, "getStatuses", (t) => re(t, this.__nativeContract, ie), [], e);
  }
  getProviderStakeThreshold(e) {
    return N.txSignAndSend(this.__apiPromise, this.__nativeContract, this.__keyringPair, "getProviderStakeThreshold", (t) => re(t, this.__nativeContract, ie), [], e);
  }
  getDappStakeThreshold(e) {
    return N.txSignAndSend(this.__apiPromise, this.__nativeContract, this.__keyringPair, "getDappStakeThreshold", (t) => re(t, this.__nativeContract, ie), [], e);
  }
  getMaxProviderFee(e) {
    return N.txSignAndSend(this.__apiPromise, this.__nativeContract, this.__keyringPair, "getMaxProviderFee", (t) => re(t, this.__nativeContract, ie), [], e);
  }
  getMinNumActiveProviders(e) {
    return N.txSignAndSend(this.__apiPromise, this.__nativeContract, this.__keyringPair, "getMinNumActiveProviders", (t) => re(t, this.__nativeContract, ie), [], e);
  }
  getBlockTime(e) {
    return N.txSignAndSend(this.__apiPromise, this.__nativeContract, this.__keyringPair, "getBlockTime", (t) => re(t, this.__nativeContract, ie), [], e);
  }
  getMaxUserHistoryAgeSeconds(e) {
    return N.txSignAndSend(this.__apiPromise, this.__nativeContract, this.__keyringPair, "getMaxUserHistoryAgeSeconds", (t) => re(t, this.__nativeContract, ie), [], e);
  }
  getMaxUserHistoryLen(e) {
    return N.txSignAndSend(this.__apiPromise, this.__nativeContract, this.__keyringPair, "getMaxUserHistoryLen", (t) => re(t, this.__nativeContract, ie), [], e);
  }
  getMaxUserHistoryAgeBlocks(e) {
    return N.txSignAndSend(this.__apiPromise, this.__nativeContract, this.__keyringPair, "getMaxUserHistoryAgeBlocks", (t) => re(t, this.__nativeContract, ie), [], e);
  }
  providerRegister(e, t, r, i) {
    return N.txSignAndSend(this.__apiPromise, this.__nativeContract, this.__keyringPair, "providerRegister", (s) => re(s, this.__nativeContract, ie), [e, t, r], i);
  }
  providerUpdate(e, t, r, i) {
    return N.txSignAndSend(this.__apiPromise, this.__nativeContract, this.__keyringPair, "providerUpdate", (s) => re(s, this.__nativeContract, ie), [e, t, r], i);
  }
  providerDeactivate(e) {
    return N.txSignAndSend(this.__apiPromise, this.__nativeContract, this.__keyringPair, "providerDeactivate", (t) => re(t, this.__nativeContract, ie), [], e);
  }
  providerDeregister(e) {
    return N.txSignAndSend(this.__apiPromise, this.__nativeContract, this.__keyringPair, "providerDeregister", (t) => re(t, this.__nativeContract, ie), [], e);
  }
  getProvider(e, t) {
    return N.txSignAndSend(this.__apiPromise, this.__nativeContract, this.__keyringPair, "getProvider", (r) => re(r, this.__nativeContract, ie), [e], t);
  }
  providerFund(e) {
    return N.txSignAndSend(this.__apiPromise, this.__nativeContract, this.__keyringPair, "providerFund", (t) => re(t, this.__nativeContract, ie), [], e);
  }
  providerSetDataset(e, t, r) {
    return N.txSignAndSend(this.__apiPromise, this.__nativeContract, this.__keyringPair, "providerSetDataset", (i) => re(i, this.__nativeContract, ie), [e, t], r);
  }
  getDapp(e, t) {
    return N.txSignAndSend(this.__apiPromise, this.__nativeContract, this.__keyringPair, "getDapp", (r) => re(r, this.__nativeContract, ie), [e], t);
  }
  dappRegister(e, t, r) {
    return N.txSignAndSend(this.__apiPromise, this.__nativeContract, this.__keyringPair, "dappRegister", (i) => re(i, this.__nativeContract, ie), [e, t], r);
  }
  dappUpdate(e, t, r, i) {
    return N.txSignAndSend(this.__apiPromise, this.__nativeContract, this.__keyringPair, "dappUpdate", (s) => re(s, this.__nativeContract, ie), [e, t, r], i);
  }
  dappFund(e, t) {
    return N.txSignAndSend(this.__apiPromise, this.__nativeContract, this.__keyringPair, "dappFund", (r) => re(r, this.__nativeContract, ie), [e], t);
  }
  dappDeregister(e, t) {
    return N.txSignAndSend(this.__apiPromise, this.__nativeContract, this.__keyringPair, "dappDeregister", (r) => re(r, this.__nativeContract, ie), [e], t);
  }
  dappDeactivate(e, t) {
    return N.txSignAndSend(this.__apiPromise, this.__nativeContract, this.__keyringPair, "dappDeactivate", (r) => re(r, this.__nativeContract, ie), [e], t);
  }
  getUserHistorySummary(e, t) {
    return N.txSignAndSend(this.__apiPromise, this.__nativeContract, this.__keyringPair, "getUserHistorySummary", (r) => re(r, this.__nativeContract, ie), [e], t);
  }
  providerCommit(e, t) {
    return N.txSignAndSend(this.__apiPromise, this.__nativeContract, this.__keyringPair, "providerCommit", (r) => re(r, this.__nativeContract, ie), [e], t);
  }
  providerCommitMany(e, t) {
    return N.txSignAndSend(this.__apiPromise, this.__nativeContract, this.__keyringPair, "providerCommitMany", (r) => re(r, this.__nativeContract, ie), [e], t);
  }
  dappOperatorIsHumanUser(e, t, r) {
    return N.txSignAndSend(this.__apiPromise, this.__nativeContract, this.__keyringPair, "dappOperatorIsHumanUser", (i) => re(i, this.__nativeContract, ie), [e, t], r);
  }
  dappOperatorLastCorrectCaptcha(e, t) {
    return N.txSignAndSend(this.__apiPromise, this.__nativeContract, this.__keyringPair, "dappOperatorLastCorrectCaptcha", (r) => re(r, this.__nativeContract, ie), [e], t);
  }
  getUser(e, t) {
    return N.txSignAndSend(this.__apiPromise, this.__nativeContract, this.__keyringPair, "getUser", (r) => re(r, this.__nativeContract, ie), [e], t);
  }
  getCommit(e, t) {
    return N.txSignAndSend(this.__apiPromise, this.__nativeContract, this.__keyringPair, "getCommit", (r) => re(r, this.__nativeContract, ie), [e], t);
  }
  listProvidersByAccounts(e, t) {
    return N.txSignAndSend(this.__apiPromise, this.__nativeContract, this.__keyringPair, "listProvidersByAccounts", (r) => re(r, this.__nativeContract, ie), [e], t);
  }
  listProvidersByStatus(e, t) {
    return N.txSignAndSend(this.__apiPromise, this.__nativeContract, this.__keyringPair, "listProvidersByStatus", (r) => re(r, this.__nativeContract, ie), [e], t);
  }
  getRandomActiveProvider(e, t, r) {
    return N.txSignAndSend(this.__apiPromise, this.__nativeContract, this.__keyringPair, "getRandomActiveProvider", (i) => re(i, this.__nativeContract, ie), [e, t], r);
  }
  getAllProviderAccounts(e) {
    return N.txSignAndSend(this.__apiPromise, this.__nativeContract, this.__keyringPair, "getAllProviderAccounts", (t) => re(t, this.__nativeContract, ie), [], e);
  }
  getRandomNumber(e, t, r, i) {
    return N.txSignAndSend(this.__apiPromise, this.__nativeContract, this.__keyringPair, "getRandomNumber", (s) => re(s, this.__nativeContract, ie), [e, t, r], i);
  }
  terminate(e) {
    return N.txSignAndSend(this.__apiPromise, this.__nativeContract, this.__keyringPair, "terminate", (t) => re(t, this.__nativeContract, ie), [], e);
  }
  withdraw(e, t) {
    return N.txSignAndSend(this.__apiPromise, this.__nativeContract, this.__keyringPair, "withdraw", (r) => re(r, this.__nativeContract, ie), [e], t);
  }
  setCodeHash(e, t) {
    return N.txSignAndSend(this.__apiPromise, this.__nativeContract, this.__keyringPair, "setCodeHash", (r) => re(r, this.__nativeContract, ie), [e], t);
  }
}
class _s {
  constructor(e, t, r) {
    this.address = e, this.nativeContract = new gv(r, Kl, e), this.nativeAPI = r, this.signer = t, this.contractAbi = new Yl(Kl), this.query = new fI(this.nativeContract, this.nativeAPI, t.address), this.buildExtrinsic = new jR(this.nativeContract, this.nativeAPI), this.tx = new hI(r, this.nativeContract, t), this.methods = new yv(r, this.nativeContract, t), this.events = new uI(this.nativeContract, r);
  }
  get name() {
    return this.nativeContract.abi.info.contract.name.toString();
  }
  get abi() {
    return this.contractAbi;
  }
  withSigner(e) {
    return new _s(this.address, e, this.nativeAPI);
  }
  withAddress(e) {
    return new _s(e, this.signer, this.nativeAPI);
  }
  withAPI(e) {
    return new _s(this.address, this.signer, e);
  }
}
function pI(n, e, t) {
  const r = [], i = ["Hash"];
  return e.args.forEach((s, a) => {
    let o = t[a];
    i.indexOf(s.type.type) > -1 && !(te(o) || ye(o)) && (o = gI(o)), r.push(n.registry.createType(s.type.type, o).toU8a());
  }), r;
}
function mI(n, e) {
  if (n.output) {
    const t = n.output;
    if (t.isOk) {
      const r = t.asOk;
      if (r.isErr)
        throw new dr("CONTRACT.QUERY_ERROR", {
          context: { error: r.toPrimitive().err.toString(), contractMethodName: e }
        });
    }
  }
}
function gI(n) {
  if (n.length > 64)
    throw new dr("CONTRACT.INVALID_DATA_FORMAT", {
      context: { error: `stringToHexPadded: string length ${n.length} exceeds 64` }
    });
  const t = wu(n).replace("0x", "");
  return `0x${Array(64 - t.length + 1).join("0")}${t}`;
}
const yI = new Z(5e12).isub(_r), _I = 1.1;
function hm(n, e, t, r, i, s) {
  const a = s ? _I : 1;
  return {
    gasLimit: r ? n.registry.createType("WeightV2", {
      refTime: r.refTime.toBn().muln(a),
      proofSize: r.proofSize.toBn().muln(a)
    }) : e ? n.registry.createType("WeightV2", {
      proofSize: new Z(1e6),
      refTime: yI
    }) : void 0,
    storageDepositLimit: i ? i.isCharge ? i.asCharge.toBn().muln(a) : i.isRefund ? i.asRefund : null : null,
    value: t || At
  };
}
function vI(n) {
  var e;
  return new Z(((e = n.consts.babe) == null ? void 0 : e.expectedBlockTime) || 6e3);
}
const bI = {
  u8: 1,
  u16: 2,
  u32: 4,
  u64: 8,
  u128: 16,
  "[u8; 32]": 32
}, _v = function(n) {
  const e = {};
  return n.types.filter((r) => {
    if (r.type.def.primitive)
      return !0;
    if (r.type.path && r.type.path.length > 0) {
      const i = Array.from(r.type.path);
      return H(i, 0).indexOf("primitive") > -1 && H(i, 1) === "types";
    }
    return !1;
  }).forEach((r) => {
    var s;
    const i = (s = r.type.def.composite) == null ? void 0 : s.fields[0];
    if (i === void 0)
      throw new Error("Invalid type definition");
    e[r.id] = r.type.def.primitive || i.typeName || "";
  }), e;
}, wI = (n, e) => {
  const t = {};
  let r = 0, i = 0;
  for (const s of n) {
    const a = s.name;
    if (s.layout && s.layout.leaf && s.layout.leaf.ty !== void 0) {
      const o = s.layout.leaf.ty;
      if (e[o]) {
        const l = ka(e, o).toString(), u = ka(bI, l);
        t[a] = {
          storageType: l,
          index: r,
          startBytes: i,
          lengthBytes: u
        }, i += u, r++;
      }
    }
  }
  return t;
};
function vv(n, e, t, r) {
  const { storageEntry: i } = xI(t, r);
  if (i) {
    let s = i;
    for (; "root" in s.layout; )
      s = s.layout.root;
    const a = s.root_key || s.layout.leaf.key || "";
    if (cg(a) === 0) {
      const l = _v(t);
      if (s.layout && s.layout.leaf && s.layout.leaf.ty) {
        const u = s.layout.leaf.ty;
        if (l[u])
          return {
            storageType: n.createType("PortableType", {
              id: u,
              type: l[u]
            }),
            storageKey: a
          };
      }
    }
    const o = M2(a.slice(2));
    return {
      storageType: ka(e.registry.lookup.types, s.layout.leaf.ty),
      storageKey: o
    };
  }
  throw new dr("CONTRACT.INVALID_STORAGE_NAME", {
    context: { failedFuncName: vv.name }
  });
}
function xI(n, e) {
  var r, i;
  const t = (r = n.storage.root.layout.struct) == null ? void 0 : r.fields.findIndex((s) => s.name === e);
  return t ? { storageEntry: (i = n.storage.root.layout.struct) == null ? void 0 : i.fields[t], index: t } : {};
}
async function SI(n, e, t, r, i) {
  const s = n.rx.call.contractsApi.getStorage(i, "0x00000000"), a = await tn(s), c = e.registry.createType("Option<Bytes>", a).unwrap().toU8a(!0), l = c.slice(4, c.length), u = ka(r, t), f = u.startBytes, m = f + u.lengthBytes, y = l.slice(f, m);
  return e.registry.createType(u.storageType, y);
}
function EI(n, e, t) {
  const r = !!n.registry.createType("Weight").proofSize, i = ar(n.consts.system.blockWeights ? n.consts.system.blockWeights.maxBlock : n.consts.system.maximumBlockWeight).v1Weight.div($r).div(el), s = n.consts.system.blockWeights ? n.consts.system.blockWeights.perClass.normal.maxExtrinsic.unwrapOrDefault().refTime.toBn().div($r).div(el) : At, a = n.consts.system.blockWeights ? n.consts.system.blockWeights.perClass.normal.maxExtrinsic.unwrapOrDefault().proofSize.toBn() : At, o = !1;
  return new Promise((c, l) => {
    let u = 0, f = 0, m = At, y = n.registry.createType("WeightV2", {
      proofSize: At,
      refTime: At
    }), _ = !1;
    i && (m = i.mul($r), u = m.mul(e).div(ar(n.consts.system.blockWeights ? n.consts.system.blockWeights.maxBlock : n.consts.system.maximumBlockWeight).v1Weight).toNumber(), f = u / e.toNumber() * 100, u = u / 3e3, _ = !i.isZero() && f < 65), r && s && a && (y = n.registry.createType("WeightV2", {
      proofSize: a.div(t),
      refTime: s.mul($r).div(t)
    }), u = s.mul($r).mul(e).div(n.consts.system.blockWeights ? n.consts.system.blockWeights.perClass.normal.maxExtrinsic.unwrapOrDefault().refTime.toBn() : _r).toNumber(), f = u / e.toNumber() * 100, u = u / 3e3, _ = !s.isZero() && f < 65), c({
      executionTime: u,
      isEmpty: o,
      isValid: _,
      isWeightV2: r,
      megaGas: i || At,
      megaRefTime: s || At,
      percentage: f,
      proofSize: a || At,
      weight: m,
      weightV2: y
    });
  });
}
const CI = (n, e) => async (...t) => {
  let r;
  try {
    r = await n.bind(e)(...t);
  } catch (i) {
    throw new dr("CONTRACT.QUERY_ERROR", {
      context: {
        error: i._asError,
        failedFuncName: n.name,
        args: t
      }
    });
  }
  if (r && r.value.err)
    throw new dr("CONTRACT.QUERY_ERROR", {
      context: {
        error: r.value.err.toString(),
        failedFuncName: n.name,
        result: JSON.stringify(r)
      }
    });
  if (r.value)
    return r.value.unwrapRecursively();
  throw new dr("CONTRACT.QUERY_ERROR", {
    context: {
      failedFuncName: n.name,
      result: JSON.stringify(r)
    }
  });
};
class so extends _s {
  constructor(e, t, r, i, s, a, o, c) {
    a || (a = ER(e, c)), super(r, a, e), this.api = e, this.contract = new gv(e, t, r), this.pair = a, this.contractName = i, this.nonce = s, this.logger = Jx(o || Wn.enum.info, `${so.name}.${i}`), this.json = Cw.parse(this.abi.json), this.createStorageGetters();
  }
  createStorageGetters() {
    if (this.json.storage.root.layout.struct)
      for (const e of this.json.storage.root.layout.struct.fields) {
        const t = `${O2(e.name)}`, r = so.prototype;
        r[t] = () => this.getStorage(e.name);
      }
  }
  async queryAtBlock(e, t, r) {
    const i = await this.api.at(e), s = new yv(i, this.contract, this.signer);
    return r ? (await s[t](...r)).value.unwrap().unwrap() : (await s[t]()).value.unwrap().unwrap();
  }
  async getExtrinsicAndGasEstimates(e, t, r) {
    const i = this.abi.findMessage(e), s = pI(this.abi, i, t), a = vI(this.api), o = await EI(this.api, a, new Z(1)), c = o.isWeightV2 ? o.weightV2 : o.isEmpty ? -1 : o.weight;
    this.logger.debug("Sending address: ", this.pair.address);
    const l = {
      gasLimit: c,
      storageDepositLimit: null
    };
    r !== void 0 && (l.value = r);
    const u = this.contract.query[i.method];
    if (u === void 0)
      throw new RangeError(`Method ${e} does not exist on contract ${this.contractName}`);
    const m = await u(this.pair.address, l, ...s);
    if (m.result.isOk) {
      let y = hm(this.api, i.isMutating, r, m.gasRequired, m.storageDeposit), _ = this.contract.tx[e];
      if (_ === void 0)
        throw new RangeError(`Method ${e} does not exist on contract ${this.contractName}`);
      const C = await _(y, ...s).paymentInfo(this.pair.address);
      if (this.logger.debug("Payment info: ", C.partialFee.toHuman()), y = hm(this.api, i.isMutating, r, C.weight, m.storageDeposit, !0), mI(m, e), _ = this.contract.tx[e], _ === void 0)
        throw new RangeError(`Method ${e} does not exist on contract ${this.contractName}`);
      return {
        extrinsic: _(y, ...s),
        options: y,
        storageDeposit: m.storageDeposit
      };
    } else
      throw new dr("CONTRACT.QUERY_ERROR", {
        context: { error: m.result.asErr, failedFuncName: this.getExtrinsicAndGasEstimates.name }
      });
  }
  async getStorage(e) {
    var i;
    const t = _v(this.json), r = wI(((i = this.json.storage.root.layout.struct) == null ? void 0 : i.fields) || [], t);
    if (e in r)
      return SI(this.api, this.abi, e, r, this.contract.address);
    {
      const { storageKey: s, storageType: a } = vv(this.api, this.abi, this.json, e);
      if (a) {
        const o = this.abi.registry.lookup.getTypeDef(`Lookup${a.id.toNumber()}`), c = this.api.rx.call.contractsApi.getStorage(this.address, s), l = await tn(c), u = this.abi.registry.createType("Option<Bytes>", l);
        return this.abi.registry.createType(o.type, [u.unwrap().toU8a(!0)]);
      }
    }
    throw new dr("CONTRACT.INVALID_STORAGE_TYPE", {
      context: { failedFuncName: this.getStorage.name }
    });
  }
}
const AI = (n) => new Promise((e) => setTimeout(e, n));
async function PI(n) {
  try {
    const e = await fetch(n);
    if (!e.ok)
      throw new cl("API.BAD_REQUEST", {
        context: { error: `Network response was not ok, status: ${e.status}`, url: n }
      });
    const t = await e.arrayBuffer();
    return new Uint8Array(t);
  } catch (e) {
    throw new Kt("DATABASE.IMAGE_GET_FAILED", { context: { error: e } });
  }
}
const kI = "NO_SOLUTION";
function bv(n, e = !1, t = !1, r) {
  try {
    const i = n.items.map((s, a) => {
      if (s.hash)
        return s.hash;
      throw new Li("CAPTCHA.MISSING_ITEM_HASH", {
        context: {
          computeCaptchaHashName: bv.name,
          index: a
        }
      });
    });
    return Cs([
      n.target,
      ...e ? TI(n.solution) : [],
      t ? n.salt : "",
      r ? i.sort() : i
    ]);
  } catch (i) {
    throw new Li("DATASET.HASH_ERROR", { context: { error: i } });
  }
}
function TI(n) {
  return n !== void 0 ? n.sort() : [kI];
}
async function NI(n) {
  if (n.type === "text")
    return { ...n, hash: Ha(n.data) };
  if (n.type === "image")
    return { ...n, hash: Ha(await PI(n.data)) };
  throw new Li("CAPTCHA.INVALID_ITEM_FORMAT");
}
function RI(n) {
  return Cs([n.captchaId, n.captchaContentId, [...n.solution].sort(), n.salt]);
}
class pm {
  constructor(e) {
    this.hash = e, this.parent = null;
  }
}
class II {
  constructor() {
    this.leaves = [], this.layers = [];
  }
  build(e) {
    this.layers.length && (this.layers = []);
    const t = [];
    for (const r of e) {
      const i = new pm(r);
      this.leaves.push(i), t.push(i.hash);
    }
    this.layers.push(t), this.root = this.buildMerkleTree(this.leaves)[0];
  }
  buildMerkleTree(e) {
    const t = e.length;
    if (t === 1)
      return e;
    const r = [];
    let i = 0;
    const s = [];
    for (; i < t; ) {
      const a = e[i];
      if (a === void 0)
        throw new cr("DEVELOPER.GENERAL", { context: { error: "leftChild undefined" } });
      const o = i + 1 < t ? H(e, i + 1) : a, c = this.createParent(a, o);
      s.push(c.hash), r.push(c), i += 2;
    }
    return this.layers.push(s), this.buildMerkleTree(r);
  }
  createParent(e, t) {
    const r = new pm(Cs([e.hash, t.hash]));
    return e.parent = r.hash, t.parent = r.hash, r;
  }
  proof(e) {
    const t = [];
    let r = 0;
    for (; r < this.layers.length - 1; ) {
      const s = this.layers[r];
      if (s === void 0)
        throw new cr("DATASET.MERKLE_ERROR", {
          context: { error: "layer undefined", failedFuncName: this.proof.name, layerNum: r }
        });
      const a = s.indexOf(e);
      let o = a % 2 && a > 0 ? a - 1 : a + 1;
      o > s.length - 1 && (o = a);
      const c = [e], l = H(s, o);
      o > a ? c.push(l) : c.unshift(l), t.push([H(c, 0), H(c, 1)]), r += 1, e = Cs(c);
    }
    const i = H(this.layers, this.layers.length - 1);
    return [...t, [H(i, 0)]];
  }
}
function OI(n, e) {
  try {
    if (H(e, 0).indexOf(n) === -1)
      return !1;
    for (const [t, r] of e.entries()) {
      if (n = Cs(r), H(e, t + 1).indexOf(n) === -1)
        return !1;
      const i = H(e, e.length - 1);
      if (n === H(i, 0))
        return !0;
    }
    return !1;
  } catch {
    return !1;
  }
}
class MI {
  constructor(e, t, r, i, s, a) {
    this.userAccount = e, this.contract = t, this.provider = r, this.providerApi = i, this.web2 = s, this.dappAccount = a;
  }
  async getCaptchaChallenge() {
    try {
      const e = await this.providerApi.getCaptchaChallenge(this.userAccount, this.provider);
      return this.verifyCaptchaChallengeContent(this.provider, e), e.captchas.forEach((t) => {
        t.captcha.items.forEach((r) => {
          r.data && (r.data = r.data.replace(/^http(s)*:\/\//, "//"));
        });
      }), e;
    } catch (e) {
      throw new Kt("CAPTCHA.INVALID_CAPTCHA_CHALLENGE", { context: { error: e } });
    }
  }
  verifyCaptchaChallengeContent(e, t) {
    const r = H(t.captchas, 0), i = r.proof.length;
    e.provider;
    const s = H(r.proof, i - 1);
    if (e.provider.datasetIdContent.toString() !== H(s, 0))
      throw new Kt("CAPTCHA.INVALID_DATASET_CONTENT_ID");
    for (const a of t.captchas) {
      if (!LI(a))
        throw new Kt("CAPTCHA.INVALID_CAPTCHA_CHALLENGE");
      if (!OI(a.captcha.captchaContentId, a.proof))
        throw new Kt("CAPTCHA.INVALID_CAPTCHA_CHALLENGE");
    }
  }
  async submitCaptchaSolution(e, t, r, i, s) {
    const a = new II(), o = i.map((m) => RI(m));
    a.build(o);
    const c = a.root.hash, l = void 0;
    let u;
    if (this.web2) {
      if (!e || !e.signRaw)
        throw new Kt("GENERAL.CANT_FIND_KEYRINGPAIR", {
          context: { error: "Signer is not defined, cannot sign message to prove account ownership" }
        });
      u = (await e.signRaw({
        address: this.userAccount,
        data: wu(t),
        type: "bytes"
      })).signature;
    }
    let f;
    try {
      f = await this.providerApi.submitCaptchaSolution(i, t, this.contract.pair.address, s, u);
    } catch (m) {
      throw new Li("CAPTCHA.INVALID_CAPTCHA_CHALLENGE", { context: { error: m } });
    }
    return [f, c, l];
  }
}
async function LI(n) {
  const e = n.captcha, t = n.proof;
  if (!(await Promise.all(e.items.map(async (i) => (await NI(i)).hash === i.hash))).every((i) => i === !0))
    return !1;
  const r = bv(e, !1, !1, !1);
  return r !== e.captchaContentId ? !1 : H(t, 0).indexOf(r) !== -1;
}
const DI = MI, wv = "@prosopo/current_account", xv = "@prosopo/provider";
function UI(n) {
  localStorage.setItem(wv, n);
}
function VI() {
  return localStorage.getItem(wv);
}
function BI(n) {
  localStorage.setItem(xv, n);
}
function HI() {
  return localStorage.getItem(xv);
}
const ha = {
  setAccount: UI,
  getAccount: VI,
  setProviderUrl: BI,
  getProviderUrl: HI
}, FI = () => ({
  showModal: !1,
  loading: !1,
  index: 0,
  challenge: void 0,
  solutions: void 0,
  isHuman: !1,
  captchaApi: void 0,
  account: void 0
}), jI = (n, e) => (r) => {
  Object.assign(n, r), e(r);
}, Ql = (n) => {
  const e = n.networks[n.defaultNetwork];
  if (!e)
    throw new Kt("DEVELOPER.NETWORK_NOT_FOUND", {
      context: { error: `No network found for environment ${n.defaultEnvironment}` }
    });
  return e;
};
function WI(n, e, t, r) {
  const i = (O) => {
    alert(O.message);
  }, s = Object.assign({
    onAccountNotFound: i,
    onError: i,
    onHuman: (O) => {
      o({ sendData: !e.sendData });
    },
    onExtensionNotFound: () => {
      alert("No extension found");
    },
    onFailed: () => {
      alert("Captcha challenge failed. Please try again"), o({ sendData: !e.sendData });
    },
    onExpired: () => {
      alert("Completed challenge has expired, please try again");
    },
    onChallengeExpired: () => {
      alert("Uncompleted challenge has expired, please try again");
    },
    onOpen: () => {
      o({ sendData: !e.sendData });
    },
    onClose: () => {
    }
  }, r), a = (O) => {
    const B = O instanceof Error ? O : new Error(String(O));
    B instanceof Ll ? s.onAccountNotFound(B.message) : s.onError(B);
  }, o = jI(e, t), c = () => {
    const O = {
      userAccountAddress: "",
      ...n
    };
    return e.account && (O.userAccountAddress = e.account.account.address), Dv.parse(O);
  }, l = async (O) => {
    try {
      await O();
    } catch (B) {
      console.error(B), a(B), o({ isHuman: !1, showModal: !1, loading: !1 });
    }
  }, u = async () => {
    s.onOpen(), await l(async () => {
      if (e.loading || e.isHuman)
        return;
      I(), o({ loading: !0 });
      const O = c();
      o({ dappAccount: O.account.address }), await AI(100);
      const B = await L(), P = await Y();
      let d = !1;
      try {
        d = (await P.query.dappOperatorIsHumanUser(B.account.address, O.solutionThreshold)).value.unwrap().unwrap();
      } catch (W) {
      }
      if (d) {
        o({ isHuman: !0, loading: !1 }), s.onHuman({
          user: B.account.address,
          dapp: F()
        }), R();
        return;
      }
      const h = ha.getProviderUrl();
      let g;
      if (h) {
        g = await C(h);
        try {
          const W = await g.verifyDappUser(F(), B.account.address, void 0, n.challengeValidLength);
          if (W.solutionApproved) {
            o({ isHuman: !0, loading: !1 }), s.onHuman({
              providerUrl: h,
              user: B.account.address,
              dapp: F(),
              commitmentId: W.commitmentId
            }), R();
            return;
          }
        } catch {
          console.error("Error contacting provider from storage", h);
        }
      }
      const E = {
        address: B.account.address,
        data: Ze("message"),
        type: "bytes"
      }, w = await B.extension.signer.signRaw(E), x = await CI(P.query.getRandomActiveProvider, P.query)(B.account.address, F()), T = parseInt(x.blockNumber.toString()), S = uf(x.provider.url.toString());
      g = await C(S);
      const p = await v(P, x, g), k = await p.getCaptchaChallenge();
      if (k.captchas.length <= 0)
        throw new cl("DEVELOPER.PROVIDER_NO_CAPTCHA");
      const q = k.captchas.map((W) => W.captcha.timeLimitMs || 30 * 1e3).reduce((W, se) => W + se), X = setTimeout(() => {
        "" + q, s.onChallengeExpired(), o({ isHuman: !1, showModal: !1, loading: !1 });
      }, q);
      o({
        index: 0,
        solutions: k.captchas.map(() => []),
        challenge: k,
        showModal: !0,
        timeout: X,
        blockNumber: T
      });
    });
  }, f = async () => {
    await l(async () => {
      if (A(), !e.challenge)
        throw new cr("CAPTCHA.NO_CAPTCHA", {
          context: { error: "Cannot submit, no Captcha found in state" }
        });
      o({ showModal: !1 });
      const O = e.challenge, B = KC(), P = e.challenge.captchas.map((S, p) => {
        const k = H(e.solutions, p);
        return {
          captchaId: S.captcha.captchaId,
          captchaContentId: S.captcha.captchaContentId,
          salt: B,
          solution: k
        };
      }), d = V(), h = U(), g = d.extension.signer, E = H(O.captchas, 0);
      if (!E.captcha.datasetId)
        throw new Li("CAPTCHA.INVALID_CAPTCHA_ID", {
          context: { error: "No datasetId set for challenge" }
        });
      const w = D(), x = await w.submitCaptchaSolution(g, O.requestHash, E.captcha.datasetId, P, B), T = x[0].solutionApproved;
      if (T || s.onFailed(), o({
        submission: x,
        isHuman: T,
        loading: !1
      }), e.isHuman) {
        const S = uf(w.provider.provider.url.toString());
        ha.setProviderUrl(S), s.onHuman({
          providerUrl: S,
          user: d.account.address,
          dapp: F(),
          commitmentId: x[1],
          blockNumber: h
        }), R();
      }
    });
  }, m = async () => {
    A(), I(), s.onClose();
  }, y = (O) => {
    if (!e.challenge)
      throw new cr("CAPTCHA.NO_CAPTCHA", {
        context: { error: "Cannot select, no Captcha found in state" }
      });
    if (e.index >= e.challenge.captchas.length || e.index < 0)
      throw new cr("CAPTCHA.NO_CAPTCHA", {
        context: { error: "Cannot select, index is out of range for this Captcha" }
      });
    const B = e.index, P = e.solutions, d = H(P, B);
    d.includes(O) ? d.splice(d.indexOf(O), 1) : d.push(O), o({ solutions: P });
  }, _ = () => {
    if (!e.challenge)
      throw new cr("CAPTCHA.NO_CAPTCHA", {
        context: { error: "Cannot select, no Captcha found in state" }
      });
    if (e.index + 1 >= e.challenge.captchas.length)
      throw new cr("CAPTCHA.NO_CAPTCHA", {
        context: { error: "Cannot select, index is out of range for this Captcha" }
      });
    o({ index: e.index + 1 });
  }, v = async (O, B, P) => {
    const d = c(), h = new DI(V().account.address, O, B, P, d.web2, F());
    return o({ captchaApi: h }), D();
  }, C = async (O) => {
    const B = c(), P = Ql(B);
    if (!B.account.address)
      throw new Kt("GENERAL.SITE_KEY_MISSING");
    return new xR(P, O, B.account.address);
  }, A = () => {
    window.clearTimeout(e.timeout), o({ timeout: void 0 });
  }, R = () => {
    const O = n.challengeValidLength || 120 * 1e3, B = setTimeout(() => {
      "" + O, o({ isHuman: !1 }), s.onExpired();
    }, O);
    o({ successfullChallengeTimeout: B });
  }, I = () => {
    A(), o(FI());
  }, D = () => {
    if (!e.captchaApi)
      throw new cl("API.UNKNOWN", { context: { error: "Captcha api not set", state: e } });
    return e.captchaApi;
  }, L = async () => {
    const O = c();
    if (!O.web2 && !O.userAccountAddress)
      throw new Kt("GENERAL.ACCOUNT_NOT_FOUND", {
        context: { error: "Account address has not been set for web3 mode" }
      });
    const P = await (O.web2 ? new PM() : new ZA()).getAccount(O);
    return ha.setAccount(P.account.address), o({ account: P }), V();
  }, V = () => {
    if (!e.account)
      throw new Kt("GENERAL.ACCOUNT_NOT_FOUND", { context: { error: "Account not loaded" } });
    return e.account;
  }, F = () => {
    if (!e.dappAccount)
      throw new Kt("GENERAL.SITE_KEY_MISSING");
    return e.dappAccount;
  }, U = () => {
    if (!e.blockNumber)
      throw new dr("CAPTCHA.INVALID_BLOCK_NO", { context: { error: "Block number not found" } });
    return e.blockNumber;
  }, Y = async () => {
    const O = c(), B = Ql(O), P = await Is.create({ provider: new Zs(B.endpoint), initWasm: !1 }), d = "sr25519", h = new io({ type: d, ss58Format: P.registry.chainSS58 });
    return new so(P, JSON.parse(Kl), B.contract.address, "prosopo", 0, h.addFromAddress(V().account.address));
  };
  return {
    start: u,
    cancel: m,
    submit: f,
    select: y,
    nextRound: _,
    exportData: async (O) => {
      var d;
      const B = ha.getProviderUrl() || ((d = e.captchaApi) == null ? void 0 : d.provider.provider.url.toString());
      if (!B)
        return;
      await (await C(B)).submitUserEvents(O, V().account.address);
    }
  };
}
var Sv = "3.4.2";
function Os(n, e) {
  return new Promise(function(t) {
    return setTimeout(t, n, e);
  });
}
function qI(n, e) {
  e === void 0 && (e = 1 / 0);
  var t = window.requestIdleCallback;
  return t ? new Promise(function(r) {
    return t.call(window, function() {
      return r();
    }, { timeout: e });
  }) : Os(Math.min(n, e));
}
function Ev(n) {
  return !!n && typeof n.then == "function";
}
function mm(n, e) {
  try {
    var t = n();
    Ev(t) ? t.then(function(r) {
      return e(!0, r);
    }, function(r) {
      return e(!1, r);
    }) : e(!0, t);
  } catch (r) {
    e(!1, r);
  }
}
function gm(n, e, t) {
  return t === void 0 && (t = 16), nr(this, void 0, void 0, function() {
    var r, i, s, a;
    return Dn(this, function(o) {
      switch (o.label) {
        case 0:
          r = Array(n.length), i = Date.now(), s = 0, o.label = 1;
        case 1:
          return s < n.length ? (r[s] = e(n[s], s), a = Date.now(), a >= i + t ? (i = a, [4, Os(0)]) : [3, 3]) : [3, 4];
        case 2:
          o.sent(), o.label = 3;
        case 3:
          return ++s, [3, 1];
        case 4:
          return [2, r];
      }
    });
  });
}
function Ms(n) {
  n.then(void 0, function() {
  });
}
function Rr(n, e) {
  n = [n[0] >>> 16, n[0] & 65535, n[1] >>> 16, n[1] & 65535], e = [e[0] >>> 16, e[0] & 65535, e[1] >>> 16, e[1] & 65535];
  var t = [0, 0, 0, 0];
  return t[3] += n[3] + e[3], t[2] += t[3] >>> 16, t[3] &= 65535, t[2] += n[2] + e[2], t[1] += t[2] >>> 16, t[2] &= 65535, t[1] += n[1] + e[1], t[0] += t[1] >>> 16, t[1] &= 65535, t[0] += n[0] + e[0], t[0] &= 65535, [t[0] << 16 | t[1], t[2] << 16 | t[3]];
}
function gn(n, e) {
  n = [n[0] >>> 16, n[0] & 65535, n[1] >>> 16, n[1] & 65535], e = [e[0] >>> 16, e[0] & 65535, e[1] >>> 16, e[1] & 65535];
  var t = [0, 0, 0, 0];
  return t[3] += n[3] * e[3], t[2] += t[3] >>> 16, t[3] &= 65535, t[2] += n[2] * e[3], t[1] += t[2] >>> 16, t[2] &= 65535, t[2] += n[3] * e[2], t[1] += t[2] >>> 16, t[2] &= 65535, t[1] += n[1] * e[3], t[0] += t[1] >>> 16, t[1] &= 65535, t[1] += n[2] * e[2], t[0] += t[1] >>> 16, t[1] &= 65535, t[1] += n[3] * e[1], t[0] += t[1] >>> 16, t[1] &= 65535, t[0] += n[0] * e[3] + n[1] * e[2] + n[2] * e[1] + n[3] * e[0], t[0] &= 65535, [t[0] << 16 | t[1], t[2] << 16 | t[3]];
}
function pi(n, e) {
  return e %= 64, e === 32 ? [n[1], n[0]] : e < 32 ? [n[0] << e | n[1] >>> 32 - e, n[1] << e | n[0] >>> 32 - e] : (e -= 32, [n[1] << e | n[0] >>> 32 - e, n[0] << e | n[1] >>> 32 - e]);
}
function cn(n, e) {
  return e %= 64, e === 0 ? n : e < 32 ? [n[0] << e | n[1] >>> 32 - e, n[1] << e] : [n[1] << e - 32, 0];
}
function Ve(n, e) {
  return [n[0] ^ e[0], n[1] ^ e[1]];
}
function ym(n) {
  return n = Ve(n, [0, n[0] >>> 1]), n = gn(n, [4283543511, 3981806797]), n = Ve(n, [0, n[0] >>> 1]), n = gn(n, [3301882366, 444984403]), n = Ve(n, [0, n[0] >>> 1]), n;
}
function zI(n, e) {
  n = n || "", e = e || 0;
  var t = n.length % 16, r = n.length - t, i = [0, e], s = [0, e], a = [0, 0], o = [0, 0], c = [2277735313, 289559509], l = [1291169091, 658871167], u;
  for (u = 0; u < r; u = u + 16)
    a = [
      n.charCodeAt(u + 4) & 255 | (n.charCodeAt(u + 5) & 255) << 8 | (n.charCodeAt(u + 6) & 255) << 16 | (n.charCodeAt(u + 7) & 255) << 24,
      n.charCodeAt(u) & 255 | (n.charCodeAt(u + 1) & 255) << 8 | (n.charCodeAt(u + 2) & 255) << 16 | (n.charCodeAt(u + 3) & 255) << 24
    ], o = [
      n.charCodeAt(u + 12) & 255 | (n.charCodeAt(u + 13) & 255) << 8 | (n.charCodeAt(u + 14) & 255) << 16 | (n.charCodeAt(u + 15) & 255) << 24,
      n.charCodeAt(u + 8) & 255 | (n.charCodeAt(u + 9) & 255) << 8 | (n.charCodeAt(u + 10) & 255) << 16 | (n.charCodeAt(u + 11) & 255) << 24
    ], a = gn(a, c), a = pi(a, 31), a = gn(a, l), i = Ve(i, a), i = pi(i, 27), i = Rr(i, s), i = Rr(gn(i, [0, 5]), [0, 1390208809]), o = gn(o, l), o = pi(o, 33), o = gn(o, c), s = Ve(s, o), s = pi(s, 31), s = Rr(s, i), s = Rr(gn(s, [0, 5]), [0, 944331445]);
  switch (a = [0, 0], o = [0, 0], t) {
    case 15:
      o = Ve(o, cn([0, n.charCodeAt(u + 14)], 48));
    case 14:
      o = Ve(o, cn([0, n.charCodeAt(u + 13)], 40));
    case 13:
      o = Ve(o, cn([0, n.charCodeAt(u + 12)], 32));
    case 12:
      o = Ve(o, cn([0, n.charCodeAt(u + 11)], 24));
    case 11:
      o = Ve(o, cn([0, n.charCodeAt(u + 10)], 16));
    case 10:
      o = Ve(o, cn([0, n.charCodeAt(u + 9)], 8));
    case 9:
      o = Ve(o, [0, n.charCodeAt(u + 8)]), o = gn(o, l), o = pi(o, 33), o = gn(o, c), s = Ve(s, o);
    case 8:
      a = Ve(a, cn([0, n.charCodeAt(u + 7)], 56));
    case 7:
      a = Ve(a, cn([0, n.charCodeAt(u + 6)], 48));
    case 6:
      a = Ve(a, cn([0, n.charCodeAt(u + 5)], 40));
    case 5:
      a = Ve(a, cn([0, n.charCodeAt(u + 4)], 32));
    case 4:
      a = Ve(a, cn([0, n.charCodeAt(u + 3)], 24));
    case 3:
      a = Ve(a, cn([0, n.charCodeAt(u + 2)], 16));
    case 2:
      a = Ve(a, cn([0, n.charCodeAt(u + 1)], 8));
    case 1:
      a = Ve(a, [0, n.charCodeAt(u)]), a = gn(a, c), a = pi(a, 31), a = gn(a, l), i = Ve(i, a);
  }
  return i = Ve(i, [0, n.length]), s = Ve(s, [0, n.length]), i = Rr(i, s), s = Rr(s, i), i = ym(i), s = ym(s), i = Rr(i, s), s = Rr(s, i), ("00000000" + (i[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (i[1] >>> 0).toString(16)).slice(-8) + ("00000000" + (s[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (s[1] >>> 0).toString(16)).slice(-8);
}
function XI(n) {
  var e;
  return ml({ name: n.name, message: n.message, stack: (e = n.stack) === null || e === void 0 ? void 0 : e.split(`
`) }, n);
}
function GI(n, e) {
  for (var t = 0, r = n.length; t < r; ++t)
    if (n[t] === e)
      return !0;
  return !1;
}
function ZI(n, e) {
  return !GI(n, e);
}
function Ed(n) {
  return parseInt(n);
}
function kn(n) {
  return parseFloat(n);
}
function or(n, e) {
  return typeof n == "number" && isNaN(n) ? e : n;
}
function Un(n) {
  return n.reduce(function(e, t) {
    return e + (t ? 1 : 0);
  }, 0);
}
function Cv(n, e) {
  if (e === void 0 && (e = 1), Math.abs(e) >= 1)
    return Math.round(n / e) * e;
  var t = 1 / e;
  return Math.round(n * t) / t;
}
function JI(n) {
  for (var e, t, r = "Unexpected syntax '".concat(n, "'"), i = /^\s*([a-z-]*)(.*)$/i.exec(n), s = i[1] || void 0, a = {}, o = /([.:#][\w-]+|\[.+?\])/gi, c = function(m, y) {
    a[m] = a[m] || [], a[m].push(y);
  }; ; ) {
    var l = o.exec(i[2]);
    if (!l)
      break;
    var u = l[0];
    switch (u[0]) {
      case ".":
        c("class", u.slice(1));
        break;
      case "#":
        c("id", u.slice(1));
        break;
      case "[": {
        var f = /^\[([\w-]+)([~|^$*]?=("(.*?)"|([\w-]+)))?(\s+[is])?\]$/.exec(u);
        if (f)
          c(f[1], (t = (e = f[4]) !== null && e !== void 0 ? e : f[5]) !== null && t !== void 0 ? t : "");
        else
          throw new Error(r);
        break;
      }
      default:
        throw new Error(r);
    }
  }
  return [s, a];
}
function _m(n) {
  return n && typeof n == "object" && "message" in n ? n : { message: n };
}
function KI(n) {
  return typeof n != "function";
}
function YI(n, e) {
  var t = new Promise(function(r) {
    var i = Date.now();
    mm(n.bind(null, e), function() {
      for (var s = [], a = 0; a < arguments.length; a++)
        s[a] = arguments[a];
      var o = Date.now() - i;
      if (!s[0])
        return r(function() {
          return { error: _m(s[1]), duration: o };
        });
      var c = s[1];
      if (KI(c))
        return r(function() {
          return { value: c, duration: o };
        });
      r(function() {
        return new Promise(function(l) {
          var u = Date.now();
          mm(c, function() {
            for (var f = [], m = 0; m < arguments.length; m++)
              f[m] = arguments[m];
            var y = o + Date.now() - u;
            if (!f[0])
              return l({ error: _m(f[1]), duration: y });
            l({ value: f[1], duration: y });
          });
        });
      });
    });
  });
  return Ms(t), function() {
    return t.then(function(i) {
      return i();
    });
  };
}
function QI(n, e, t) {
  var r = Object.keys(n).filter(function(s) {
    return ZI(t, s);
  }), i = gm(r, function(s) {
    return YI(n[s], e);
  });
  return Ms(i), function() {
    return nr(this, void 0, void 0, function() {
      var a, o, c, l, u;
      return Dn(this, function(f) {
        switch (f.label) {
          case 0:
            return [4, i];
          case 1:
            return a = f.sent(), [4, gm(a, function(m) {
              var y = m();
              return Ms(y), y;
            })];
          case 2:
            return o = f.sent(), [
              4,
              Promise.all(o)
              // Keeping the component keys order the same as the source keys order
            ];
          case 3:
            for (c = f.sent(), l = {}, u = 0; u < r.length; ++u)
              l[r[u]] = c[u];
            return [2, l];
        }
      });
    });
  };
}
function Av() {
  var n = window, e = navigator;
  return Un([
    "MSCSSMatrix" in n,
    "msSetImmediate" in n,
    "msIndexedDB" in n,
    "msMaxTouchPoints" in e,
    "msPointerEnabled" in e
  ]) >= 4;
}
function $I() {
  var n = window, e = navigator;
  return Un(["msWriteProfilerMark" in n, "MSStream" in n, "msLaunchUri" in e, "msSaveBlob" in e]) >= 3 && !Av();
}
function Cd() {
  var n = window, e = navigator;
  return Un([
    "webkitPersistentStorage" in e,
    "webkitTemporaryStorage" in e,
    e.vendor.indexOf("Google") === 0,
    "webkitResolveLocalFileSystemURL" in n,
    "BatteryManager" in n,
    "webkitMediaStream" in n,
    "webkitSpeechGrammar" in n
  ]) >= 5;
}
function Js() {
  var n = window, e = navigator;
  return Un([
    "ApplePayError" in n,
    "CSSPrimitiveValue" in n,
    "Counter" in n,
    e.vendor.indexOf("Apple") === 0,
    "getStorageUpdates" in e,
    "WebKitMediaKeys" in n
  ]) >= 4;
}
function Ad() {
  var n = window;
  return Un([
    "safari" in n,
    !("DeviceMotionEvent" in n),
    !("ongestureend" in n),
    !("standalone" in navigator)
  ]) >= 3;
}
function eO() {
  var n, e, t = window;
  return Un([
    "buildID" in navigator,
    "MozAppearance" in ((e = (n = document.documentElement) === null || n === void 0 ? void 0 : n.style) !== null && e !== void 0 ? e : {}),
    "onmozfullscreenchange" in t,
    "mozInnerScreenX" in t,
    "CSSMozDocumentRule" in t,
    "CanvasCaptureMediaStream" in t
  ]) >= 4;
}
function tO() {
  var n = window;
  return Un([
    !("MediaSettingsRange" in n),
    "RTCEncodedAudioFrame" in n,
    "" + n.Intl == "[object Intl]",
    "" + n.Reflect == "[object Reflect]"
  ]) >= 3;
}
function nO() {
  var n = window;
  return Un([
    "DOMRectList" in n,
    "RTCPeerConnectionIceEvent" in n,
    "SVGGeometryElement" in n,
    "ontransitioncancel" in n
  ]) >= 3;
}
function rO() {
  if (navigator.platform === "iPad")
    return !0;
  var n = screen, e = n.width / n.height;
  return Un([
    "MediaSource" in window,
    !!Element.prototype.webkitRequestFullscreen,
    // iPhone 4S that runs iOS 9 matches this. But it won't match the criteria above, so it won't be detected as iPad.
    e > 0.65 && e < 1.53
  ]) >= 2;
}
function iO() {
  var n = document;
  return n.fullscreenElement || n.msFullscreenElement || n.mozFullScreenElement || n.webkitFullscreenElement || null;
}
function sO() {
  var n = document;
  return (n.exitFullscreen || n.msExitFullscreen || n.mozCancelFullScreen || n.webkitExitFullscreen).call(n);
}
function Pv() {
  var n = Cd(), e = eO();
  if (!n && !e)
    return !1;
  var t = window;
  return Un([
    "onorientationchange" in t,
    "orientation" in t,
    n && !("SharedWorker" in t),
    e && /android/i.test(navigator.appVersion)
  ]) >= 2;
}
function aO() {
  var n = window, e = n.OfflineAudioContext || n.webkitOfflineAudioContext;
  if (!e)
    return -2;
  if (oO())
    return -1;
  var t = 4500, r = 5e3, i = new e(1, r, 44100), s = i.createOscillator();
  s.type = "triangle", s.frequency.value = 1e4;
  var a = i.createDynamicsCompressor();
  a.threshold.value = -50, a.knee.value = 40, a.ratio.value = 12, a.attack.value = 0, a.release.value = 0.25, s.connect(a), a.connect(i.destination), s.start(0);
  var o = cO(i), c = o[0], l = o[1], u = c.then(function(f) {
    return lO(f.getChannelData(0).subarray(t));
  }, function(f) {
    if (f.name === "timeout" || f.name === "suspended")
      return -3;
    throw f;
  });
  return Ms(u), function() {
    return l(), u;
  };
}
function oO() {
  return Js() && !Ad() && !nO();
}
function cO(n) {
  var e = 3, t = 500, r = 500, i = 5e3, s = function() {
  }, a = new Promise(function(o, c) {
    var l = !1, u = 0, f = 0;
    n.oncomplete = function(_) {
      return o(_.renderedBuffer);
    };
    var m = function() {
      setTimeout(function() {
        return c(vm(
          "timeout"
          /* InnerErrorName.Timeout */
        ));
      }, Math.min(r, f + i - Date.now()));
    }, y = function() {
      try {
        var _ = n.startRendering();
        switch (Ev(_) && Ms(_), n.state) {
          case "running":
            f = Date.now(), l && m();
            break;
          case "suspended":
            document.hidden || u++, l && u >= e ? c(vm(
              "suspended"
              /* InnerErrorName.Suspended */
            )) : setTimeout(y, t);
            break;
        }
      } catch (v) {
        c(v);
      }
    };
    y(), s = function() {
      l || (l = !0, f > 0 && m());
    };
  });
  return [a, s];
}
function lO(n) {
  for (var e = 0, t = 0; t < n.length; ++t)
    e += Math.abs(n[t]);
  return e;
}
function vm(n) {
  var e = new Error(n);
  return e.name = n, e;
}
function kv(n, e, t) {
  var r, i, s;
  return t === void 0 && (t = 50), nr(this, void 0, void 0, function() {
    var a, o;
    return Dn(this, function(c) {
      switch (c.label) {
        case 0:
          a = document, c.label = 1;
        case 1:
          return a.body ? [3, 3] : [4, Os(t)];
        case 2:
          return c.sent(), [3, 1];
        case 3:
          o = a.createElement("iframe"), c.label = 4;
        case 4:
          return c.trys.push([4, , 10, 11]), [4, new Promise(function(l, u) {
            var f = !1, m = function() {
              f = !0, l();
            }, y = function(C) {
              f = !0, u(C);
            };
            o.onload = m, o.onerror = y;
            var _ = o.style;
            _.setProperty("display", "block", "important"), _.position = "absolute", _.top = "0", _.left = "0", _.visibility = "hidden", e && "srcdoc" in o ? o.srcdoc = e : o.src = "about:blank", a.body.appendChild(o);
            var v = function() {
              var C, A;
              f || (((A = (C = o.contentWindow) === null || C === void 0 ? void 0 : C.document) === null || A === void 0 ? void 0 : A.readyState) === "complete" ? m() : setTimeout(v, 10));
            };
            v();
          })];
        case 5:
          c.sent(), c.label = 6;
        case 6:
          return !((i = (r = o.contentWindow) === null || r === void 0 ? void 0 : r.document) === null || i === void 0) && i.body ? [3, 8] : [4, Os(t)];
        case 7:
          return c.sent(), [3, 6];
        case 8:
          return [4, n(o, o.contentWindow)];
        case 9:
          return [2, c.sent()];
        case 10:
          return (s = o.parentNode) === null || s === void 0 || s.removeChild(o), [
            7
            /*endfinally*/
          ];
        case 11:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function uO(n) {
  for (var e = JI(n), t = e[0], r = e[1], i = document.createElement(t ?? "div"), s = 0, a = Object.keys(r); s < a.length; s++) {
    var o = a[s], c = r[o].join(" ");
    o === "style" ? dO(i.style, c) : i.setAttribute(o, c);
  }
  return i;
}
function dO(n, e) {
  for (var t = 0, r = e.split(";"); t < r.length; t++) {
    var i = r[t], s = /^\s*([\w-]+)\s*:\s*(.+?)(\s*!([\w-]+))?\s*$/.exec(i);
    if (s) {
      var a = s[1], o = s[2], c = s[4];
      n.setProperty(a, o, c || "");
    }
  }
}
var fO = "mmMwWLliI0O&1", hO = "48px", mi = ["monospace", "sans-serif", "serif"], bm = [
  // This is android-specific font from "Roboto" family
  "sans-serif-thin",
  "ARNO PRO",
  "Agency FB",
  "Arabic Typesetting",
  "Arial Unicode MS",
  "AvantGarde Bk BT",
  "BankGothic Md BT",
  "Batang",
  "Bitstream Vera Sans Mono",
  "Calibri",
  "Century",
  "Century Gothic",
  "Clarendon",
  "EUROSTILE",
  "Franklin Gothic",
  "Futura Bk BT",
  "Futura Md BT",
  "GOTHAM",
  "Gill Sans",
  "HELV",
  "Haettenschweiler",
  "Helvetica Neue",
  "Humanst521 BT",
  "Leelawadee",
  "Letter Gothic",
  "Levenim MT",
  "Lucida Bright",
  "Lucida Sans",
  "Menlo",
  "MS Mincho",
  "MS Outlook",
  "MS Reference Specialty",
  "MS UI Gothic",
  "MT Extra",
  "MYRIAD PRO",
  "Marlett",
  "Meiryo UI",
  "Microsoft Uighur",
  "Minion Pro",
  "Monotype Corsiva",
  "PMingLiU",
  "Pristina",
  "SCRIPTINA",
  "Segoe UI Light",
  "Serifa",
  "SimHei",
  "Small Fonts",
  "Staccato222 BT",
  "TRAJAN PRO",
  "Univers CE 55 Medium",
  "Vrinda",
  "ZWAdobeF"
];
function pO() {
  return kv(function(n, e) {
    var t = e.document, r = t.body;
    r.style.fontSize = hO;
    var i = t.createElement("div"), s = {}, a = {}, o = function(v) {
      var C = t.createElement("span"), A = C.style;
      return A.position = "absolute", A.top = "0", A.left = "0", A.fontFamily = v, C.textContent = fO, i.appendChild(C), C;
    }, c = function(v, C) {
      return o("'".concat(v, "',").concat(C));
    }, l = function() {
      return mi.map(o);
    }, u = function() {
      for (var v = {}, C = function(D) {
        v[D] = mi.map(function(L) {
          return c(D, L);
        });
      }, A = 0, R = bm; A < R.length; A++) {
        var I = R[A];
        C(I);
      }
      return v;
    }, f = function(v) {
      return mi.some(function(C, A) {
        return v[A].offsetWidth !== s[C] || v[A].offsetHeight !== a[C];
      });
    }, m = l(), y = u();
    r.appendChild(i);
    for (var _ = 0; _ < mi.length; _++)
      s[mi[_]] = m[_].offsetWidth, a[mi[_]] = m[_].offsetHeight;
    return bm.filter(function(v) {
      return f(y[v]);
    });
  });
}
function mO() {
  var n = navigator.plugins;
  if (n) {
    for (var e = [], t = 0; t < n.length; ++t) {
      var r = n[t];
      if (r) {
        for (var i = [], s = 0; s < r.length; ++s) {
          var a = r[s];
          i.push({
            type: a.type,
            suffixes: a.suffixes
          });
        }
        e.push({
          name: r.name,
          description: r.description,
          mimeTypes: i
        });
      }
    }
    return e;
  }
}
function gO() {
  var n = !1, e, t, r = yO(), i = r[0], s = r[1];
  if (!_O(i, s))
    e = t = "";
  else {
    n = vO(s), bO(i, s);
    var a = Zc(i), o = Zc(i);
    a !== o ? e = t = "unstable" : (t = a, wO(i, s), e = Zc(i));
  }
  return { winding: n, geometry: e, text: t };
}
function yO() {
  var n = document.createElement("canvas");
  return n.width = 1, n.height = 1, [n, n.getContext("2d")];
}
function _O(n, e) {
  return !!(e && n.toDataURL);
}
function vO(n) {
  return n.rect(0, 0, 10, 10), n.rect(2, 2, 6, 6), !n.isPointInPath(5, 5, "evenodd");
}
function bO(n, e) {
  n.width = 240, n.height = 60, e.textBaseline = "alphabetic", e.fillStyle = "#f60", e.fillRect(100, 1, 62, 20), e.fillStyle = "#069", e.font = '11pt "Times New Roman"';
  var t = "Cwm fjordbank gly ".concat(
    String.fromCharCode(55357, 56835)
    /*  */
  );
  e.fillText(t, 2, 15), e.fillStyle = "rgba(102, 204, 0, 0.2)", e.font = "18pt Arial", e.fillText(t, 4, 45);
}
function wO(n, e) {
  n.width = 122, n.height = 110, e.globalCompositeOperation = "multiply";
  for (var t = 0, r = [
    ["#f2f", 40, 40],
    ["#2ff", 80, 40],
    ["#ff2", 60, 80]
  ]; t < r.length; t++) {
    var i = r[t], s = i[0], a = i[1], o = i[2];
    e.fillStyle = s, e.beginPath(), e.arc(a, o, 40, 0, Math.PI * 2, !0), e.closePath(), e.fill();
  }
  e.fillStyle = "#f9c", e.arc(60, 60, 60, 0, Math.PI * 2, !0), e.arc(60, 60, 20, 0, Math.PI * 2, !0), e.fill("evenodd");
}
function Zc(n) {
  return n.toDataURL();
}
function xO() {
  var n = navigator, e = 0, t;
  n.maxTouchPoints !== void 0 ? e = Ed(n.maxTouchPoints) : n.msMaxTouchPoints !== void 0 && (e = n.msMaxTouchPoints);
  try {
    document.createEvent("TouchEvent"), t = !0;
  } catch {
    t = !1;
  }
  var r = "ontouchstart" in window;
  return {
    maxTouchPoints: e,
    touchEvent: t,
    touchStart: r
  };
}
function SO() {
  return navigator.oscpu;
}
function EO() {
  var n = navigator, e = [], t = n.language || n.userLanguage || n.browserLanguage || n.systemLanguage;
  if (t !== void 0 && e.push([t]), Array.isArray(n.languages))
    Cd() && tO() || e.push(n.languages);
  else if (typeof n.languages == "string") {
    var r = n.languages;
    r && e.push(r.split(","));
  }
  return e;
}
function CO() {
  return window.screen.colorDepth;
}
function AO() {
  return or(kn(navigator.deviceMemory), void 0);
}
function PO() {
  var n = screen, e = function(r) {
    return or(Ed(r), null);
  }, t = [e(n.width), e(n.height)];
  return t.sort().reverse(), t;
}
var kO = 2500, TO = 10, Pa, Jc;
function NO() {
  if (Jc === void 0) {
    var n = function() {
      var e = $l();
      eu(e) ? Jc = setTimeout(n, kO) : (Pa = e, Jc = void 0);
    };
    n();
  }
}
function RO() {
  var n = this;
  return NO(), function() {
    return nr(n, void 0, void 0, function() {
      var e;
      return Dn(this, function(t) {
        switch (t.label) {
          case 0:
            return e = $l(), eu(e) ? Pa ? [2, $n([], Pa, !0)] : iO() ? [4, sO()] : [3, 2] : [3, 2];
          case 1:
            t.sent(), e = $l(), t.label = 2;
          case 2:
            return eu(e) || (Pa = e), [2, e];
        }
      });
    });
  };
}
function IO() {
  var n = this, e = RO();
  return function() {
    return nr(n, void 0, void 0, function() {
      var t, r;
      return Dn(this, function(i) {
        switch (i.label) {
          case 0:
            return [4, e()];
          case 1:
            return t = i.sent(), r = function(s) {
              return s === null ? null : Cv(s, TO);
            }, [2, [r(t[0]), r(t[1]), r(t[2]), r(t[3])]];
        }
      });
    });
  };
}
function $l() {
  var n = screen;
  return [
    or(kn(n.availTop), null),
    or(kn(n.width) - kn(n.availWidth) - or(kn(n.availLeft), 0), null),
    or(kn(n.height) - kn(n.availHeight) - or(kn(n.availTop), 0), null),
    or(kn(n.availLeft), null)
  ];
}
function eu(n) {
  for (var e = 0; e < 4; ++e)
    if (n[e])
      return !1;
  return !0;
}
function OO() {
  return or(Ed(navigator.hardwareConcurrency), void 0);
}
function MO() {
  var n, e = (n = window.Intl) === null || n === void 0 ? void 0 : n.DateTimeFormat;
  if (e) {
    var t = new e().resolvedOptions().timeZone;
    if (t)
      return t;
  }
  var r = -LO();
  return "UTC".concat(r >= 0 ? "+" : "").concat(Math.abs(r));
}
function LO() {
  var n = (/* @__PURE__ */ new Date()).getFullYear();
  return Math.max(
    // `getTimezoneOffset` returns a number as a string in some unidentified cases
    kn(new Date(n, 0, 1).getTimezoneOffset()),
    kn(new Date(n, 6, 1).getTimezoneOffset())
  );
}
function DO() {
  try {
    return !!window.sessionStorage;
  } catch {
    return !0;
  }
}
function UO() {
  try {
    return !!window.localStorage;
  } catch {
    return !0;
  }
}
function VO() {
  if (!(Av() || $I()))
    try {
      return !!window.indexedDB;
    } catch {
      return !0;
    }
}
function BO() {
  return !!window.openDatabase;
}
function HO() {
  return navigator.cpuClass;
}
function FO() {
  var n = navigator.platform;
  return n === "MacIntel" && Js() && !Ad() ? rO() ? "iPad" : "iPhone" : n;
}
function jO() {
  return navigator.vendor || "";
}
function WO() {
  for (var n = [], e = 0, t = [
    // Blink and some browsers on iOS
    "chrome",
    // Safari on macOS
    "safari",
    // Chrome on iOS (checked in 85 on 13 and 87 on 14)
    "__crWeb",
    "__gCrWeb",
    // Yandex Browser on iOS, macOS and Android (checked in 21.2 on iOS 14, macOS and Android)
    "yandex",
    // Yandex Browser on iOS (checked in 21.2 on 14)
    "__yb",
    "__ybro",
    // Firefox on iOS (checked in 32 on 14)
    "__firefox__",
    // Edge on iOS (checked in 46 on 14)
    "__edgeTrackingPreventionStatistics",
    "webkit",
    // Opera Touch on iOS (checked in 2.6 on 14)
    "oprt",
    // Samsung Internet on Android (checked in 11.1)
    "samsungAr",
    // UC Browser on Android (checked in 12.10 and 13.0)
    "ucweb",
    "UCShellJava",
    // Puffin on Android (checked in 9.0)
    "puffinDevice"
    // UC on iOS and Opera on Android have no specific global variables
    // Edge for Android isn't checked
  ]; e < t.length; e++) {
    var r = t[e], i = window[r];
    i && typeof i == "object" && n.push(r);
  }
  return n.sort();
}
function qO() {
  var n = document;
  try {
    n.cookie = "cookietest=1; SameSite=Strict;";
    var e = n.cookie.indexOf("cookietest=") !== -1;
    return n.cookie = "cookietest=1; SameSite=Strict; expires=Thu, 01-Jan-1970 00:00:01 GMT", e;
  } catch {
    return !1;
  }
}
function zO() {
  var n = atob;
  return {
    abpIndo: [
      "#Iklan-Melayang",
      "#Kolom-Iklan-728",
      "#SidebarIklan-wrapper",
      '[title="ALIENBOLA" i]',
      n("I0JveC1CYW5uZXItYWRz")
    ],
    abpvn: [".quangcao", "#mobileCatfish", n("LmNsb3NlLWFkcw=="), '[id^="bn_bottom_fixed_"]', "#pmadv"],
    adBlockFinland: [
      ".mainostila",
      n("LnNwb25zb3JpdA=="),
      ".ylamainos",
      n("YVtocmVmKj0iL2NsaWNrdGhyZ2guYXNwPyJd"),
      n("YVtocmVmXj0iaHR0cHM6Ly9hcHAucmVhZHBlYWsuY29tL2FkcyJd")
    ],
    adBlockPersian: [
      "#navbar_notice_50",
      ".kadr",
      'TABLE[width="140px"]',
      "#divAgahi",
      n("YVtocmVmXj0iaHR0cDovL2cxLnYuZndtcm0ubmV0L2FkLyJd")
    ],
    adBlockWarningRemoval: [
      "#adblock-honeypot",
      ".adblocker-root",
      ".wp_adblock_detect",
      n("LmhlYWRlci1ibG9ja2VkLWFk"),
      n("I2FkX2Jsb2NrZXI=")
    ],
    adGuardAnnoyances: [
      ".hs-sosyal",
      "#cookieconsentdiv",
      'div[class^="app_gdpr"]',
      ".as-oil",
      '[data-cypress="soft-push-notification-modal"]'
    ],
    adGuardBase: [
      ".BetterJsPopOverlay",
      n("I2FkXzMwMFgyNTA="),
      n("I2Jhbm5lcmZsb2F0MjI="),
      n("I2NhbXBhaWduLWJhbm5lcg=="),
      n("I0FkLUNvbnRlbnQ=")
    ],
    adGuardChinese: [
      n("LlppX2FkX2FfSA=="),
      n("YVtocmVmKj0iLmh0aGJldDM0LmNvbSJd"),
      "#widget-quan",
      n("YVtocmVmKj0iLzg0OTkyMDIwLnh5eiJd"),
      n("YVtocmVmKj0iLjE5NTZobC5jb20vIl0=")
    ],
    adGuardFrench: [
      "#pavePub",
      n("LmFkLWRlc2t0b3AtcmVjdGFuZ2xl"),
      ".mobile_adhesion",
      ".widgetadv",
      n("LmFkc19iYW4=")
    ],
    adGuardGerman: ['aside[data-portal-id="leaderboard"]'],
    adGuardJapanese: [
      "#kauli_yad_1",
      n("YVtocmVmXj0iaHR0cDovL2FkMi50cmFmZmljZ2F0ZS5uZXQvIl0="),
      n("Ll9wb3BJbl9pbmZpbml0ZV9hZA=="),
      n("LmFkZ29vZ2xl"),
      n("Ll9faXNib29zdFJldHVybkFk")
    ],
    adGuardMobile: [
      n("YW1wLWF1dG8tYWRz"),
      n("LmFtcF9hZA=="),
      'amp-embed[type="24smi"]',
      "#mgid_iframe1",
      n("I2FkX2ludmlld19hcmVh")
    ],
    adGuardRussian: [
      n("YVtocmVmXj0iaHR0cHM6Ly9hZC5sZXRtZWFkcy5jb20vIl0="),
      n("LnJlY2xhbWE="),
      'div[id^="smi2adblock"]',
      n("ZGl2W2lkXj0iQWRGb3hfYmFubmVyXyJd"),
      "#psyduckpockeball"
    ],
    adGuardSocial: [
      n("YVtocmVmXj0iLy93d3cuc3R1bWJsZXVwb24uY29tL3N1Ym1pdD91cmw9Il0="),
      n("YVtocmVmXj0iLy90ZWxlZ3JhbS5tZS9zaGFyZS91cmw/Il0="),
      ".etsy-tweet",
      "#inlineShare",
      ".popup-social"
    ],
    adGuardSpanishPortuguese: ["#barraPublicidade", "#Publicidade", "#publiEspecial", "#queTooltip", ".cnt-publi"],
    adGuardTrackingProtection: [
      "#qoo-counter",
      n("YVtocmVmXj0iaHR0cDovL2NsaWNrLmhvdGxvZy5ydS8iXQ=="),
      n("YVtocmVmXj0iaHR0cDovL2hpdGNvdW50ZXIucnUvdG9wL3N0YXQucGhwIl0="),
      n("YVtocmVmXj0iaHR0cDovL3RvcC5tYWlsLnJ1L2p1bXAiXQ=="),
      "#top100counter"
    ],
    adGuardTurkish: [
      "#backkapat",
      n("I3Jla2xhbWk="),
      n("YVtocmVmXj0iaHR0cDovL2Fkc2Vydi5vbnRlay5jb20udHIvIl0="),
      n("YVtocmVmXj0iaHR0cDovL2l6bGVuemkuY29tL2NhbXBhaWduLyJd"),
      n("YVtocmVmXj0iaHR0cDovL3d3dy5pbnN0YWxsYWRzLm5ldC8iXQ==")
    ],
    bulgarian: [n("dGQjZnJlZW5ldF90YWJsZV9hZHM="), "#ea_intext_div", ".lapni-pop-over", "#xenium_hot_offers"],
    easyList: [
      ".yb-floorad",
      n("LndpZGdldF9wb19hZHNfd2lkZ2V0"),
      n("LnRyYWZmaWNqdW5reS1hZA=="),
      ".textad_headline",
      n("LnNwb25zb3JlZC10ZXh0LWxpbmtz")
    ],
    easyListChina: [
      n("LmFwcGd1aWRlLXdyYXBbb25jbGljayo9ImJjZWJvcy5jb20iXQ=="),
      n("LmZyb250cGFnZUFkdk0="),
      "#taotaole",
      "#aafoot.top_box",
      ".cfa_popup"
    ],
    easyListCookie: [
      ".ezmob-footer",
      ".cc-CookieWarning",
      "[data-cookie-number]",
      n("LmF3LWNvb2tpZS1iYW5uZXI="),
      ".sygnal24-gdpr-modal-wrap"
    ],
    easyListCzechSlovak: [
      "#onlajny-stickers",
      n("I3Jla2xhbW5pLWJveA=="),
      n("LnJla2xhbWEtbWVnYWJvYXJk"),
      ".sklik",
      n("W2lkXj0ic2tsaWtSZWtsYW1hIl0=")
    ],
    easyListDutch: [
      n("I2FkdmVydGVudGll"),
      n("I3ZpcEFkbWFya3RCYW5uZXJCbG9jaw=="),
      ".adstekst",
      n("YVtocmVmXj0iaHR0cHM6Ly94bHR1YmUubmwvY2xpY2svIl0="),
      "#semilo-lrectangle"
    ],
    easyListGermany: [
      "#SSpotIMPopSlider",
      n("LnNwb25zb3JsaW5rZ3J1ZW4="),
      n("I3dlcmJ1bmdza3k="),
      n("I3Jla2xhbWUtcmVjaHRzLW1pdHRl"),
      n("YVtocmVmXj0iaHR0cHM6Ly9iZDc0Mi5jb20vIl0=")
    ],
    easyListItaly: [
      n("LmJveF9hZHZfYW5udW5jaQ=="),
      ".sb-box-pubbliredazionale",
      n("YVtocmVmXj0iaHR0cDovL2FmZmlsaWF6aW9uaWFkcy5zbmFpLml0LyJd"),
      n("YVtocmVmXj0iaHR0cHM6Ly9hZHNlcnZlci5odG1sLml0LyJd"),
      n("YVtocmVmXj0iaHR0cHM6Ly9hZmZpbGlhemlvbmlhZHMuc25haS5pdC8iXQ==")
    ],
    easyListLithuania: [
      n("LnJla2xhbW9zX3RhcnBhcw=="),
      n("LnJla2xhbW9zX251b3JvZG9z"),
      n("aW1nW2FsdD0iUmVrbGFtaW5pcyBza3lkZWxpcyJd"),
      n("aW1nW2FsdD0iRGVkaWt1b3RpLmx0IHNlcnZlcmlhaSJd"),
      n("aW1nW2FsdD0iSG9zdGluZ2FzIFNlcnZlcmlhaS5sdCJd")
    ],
    estonian: [n("QVtocmVmKj0iaHR0cDovL3BheTRyZXN1bHRzMjQuZXUiXQ==")],
    fanboyAnnoyances: ["#ac-lre-player", ".navigate-to-top", "#subscribe_popup", ".newsletter_holder", "#back-top"],
    fanboyAntiFacebook: [".util-bar-module-firefly-visible"],
    fanboyEnhancedTrackers: [
      ".open.pushModal",
      "#issuem-leaky-paywall-articles-zero-remaining-nag",
      "#sovrn_container",
      'div[class$="-hide"][zoompage-fontsize][style="display: block;"]',
      ".BlockNag__Card"
    ],
    fanboySocial: ["#FollowUs", "#meteored_share", "#social_follow", ".article-sharer", ".community__social-desc"],
    frellwitSwedish: [
      n("YVtocmVmKj0iY2FzaW5vcHJvLnNlIl1bdGFyZ2V0PSJfYmxhbmsiXQ=="),
      n("YVtocmVmKj0iZG9rdG9yLXNlLm9uZWxpbmsubWUiXQ=="),
      "article.category-samarbete",
      n("ZGl2LmhvbGlkQWRz"),
      "ul.adsmodern"
    ],
    greekAdBlock: [
      n("QVtocmVmKj0iYWRtYW4ub3RlbmV0LmdyL2NsaWNrPyJd"),
      n("QVtocmVmKj0iaHR0cDovL2F4aWFiYW5uZXJzLmV4b2R1cy5nci8iXQ=="),
      n("QVtocmVmKj0iaHR0cDovL2ludGVyYWN0aXZlLmZvcnRobmV0LmdyL2NsaWNrPyJd"),
      "DIV.agores300",
      "TABLE.advright"
    ],
    hungarian: [
      "#cemp_doboz",
      ".optimonk-iframe-container",
      n("LmFkX19tYWlu"),
      n("W2NsYXNzKj0iR29vZ2xlQWRzIl0="),
      "#hirdetesek_box"
    ],
    iDontCareAboutCookies: [
      '.alert-info[data-block-track*="CookieNotice"]',
      ".ModuleTemplateCookieIndicator",
      ".o--cookies--container",
      "#cookies-policy-sticky",
      "#stickyCookieBar"
    ],
    icelandicAbp: [n("QVtocmVmXj0iL2ZyYW1ld29yay9yZXNvdXJjZXMvZm9ybXMvYWRzLmFzcHgiXQ==")],
    latvian: [
      n("YVtocmVmPSJodHRwOi8vd3d3LnNhbGlkemluaS5sdi8iXVtzdHlsZT0iZGlzcGxheTogYmxvY2s7IHdpZHRoOiAxMjBweDsgaGVpZ2h0OiA0MHB4OyBvdmVyZmxvdzogaGlkZGVuOyBwb3NpdGlvbjogcmVsYXRpdmU7Il0="),
      n("YVtocmVmPSJodHRwOi8vd3d3LnNhbGlkemluaS5sdi8iXVtzdHlsZT0iZGlzcGxheTogYmxvY2s7IHdpZHRoOiA4OHB4OyBoZWlnaHQ6IDMxcHg7IG92ZXJmbG93OiBoaWRkZW47IHBvc2l0aW9uOiByZWxhdGl2ZTsiXQ==")
    ],
    listKr: [
      n("YVtocmVmKj0iLy9hZC5wbGFuYnBsdXMuY28ua3IvIl0="),
      n("I2xpdmVyZUFkV3JhcHBlcg=="),
      n("YVtocmVmKj0iLy9hZHYuaW1hZHJlcC5jby5rci8iXQ=="),
      n("aW5zLmZhc3R2aWV3LWFk"),
      ".revenue_unit_item.dable"
    ],
    listeAr: [
      n("LmdlbWluaUxCMUFk"),
      ".right-and-left-sponsers",
      n("YVtocmVmKj0iLmFmbGFtLmluZm8iXQ=="),
      n("YVtocmVmKj0iYm9vcmFxLm9yZyJd"),
      n("YVtocmVmKj0iZHViaXp6bGUuY29tL2FyLz91dG1fc291cmNlPSJd")
    ],
    listeFr: [
      n("YVtocmVmXj0iaHR0cDovL3Byb21vLnZhZG9yLmNvbS8iXQ=="),
      n("I2FkY29udGFpbmVyX3JlY2hlcmNoZQ=="),
      n("YVtocmVmKj0id2Vib3JhbWEuZnIvZmNnaS1iaW4vIl0="),
      ".site-pub-interstitiel",
      'div[id^="crt-"][data-criteo-id]'
    ],
    officialPolish: [
      "#ceneo-placeholder-ceneo-12",
      n("W2hyZWZePSJodHRwczovL2FmZi5zZW5kaHViLnBsLyJd"),
      n("YVtocmVmXj0iaHR0cDovL2Fkdm1hbmFnZXIudGVjaGZ1bi5wbC9yZWRpcmVjdC8iXQ=="),
      n("YVtocmVmXj0iaHR0cDovL3d3dy50cml6ZXIucGwvP3V0bV9zb3VyY2UiXQ=="),
      n("ZGl2I3NrYXBpZWNfYWQ=")
    ],
    ro: [
      n("YVtocmVmXj0iLy9hZmZ0cmsuYWx0ZXgucm8vQ291bnRlci9DbGljayJd"),
      n("YVtocmVmXj0iaHR0cHM6Ly9ibGFja2ZyaWRheXNhbGVzLnJvL3Ryay9zaG9wLyJd"),
      n("YVtocmVmXj0iaHR0cHM6Ly9ldmVudC4ycGVyZm9ybWFudC5jb20vZXZlbnRzL2NsaWNrIl0="),
      n("YVtocmVmXj0iaHR0cHM6Ly9sLnByb2ZpdHNoYXJlLnJvLyJd"),
      'a[href^="/url/"]'
    ],
    ruAd: [
      n("YVtocmVmKj0iLy9mZWJyYXJlLnJ1LyJd"),
      n("YVtocmVmKj0iLy91dGltZy5ydS8iXQ=="),
      n("YVtocmVmKj0iOi8vY2hpa2lkaWtpLnJ1Il0="),
      "#pgeldiz",
      ".yandex-rtb-block"
    ],
    thaiAds: [
      "a[href*=macau-uta-popup]",
      n("I2Fkcy1nb29nbGUtbWlkZGxlX3JlY3RhbmdsZS1ncm91cA=="),
      n("LmFkczMwMHM="),
      ".bumq",
      ".img-kosana"
    ],
    webAnnoyancesUltralist: [
      "#mod-social-share-2",
      "#social-tools",
      n("LmN0cGwtZnVsbGJhbm5lcg=="),
      ".zergnet-recommend",
      ".yt.btn-link.btn-md.btn"
    ]
  };
}
function XO(n) {
  var e = n === void 0 ? {} : n, t = e.debug;
  return nr(this, void 0, void 0, function() {
    var r, i, s, a, o, c;
    return Dn(this, function(l) {
      switch (l.label) {
        case 0:
          return GO() ? (r = zO(), i = Object.keys(r), s = (c = []).concat.apply(c, i.map(function(u) {
            return r[u];
          })), [4, ZO(s)]) : [2, void 0];
        case 1:
          return a = l.sent(), t && JO(r, a), o = i.filter(function(u) {
            var f = r[u], m = Un(f.map(function(y) {
              return a[y];
            }));
            return m > f.length * 0.6;
          }), o.sort(), [2, o];
      }
    });
  });
}
function GO() {
  return Js() || Pv();
}
function ZO(n) {
  var e;
  return nr(this, void 0, void 0, function() {
    var t, r, i, s, c, a, o, c;
    return Dn(this, function(l) {
      switch (l.label) {
        case 0:
          for (t = document, r = t.createElement("div"), i = new Array(n.length), s = {}, wm(r), c = 0; c < n.length; ++c)
            a = uO(n[c]), a.tagName === "DIALOG" && a.show(), o = t.createElement("div"), wm(o), o.appendChild(a), r.appendChild(o), i[c] = a;
          l.label = 1;
        case 1:
          return t.body ? [3, 3] : [4, Os(50)];
        case 2:
          return l.sent(), [3, 1];
        case 3:
          t.body.appendChild(r);
          try {
            for (c = 0; c < n.length; ++c)
              i[c].offsetParent || (s[n[c]] = !0);
          } finally {
            (e = r.parentNode) === null || e === void 0 || e.removeChild(r);
          }
          return [2, s];
      }
    });
  });
}
function wm(n) {
  n.style.setProperty("display", "block", "important");
}
function JO(n, e) {
  for (var t = "DOM blockers debug:\n```", r = 0, i = Object.keys(n); r < i.length; r++) {
    var s = i[r];
    t += `
`.concat(s, ":");
    for (var a = 0, o = n[s]; a < o.length; a++) {
      var c = o[a];
      t += `
  `.concat(e[c] ? "" : "", " ").concat(c);
    }
  }
  "".concat(t, "\n```");
}
function KO() {
  for (var n = 0, e = ["rec2020", "p3", "srgb"]; n < e.length; n++) {
    var t = e[n];
    if (matchMedia("(color-gamut: ".concat(t, ")")).matches)
      return t;
  }
}
function YO() {
  if (xm("inverted"))
    return !0;
  if (xm("none"))
    return !1;
}
function xm(n) {
  return matchMedia("(inverted-colors: ".concat(n, ")")).matches;
}
function QO() {
  if (Sm("active"))
    return !0;
  if (Sm("none"))
    return !1;
}
function Sm(n) {
  return matchMedia("(forced-colors: ".concat(n, ")")).matches;
}
var $O = 100;
function eM() {
  if (matchMedia("(min-monochrome: 0)").matches) {
    for (var n = 0; n <= $O; ++n)
      if (matchMedia("(max-monochrome: ".concat(n, ")")).matches)
        return n;
    throw new Error("Too high value");
  }
}
function tM() {
  if (gi("no-preference"))
    return 0;
  if (gi("high") || gi("more"))
    return 1;
  if (gi("low") || gi("less"))
    return -1;
  if (gi("forced"))
    return 10;
}
function gi(n) {
  return matchMedia("(prefers-contrast: ".concat(n, ")")).matches;
}
function nM() {
  if (Em("reduce"))
    return !0;
  if (Em("no-preference"))
    return !1;
}
function Em(n) {
  return matchMedia("(prefers-reduced-motion: ".concat(n, ")")).matches;
}
function rM() {
  if (Cm("high"))
    return !0;
  if (Cm("standard"))
    return !1;
}
function Cm(n) {
  return matchMedia("(dynamic-range: ".concat(n, ")")).matches;
}
var Ae = Math, Gt = function() {
  return 0;
};
function iM() {
  var n = Ae.acos || Gt, e = Ae.acosh || Gt, t = Ae.asin || Gt, r = Ae.asinh || Gt, i = Ae.atanh || Gt, s = Ae.atan || Gt, a = Ae.sin || Gt, o = Ae.sinh || Gt, c = Ae.cos || Gt, l = Ae.cosh || Gt, u = Ae.tan || Gt, f = Ae.tanh || Gt, m = Ae.exp || Gt, y = Ae.expm1 || Gt, _ = Ae.log1p || Gt, v = function(U) {
    return Ae.pow(Ae.PI, U);
  }, C = function(U) {
    return Ae.log(U + Ae.sqrt(U * U - 1));
  }, A = function(U) {
    return Ae.log(U + Ae.sqrt(U * U + 1));
  }, R = function(U) {
    return Ae.log((1 + U) / (1 - U)) / 2;
  }, I = function(U) {
    return Ae.exp(U) - 1 / Ae.exp(U) / 2;
  }, D = function(U) {
    return (Ae.exp(U) + 1 / Ae.exp(U)) / 2;
  }, L = function(U) {
    return Ae.exp(U) - 1;
  }, V = function(U) {
    return (Ae.exp(2 * U) - 1) / (Ae.exp(2 * U) + 1);
  }, F = function(U) {
    return Ae.log(1 + U);
  };
  return {
    acos: n(0.12312423423423424),
    acosh: e(1e308),
    acoshPf: C(1e154),
    asin: t(0.12312423423423424),
    asinh: r(1),
    asinhPf: A(1),
    atanh: i(0.5),
    atanhPf: R(0.5),
    atan: s(0.5),
    sin: a(-1e300),
    sinh: o(1),
    sinhPf: I(1),
    cos: c(10.000000000123),
    cosh: l(1),
    coshPf: D(1),
    tan: u(-1e300),
    tanh: f(1),
    tanhPf: V(1),
    exp: m(1),
    expm1: y(1),
    expm1Pf: L(1),
    log1p: _(10),
    log1pPf: F(10),
    powPI: v(-100)
  };
}
var sM = "mmMwWLliI0fiflO&1", Kc = {
  /**
   * The default font. User can change it in desktop Chrome, desktop Firefox, IE 11,
   * Android Chrome (but only when the size is  than the default) and Android Firefox.
   */
  default: [],
  /** OS font on macOS. User can change its size and weight. Applies after Safari restart. */
  apple: [{ font: "-apple-system-body" }],
  /** User can change it in desktop Chrome and desktop Firefox. */
  serif: [{ fontFamily: "serif" }],
  /** User can change it in desktop Chrome and desktop Firefox. */
  sans: [{ fontFamily: "sans-serif" }],
  /** User can change it in desktop Chrome and desktop Firefox. */
  mono: [{ fontFamily: "monospace" }],
  /**
   * Check the smallest allowed font size. User can change it in desktop Chrome, desktop Firefox and desktop Safari.
   * The height can be 0 in Chrome on a retina display.
   */
  min: [{ fontSize: "1px" }],
  /** Tells one OS from another in desktop Chrome. */
  system: [{ fontFamily: "system-ui" }]
};
function aM() {
  return oM(function(n, e) {
    for (var t = {}, r = {}, i = 0, s = Object.keys(Kc); i < s.length; i++) {
      var a = s[i], o = Kc[a], c = o[0], l = c === void 0 ? {} : c, u = o[1], f = u === void 0 ? sM : u, m = n.createElement("span");
      m.textContent = f, m.style.whiteSpace = "nowrap";
      for (var y = 0, _ = Object.keys(l); y < _.length; y++) {
        var v = _[y], C = l[v];
        C !== void 0 && (m.style[v] = C);
      }
      t[a] = m, e.appendChild(n.createElement("br")), e.appendChild(m);
    }
    for (var A = 0, R = Object.keys(Kc); A < R.length; A++) {
      var a = R[A];
      r[a] = t[a].getBoundingClientRect().width;
    }
    return r;
  });
}
function oM(n, e) {
  return e === void 0 && (e = 4e3), kv(function(t, r) {
    var i = r.document, s = i.body, a = s.style;
    a.width = "".concat(e, "px"), a.webkitTextSizeAdjust = a.textSizeAdjust = "none", Cd() ? s.style.zoom = "".concat(1 / r.devicePixelRatio) : Js() && (s.style.zoom = "reset");
    var o = i.createElement("div");
    return o.textContent = $n([], Array(e / 20 << 0), !0).map(function() {
      return "word";
    }).join(" "), s.appendChild(o), n(i, s);
  }, '<!doctype html><html><head><meta name="viewport" content="width=device-width, initial-scale=1">');
}
function cM() {
  var n, e = document.createElement("canvas"), t = (n = e.getContext("webgl")) !== null && n !== void 0 ? n : e.getContext("experimental-webgl");
  if (t && "getExtension" in t) {
    var r = t.getExtension("WEBGL_debug_renderer_info");
    if (r)
      return {
        vendor: (t.getParameter(r.UNMASKED_VENDOR_WEBGL) || "").toString(),
        renderer: (t.getParameter(r.UNMASKED_RENDERER_WEBGL) || "").toString()
      };
  }
}
function lM() {
  return navigator.pdfViewerEnabled;
}
function uM() {
  var n = new Float32Array(1), e = new Uint8Array(n.buffer);
  return n[0] = 1 / 0, n[0] = n[0] - n[0], e[3];
}
var dM = {
  // READ FIRST:
  // See https://github.com/fingerprintjs/fingerprintjs/blob/master/contributing.md#how-to-make-an-entropy-source
  // to learn how entropy source works and how to make your own.
  // The sources run in this exact order.
  // The asynchronous sources are at the start to run in parallel with other sources.
  fonts: pO,
  domBlockers: XO,
  fontPreferences: aM,
  audio: aO,
  screenFrame: IO,
  osCpu: SO,
  languages: EO,
  colorDepth: CO,
  deviceMemory: AO,
  screenResolution: PO,
  hardwareConcurrency: OO,
  timezone: MO,
  sessionStorage: DO,
  localStorage: UO,
  indexedDB: VO,
  openDatabase: BO,
  cpuClass: HO,
  platform: FO,
  plugins: mO,
  canvas: gO,
  touchSupport: xO,
  vendor: jO,
  vendorFlavors: WO,
  cookiesEnabled: qO,
  colorGamut: KO,
  invertedColors: YO,
  forcedColors: QO,
  monochrome: eM,
  contrast: tM,
  reducedMotion: nM,
  hdr: rM,
  math: iM,
  videoCard: cM,
  pdfViewerEnabled: lM,
  architecture: uM
};
function fM(n) {
  return QI(dM, n, []);
}
var hM = "$ if upgrade to Pro: https://fpjs.dev/pro";
function pM(n) {
  var e = mM(n), t = gM(e);
  return { score: e, comment: hM.replace(/\$/g, "".concat(t)) };
}
function mM(n) {
  if (Pv())
    return 0.4;
  if (Js())
    return Ad() ? 0.5 : 0.3;
  var e = n.platform.value || "";
  return /^Win/.test(e) ? 0.6 : /^Mac/.test(e) ? 0.5 : 0.7;
}
function gM(n) {
  return Cv(0.99 + 0.01 * n, 1e-4);
}
function yM(n) {
  for (var e = "", t = 0, r = Object.keys(n).sort(); t < r.length; t++) {
    var i = r[t], s = n[i], a = s.error ? "error" : JSON.stringify(s.value);
    e += "".concat(e ? "|" : "").concat(i.replace(/([:|\\])/g, "\\$1"), ":").concat(a);
  }
  return e;
}
function _M(n) {
  return JSON.stringify(n, function(e, t) {
    return t instanceof Error ? XI(t) : t;
  }, 2);
}
function Tv(n) {
  return zI(yM(n));
}
function vM(n) {
  var e, t = pM(n);
  return {
    get visitorId() {
      return e === void 0 && (e = Tv(this.components)), e;
    },
    set visitorId(r) {
      e = r;
    },
    confidence: t,
    components: n,
    version: Sv
  };
}
function bM(n) {
  return n === void 0 && (n = 50), qI(n, n * 2);
}
function wM(n, e) {
  var t = Date.now();
  return {
    get: function(r) {
      return nr(this, void 0, void 0, function() {
        var i, s, a;
        return Dn(this, function(o) {
          switch (o.label) {
            case 0:
              return i = Date.now(), [4, n()];
            case 1:
              return s = o.sent(), a = vM(s), (e || r != null && r.debug) && "Copy the text below to get the debug data:\n\n```\nversion: ".concat(a.version, `
userAgent: `).concat(navigator.userAgent, `
timeBetweenLoadAndGet: `).concat(i - t, `
visitorId: `).concat(a.visitorId, `
components: `).concat(_M(s), "\n```"), [2, a];
          }
        });
      });
    }
  };
}
function xM() {
  if (!(window.__fpjs_d_m || Math.random() >= 1e-3))
    try {
      var n = new XMLHttpRequest();
      n.open("get", "https://m1.openfpcdn.io/fingerprintjs/v".concat(Sv, "/npm-monitoring"), !0), n.send();
    } catch (e) {
      console.error(e);
    }
}
function SM(n) {
  var e = n === void 0 ? {} : n, t = e.delayFallback, r = e.debug, i = e.monitoring, s = i === void 0 ? !0 : i;
  return nr(this, void 0, void 0, function() {
    var a;
    return Dn(this, function(o) {
      switch (o.label) {
        case 0:
          return s && xM(), [4, bM(t)];
        case 1:
          return o.sent(), a = fM({ debug: r }), [2, wM(a, r)];
      }
    });
  });
}
function Ir(n, e) {
  n = [H(n, 0) >>> 16, H(n, 0) & 65535, H(n, 1) >>> 16, H(n, 1) & 65535], e = [H(e, 0) >>> 16, H(e, 0) & 65535, H(e, 1) >>> 16, H(e, 1) & 65535];
  const t = [0, 0, 0, 0];
  return t[3] += H(n, 3) + H(e, 3), t[2] += H(t, 3) >>> 16, t[3] &= 65535, t[2] += H(n, 2) + H(e, 2), t[1] += H(t, 2) >>> 16, t[2] &= 65535, t[1] += H(n, 1) + H(e, 1), t[0] += H(t, 1) >>> 16, t[1] &= 65535, t[0] += H(n, 0) + H(e, 0), t[0] &= 65535, [H(t, 0) << 16 | H(t, 1), H(t, 2) << 16 | H(t, 3)];
}
function yn(n, e) {
  n = [H(n, 0) >>> 16, H(n, 0) & 65535, H(n, 1) >>> 16, H(n, 1) & 65535], e = [H(e, 0) >>> 16, H(e, 0) & 65535, H(e, 1) >>> 16, H(e, 1) & 65535];
  const t = [0, 0, 0, 0];
  return t[3] += H(n, 3) * H(e, 3), t[2] += H(t, 3) >>> 16, t[3] &= 65535, t[2] += H(n, 2) * H(e, 3), t[1] += H(t, 2) >>> 16, t[2] &= 65535, t[2] += H(n, 3) * H(e, 2), t[1] += H(t, 2) >>> 16, t[2] &= 65535, t[1] += H(n, 1) * H(e, 3), t[0] += H(t, 1) >>> 16, t[1] &= 65535, t[1] += H(n, 2) * H(e, 2), t[0] += H(t, 1) >>> 16, t[1] &= 65535, t[1] += H(n, 3) * H(e, 1), t[0] += H(t, 1) >>> 16, t[1] &= 65535, t[0] += H(n, 0) * H(e, 3) + H(n, 1) * H(e, 2) + H(n, 2) * H(e, 1) + H(n, 3) * H(e, 0), t[0] &= 65535, [H(t, 0) << 16 | H(t, 1), H(t, 2) << 16 | H(t, 3)];
}
function yi(n, e) {
  return e %= 64, e === 32 ? [H(n, 1), H(n, 0)] : e < 32 ? [H(n, 0) << e | H(n, 1) >>> 32 - e, H(n, 1) << e | H(n, 0) >>> 32 - e] : (e -= 32, [H(n, 1) << e | H(n, 0) >>> 32 - e, H(n, 0) << e | H(n, 1) >>> 32 - e]);
}
function ln(n, e) {
  return e %= 64, e === 0 ? n : e < 32 ? [H(n, 0) << e | H(n, 1) >>> 32 - e, H(n, 1) << e] : [H(n, 1) << e - 32, 0];
}
function Be(n, e) {
  return [H(n, 0) ^ H(e, 0), H(n, 1) ^ H(e, 1)];
}
function Am(n) {
  return n = Be(n, [0, H(n, 0) >>> 1]), n = yn(n, [4283543511, 3981806797]), n = Be(n, [0, H(n, 0) >>> 1]), n = yn(n, [3301882366, 444984403]), n = Be(n, [0, H(n, 0) >>> 1]), n;
}
function EM(n, e) {
  n = n || "", e = e || 0;
  const t = n.length % 16, r = n.length - t;
  let i = [0, e], s = [0, e], a = [0, 0], o = [0, 0];
  const c = [2277735313, 289559509], l = [1291169091, 658871167];
  let u = 0;
  for (u = 0; u < r; u = u + 16)
    a = [
      n.charCodeAt(u + 4) & 255 | (n.charCodeAt(u + 5) & 255) << 8 | (n.charCodeAt(u + 6) & 255) << 16 | (n.charCodeAt(u + 7) & 255) << 24,
      n.charCodeAt(u) & 255 | (n.charCodeAt(u + 1) & 255) << 8 | (n.charCodeAt(u + 2) & 255) << 16 | (n.charCodeAt(u + 3) & 255) << 24
    ], o = [
      n.charCodeAt(u + 12) & 255 | (n.charCodeAt(u + 13) & 255) << 8 | (n.charCodeAt(u + 14) & 255) << 16 | (n.charCodeAt(u + 15) & 255) << 24,
      n.charCodeAt(u + 8) & 255 | (n.charCodeAt(u + 9) & 255) << 8 | (n.charCodeAt(u + 10) & 255) << 16 | (n.charCodeAt(u + 11) & 255) << 24
    ], a = yn(a, c), a = yi(a, 31), a = yn(a, l), i = Be(i, a), i = yi(i, 27), i = Ir(i, s), i = Ir(yn(i, [0, 5]), [0, 1390208809]), o = yn(o, l), o = yi(o, 33), o = yn(o, c), s = Be(s, o), s = yi(s, 31), s = Ir(s, i), s = Ir(yn(s, [0, 5]), [0, 944331445]);
  switch (a = [0, 0], o = [0, 0], t) {
    case 15:
      o = Be(o, ln([0, n.charCodeAt(u + 14)], 48));
      break;
    case 14:
      o = Be(o, ln([0, n.charCodeAt(u + 13)], 40));
      break;
    case 13:
      o = Be(o, ln([0, n.charCodeAt(u + 12)], 32));
      break;
    case 12:
      o = Be(o, ln([0, n.charCodeAt(u + 11)], 24));
      break;
    case 11:
      o = Be(o, ln([0, n.charCodeAt(u + 10)], 16));
      break;
    case 10:
      o = Be(o, ln([0, n.charCodeAt(u + 9)], 8));
      break;
    case 9:
      o = Be(o, [0, n.charCodeAt(u + 8)]), o = yn(o, l), o = yi(o, 33), o = yn(o, c), s = Be(s, o);
      break;
    case 8:
      a = Be(a, ln([0, n.charCodeAt(u + 7)], 56));
      break;
    case 7:
      a = Be(a, ln([0, n.charCodeAt(u + 6)], 48));
      break;
    case 6:
      a = Be(a, ln([0, n.charCodeAt(u + 5)], 40));
      break;
    case 5:
      a = Be(a, ln([0, n.charCodeAt(u + 4)], 32));
      break;
    case 4:
      a = Be(a, ln([0, n.charCodeAt(u + 3)], 24));
      break;
    case 3:
      a = Be(a, ln([0, n.charCodeAt(u + 2)], 16));
      break;
    case 2:
      a = Be(a, ln([0, n.charCodeAt(u + 1)], 8));
      break;
    case 1:
      a = Be(a, [0, n.charCodeAt(u)]), a = yn(a, c), a = yi(a, 31), a = yn(a, l), i = Be(i, a);
  }
  return i = Be(i, [0, n.length]), s = Be(s, [0, n.length]), i = Ir(i, s), s = Ir(s, i), i = Am(i), s = Am(s), i = Ir(i, s), s = Ir(s, i), ("00000000" + (H(i, 0) >>> 0).toString(16)).slice(-8) + ("00000000" + (H(i, 1) >>> 0).toString(16)).slice(-8) + ("00000000" + (H(s, 0) >>> 0).toString(16)).slice(-8) + ("00000000" + (H(s, 1) >>> 0).toString(16)).slice(-8);
}
function CM(n, e, t) {
  const { area: r, offsetParameter: i, multiplier: s, fontSizeFactor: a, maxShadowBlur: o } = t;
  class c {
    constructor(v) {
      this.currentNumber = v % i, this.currentNumber <= 0 && (this.currentNumber += i);
    }
    getNext() {
      return this.currentNumber = s * this.currentNumber % i, this.currentNumber;
    }
  }
  function l(_, v, C) {
    return _ = (_ - 1) / i, C ? _ * v : Math.floor(_ * v);
  }
  function u(_, v, C) {
    const A = v.createRadialGradient(l(_.getNext(), C.width, void 0), l(_.getNext(), C.height, void 0), l(_.getNext(), C.width, void 0), l(_.getNext(), C.width, void 0), l(_.getNext(), C.height, void 0), l(_.getNext(), C.width, void 0));
    A.addColorStop(0, H(m, l(_.getNext(), m.length, void 0))), A.addColorStop(1, H(m, l(_.getNext(), m.length, void 0))), v.fillStyle = A;
  }
  function f(_, v) {
    const R = [];
    for (let I = 0; I < v; I++) {
      const D = 65 + _.getNext() % 61;
      R.push(String.fromCharCode(D));
    }
    return R.join("");
  }
  if (window.CanvasRenderingContext2D)
    return "unknown";
  const m = [
    "#FF6633",
    "#FFB399",
    "#FF33FF",
    "#FFFF99",
    "#00B3E6",
    "#E6B333",
    "#3366E6",
    "#999966",
    "#99FF99",
    "#B34D4D",
    "#80B300",
    "#809900",
    "#E6B3B3",
    "#6680B3",
    "#66991A",
    "#FF99E6",
    "#CCFF1A",
    "#FF1A66",
    "#E6331A",
    "#33FFCC",
    "#66994D",
    "#B366CC",
    "#4D8000",
    "#B33300",
    "#CC80CC",
    "#66664D",
    "#991AFF",
    "#E666FF",
    "#4DB3FF",
    "#1AB399",
    "#E666B3",
    "#33991A",
    "#CC9999",
    "#B3B31A",
    "#00E680",
    "#4D8066",
    "#809980",
    "#E6FF80",
    "#1AFF33",
    "#999933",
    "#FF3380",
    "#CCCC00",
    "#66E64D",
    "#4D80CC",
    "#9900B3",
    "#E64D66",
    "#4DB380",
    "#FF4D4D",
    "#99E6E6",
    "#6666FF"
  ], y = [
    function(v, C, A) {
      C.beginPath(), C.arc(l(v.getNext(), A.width, void 0), l(v.getNext(), A.height, void 0), l(v.getNext(), Math.min(A.width, A.height), void 0), l(v.getNext(), 2 * Math.PI, !0), l(v.getNext(), 2 * Math.PI, !0)), C.stroke();
    },
    function(v, C, A) {
      const R = Math.max(1, l(v.getNext(), 5, void 0)), I = f(v, R);
      C.font = `${A.height / a}px aafakefontaa`, C.strokeText(I, l(v.getNext(), A.width, void 0), l(v.getNext(), A.height, void 0), l(v.getNext(), A.width, void 0));
    },
    function(v, C, A) {
      C.beginPath(), C.moveTo(l(v.getNext(), A.width, void 0), l(v.getNext(), A.height, void 0)), C.bezierCurveTo(l(v.getNext(), A.width, void 0), l(v.getNext(), A.height, void 0), l(v.getNext(), A.width, void 0), l(v.getNext(), A.height, void 0), l(v.getNext(), A.width, void 0), l(v.getNext(), A.height, void 0)), C.stroke();
    },
    function(v, C, A) {
      C.beginPath(), C.moveTo(l(v.getNext(), A.width, void 0), l(v.getNext(), A.height, void 0)), C.quadraticCurveTo(l(v.getNext(), A.width, void 0), l(v.getNext(), A.height, void 0), l(v.getNext(), A.width, void 0), l(v.getNext(), A.height, void 0)), C.stroke();
    },
    function(v, C, A) {
      C.beginPath(), C.ellipse(l(v.getNext(), A.width, void 0), l(v.getNext(), A.height, void 0), l(v.getNext(), Math.floor(A.width / 2), void 0), l(v.getNext(), Math.floor(A.height / 2), void 0), l(v.getNext(), 2 * Math.PI, !0), l(v.getNext(), 2 * Math.PI, !0), l(v.getNext(), 2 * Math.PI, !0)), C.stroke();
    }
  ];
  try {
    const _ = new c(e), v = document.createElement("canvas");
    v.width = r.width, v.height = r.height, v.style.display = "none";
    const C = v.getContext("2d");
    if (C !== null)
      for (let A = 0; A < n; A++)
        u(_, C, r), C.shadowBlur = l(_.getNext(), o, void 0), C.shadowColor = H(m, l(_.getNext(), m.length, void 0)), H(y, l(_.getNext(), y.length, void 0))(_, C, r), C.fill();
    return EM(v.toDataURL(), e);
  } catch (_) {
    throw new cr("WIDGET.CANVAS", { context: { error: _ } });
  }
}
let Yc, Pm = 0;
class AM {
  constructor(e) {
    Yc = e;
  }
  async signPayload(e) {
    const t = ++Pm;
    return {
      ...await Yc("pub(extrinsic.sign)", e),
      id: t
    };
  }
  async signRaw(e) {
    const t = ++Pm;
    return {
      ...await Yc("pub(bytes.sign)", e),
      id: t
    };
  }
}
class PM extends x0 {
  async getAccount(e) {
    const t = Ql(e), r = new Zs(t.endpoint), i = await this.createAccount(r), s = await this.createExtension(i);
    return {
      account: i,
      extension: s
    };
  }
  async createExtension(e) {
    const t = new AM(async () => {
    });
    return t.signRaw = async (r) => {
      const i = e.keypair.sign(r.data);
      return {
        id: 1,
        signature: pe(i)
      };
    }, {
      accounts: {
        get: async () => [e],
        subscribe: () => () => {
        }
      },
      name: "procaptcha-web2",
      version: "0.1.11",
      signer: t
    };
  }
  async createAccount(e) {
    const t = {
      area: { width: 300, height: 300 },
      offsetParameter: 2001000001,
      multiplier: 15e3,
      fontSizeFactor: 1.5,
      maxShadowBlur: 50,
      numberOfRounds: 5,
      seed: 42
    }, r = await this.getFingerprint(), i = CM(t.numberOfRounds, t.seed, t), s = Ha([i, r].join(""), 128).slice(2), a = Ze(s), o = eA(a), c = await Is.create({ provider: e, initWasm: !1 }), l = "ed25519", f = new io({ type: l, ss58Format: c.registry.chainSS58 }).addFromMnemonic(o), m = f.address.length === 42 ? f.address : bo(rn(f.address), c.registry.chainSS58);
    return {
      address: m,
      type: l,
      name: m,
      keypair: f
    };
  }
  async getFingerprint() {
    const r = await (await SM()).get(), { screenFrame: i, ...s } = r.components;
    return Tv(s);
  }
}
const kM = 1e3, Pd = (n, e) => {
  e((t) => {
    let r = [...t, n];
    return r.length > kM && (r = r.slice(1)), r;
  });
}, TM = (n, e) => {
  const t = {
    x: n.x,
    y: n.y,
    timestamp: n.timeStamp
  };
  Pd(t, e);
}, km = (n, e) => {
  const t = {
    key: n.key,
    timestamp: n.timeStamp,
    isShiftKey: n.shiftKey,
    isCtrlKey: n.ctrlKey
  };
  Pd(t, e);
}, pa = (n, e) => {
  for (let t = 0; t < n.touches.length; t++) {
    const r = n.touches[t];
    r && Pd({ x: r.clientX, y: r.clientY, timestamp: n.timeStamp }, e);
  }
}, NM = (n, e, t, r) => {
  const i = Nv(r);
  i && (i.addEventListener("mousemove", (s) => TM(s, n)), i.addEventListener("keydown", (s) => km(s, t)), i.addEventListener("keyup", (s) => km(s, t)), i.addEventListener("touchstart", (s) => pa(s, e)), i.addEventListener("touchend", (s) => pa(s, e)), i.addEventListener("touchcancel", (s) => pa(s, e)), i.addEventListener("touchmove", (s) => pa(s, e)));
}, Nv = (n) => n.tagName === "FORM" ? n : n.parentElement ? Nv(n.parentElement) : null, RM = Nm`{
  &:before {
    content: '""';
    position: absolute;
    height: 100%;
    width: 100%;
  }
}`, IM = {
  width: "2.2em",
  height: "2.2em",
  top: "auto",
  left: "auto",
  opacity: "1",
  borderRadius: "12.5%",
  appearance: "none",
  cursor: "pointer",
  margin: "0",
  borderStyle: "solid",
  borderWidth: "1px"
}, OM = ({ themeColor: n, onChange: e, checked: t }) => {
  const r = we.useMemo(() => n === "light" ? Ls : Ds, [n]), i = {
    ...IM,
    border: `1px solid ${r.palette.background.contrastText}`
  }, [s, a] = we.useState(!1), o = we.useMemo(() => ({
    ...i,
    borderColor: s ? r.palette.background.contrastText : r.palette.grey[400],
    appearance: t ? "auto" : "none"
  }), [s, r, t]);
  return ge("input", { onMouseEnter: () => a(!0), onMouseLeave: () => a(!1), css: RM, type: "checkbox", "aria-live": "assertive", "aria-haspopup": "true", onChange: e, checked: t, style: o });
}, MM = OM, LM = ({ onProcessData: n, sendData: e }) => {
  const [t, r] = we.useState([]), [i, s] = we.useState([]), [a, o] = we.useState([]), c = we.useRef(null);
  return we.useEffect(() => {
    c && c.current && NM(r, s, o, c.current);
  }, []), we.useEffect(() => {
    n({
      mouseEvents: t,
      touchEvents: i,
      keyboardEvents: a
    });
  }, [e]), ge("div", { ref: c });
}, DM = LM, UM = Uv.memo((n, e) => {
  const { show: t, children: r } = n, s = {
    position: "fixed",
    zIndex: 2147483646,
    inset: 0,
    display: t ? "block" : "none"
  }, a = {
    position: "fixed",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    right: 0,
    bottom: 0,
    top: 0,
    left: 0,
    backgroundColor: "rgba(0, 0, 0, 0.5)",
    zIndex: -1
  }, o = {
    position: "absolute",
    top: "50%",
    left: "50%",
    transform: "translate(-50%, -50%)",
    width: "400px",
    backgroundColor: "rgb(255, 255, 255)",
    border: "none",
    boxShadow: "rgba(0, 0, 0, 0.2) 0px 11px 15px -7px, rgba(0, 0, 0, 0.14) 0px 24px 38px 3px, rgba(0, 0, 0, 0.12) 0px 9px 46px 8px,"
  };
  return dn("div", { className: "modalOuter", style: s, children: [ge("div", { className: "modalBackground", style: a }), ge("div", { className: "modalInner", style: o, children: r })] });
}), VM = UM, Tm = Nm`
    align-items: center;
    justify-content: flex-end;
    display: flex;
    padding: 8px;

    @media (max-width: 245px) {
        &:nth-of-type(1),
        &:nth-of-type(2) {
            display: none;
        } /* Both logos hidden */
    }

    @media (min-width: 245px) and (max-width: 400px) {
        &:nth-of-type(1) {
            display: flex;
        } /* logoWithText */
        &:nth-of-type(2) {
            display: none;
        } /* logoWithoutText */
    }

    @media (min-width: 401px) {
        &:nth-of-type(1) {
            display: none;
        } /* logoWithText */
        &:nth-of-type(2) {
            display: flex;
        } /* logoWithoutText */
    }
`, cs = (n) => {
  const e = we.useRef(n), t = (i) => {
    e.current = i;
  };
  return [e.current, t];
}, BM = () => {
  const [n, e] = we.useState(!1), [t, r] = we.useState(0), [i, s] = we.useState([]), [a, o] = cs(void 0), [c, l] = we.useState(!1), [u, f] = we.useState(void 0), [m, y] = we.useState(!1), [_, v] = we.useState(void 0), [C, A] = we.useState(void 0), [R, I] = cs(void 0), [D, L] = cs(void 0), [V, F] = cs(void 0), [U, Y] = cs(void 0), [Q, O] = we.useState(!1);
  return [
    {
      isHuman: n,
      index: t,
      solutions: i,
      captchaApi: a,
      showModal: c,
      challenge: u,
      loading: m,
      account: _,
      dappAccount: C,
      submission: R,
      timeout: D,
      blockNumber: V,
      successfullChallengeTimeout: U,
      sendData: Q
    },
    (B) => {
      B.account !== void 0 && v(B.account), B.isHuman !== void 0 && e(B.isHuman), B.index !== void 0 && r(B.index), B.solutions !== void 0 && s(B.solutions.slice()), B.captchaApi !== void 0 && o(B.captchaApi), B.showModal !== void 0 && l(B.showModal), B.challenge !== void 0 && f(B.challenge), B.loading !== void 0 && y(B.loading), B.showModal !== void 0 && l(B.showModal), B.dappAccount !== void 0 && A(B.dappAccount), B.submission !== void 0 && I(B.submission), B.timeout !== void 0 && L(B.timeout), B.successfullChallengeTimeout !== void 0 && Y(B.timeout), B.blockNumber !== void 0 && F(B.blockNumber), B.sendData !== void 0 && O(B.sendData);
    }
  ];
}, $M = (n) => {
  n.config;
  const e = n.config, t = n.callbacks || {}, [r, i] = BM(), s = WI(e, r, i, t), a = { maxWidth: "400px", minWidth: "200px", margin: "8px" }, o = n.config.theme === "light" ? "light" : "dark", c = we.useMemo(() => n.config.theme === "light" ? Ls : Ds, [n.config.theme]);
  return r.showModal, dn("div", { children: [dn("div", { style: { maxWidth: "100%", maxHeight: "100%", overflowX: "auto" }, children: [ge(VM, { show: r.showModal, children: r.challenge ? ge(RE, { challenge: r.challenge, index: r.index, solutions: r.solutions, onSubmit: s.submit, onCancel: s.cancel, onClick: s.select, onNext: s.nextRound, themeColor: e.theme ?? "light" }) : ge("div", { children: "No challenge set." }) }), dn("div", { style: a, "data-cy": "button-human", children: [" ", dn("div", { style: {
    padding: "8px",
    border: "1px solid",
    backgroundColor: c.palette.background.default,
    borderColor: c.palette.grey[300],
    borderRadius: "8px",
    display: "flex",
    justifyContent: "space-between",
    alignItems: "center",
    flexWrap: "wrap"
  }, children: [ge("div", { style: { display: "flex", flexDirection: "column" }, children: dn("div", { style: {
    display: "flex",
    justifyContent: "flex-start",
    alignItems: "center",
    flexWrap: "wrap"
  }, children: [dn("div", { style: {
    height: "50px",
    width: "50px",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    flexDirection: "column",
    verticalAlign: "middle"
  }, children: [ge("div", { style: {
    display: r.loading ? "none" : "flex"
  }, children: ge(MM, { themeColor: o, onChange: s.start, checked: r.isHuman }) }), ge("div", { style: {
    display: r.loading ? "flex" : "none"
  }, children: ge("div", { style: { flex: 1 }, children: ge(Vv, { themeColor: o }) }) })] }), ge("div", { style: { padding: 1 }, children: ge("span", { style: { color: c.palette.background.contrastText, paddingLeft: "4px" }, children: "I am a human" }) })] }) }), ge("div", { children: ge("a", { href: "https://www.prosopo.io/#features?ref=accounts.prosopo.io&utm_campaign=widget&utm_medium=checkbox", target: "_blank", "aria-label": "Visit prosopo.io to learn more about the service and its accessibility options.", children: ge("div", { children: dn("div", { children: [ge("div", { css: Tm, dangerouslySetInnerHTML: {
    __html: n.config.theme === "light" ? WM : jM
  } }), ge("div", { css: Tm, dangerouslySetInnerHTML: {
    __html: n.config.theme === "light" ? HM : FM
  } })] }) }) }) })] })] })] }), e.devOnlyWatchEvents && ge(DM, { onProcessData: s.exportData, sendData: r.showModal })] });
}, HM = '<svg id="Layer_1" data-name="Layer 1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 2062.63 468.67" height="35px" width="140px"><defs><style>.cls-1{fill:#1d1d1b;}</style></defs><title>Prosopo Logo Black</title><path class="cls-1" d="M335.55,1825.19A147.75,147.75,0,0,1,483.3,1972.94h50.5c0-109.49-88.76-198.25-198.25-198.25v50.5Z" transform="translate(-215.73 -1774.69)"/><path class="cls-1" d="M269.36,1891.39A147.74,147.74,0,0,1,417.1,2039.13h50.5c0-109.49-88.75-198.24-198.24-198.24v50.5Z" transform="translate(-215.73 -1774.69)"/><path class="cls-1" d="M414,2157.17a147.75,147.75,0,0,1-147.74-147.74h-50.5c0,109.49,88.75,198.24,198.24,198.24v-50.5Z" transform="translate(-215.73 -1774.69)"/><path class="cls-1" d="M480.17,2091a147.74,147.74,0,0,1-147.74-147.75H281.92c0,109.49,88.76,198.25,198.25,198.25V2091Z" transform="translate(-215.73 -1774.69)"/><path class="cls-1" d="M862.8,2017.5q-27.39,22.86-78.25,22.86h-65v112.19H654.82v-312h134q46.32,0,73.86,24.13t27.55,74.72Q890.2,1994.64,862.8,2017.5ZM813,1905.1q-12.37-10.36-34.7-10.38H719.59v91.87h58.75q22.32,0,34.7-11.22t12.39-35.56Q825.43,1915.48,813,1905.1Z" transform="translate(-215.73 -1774.69)"/><path class="cls-1" d="M1045.69,1916.42c.78.08,2.51.19,5.19.32v61.81c-3.81-.42-7.2-.71-10.16-.85s-5.36-.21-7.2-.21q-36.4,0-48.89,23.71-7,13.33-7,41.06v110.29H916.89V1921.82h57.58V1962q14-23.07,24.34-31.54,16.94-14.18,44-14.18C1044,1916.32,1044.92,1916.35,1045.69,1916.42Z" transform="translate(-215.73 -1774.69)"/><path class="cls-1" d="M1265.64,2124.32q-29.21,36.06-88.69,36.06t-88.69-36.06Q1059,2088.26,1059,2037.5q0-49.9,29.22-86.5t88.69-36.59q59.47,0,88.69,36.59t29.21,86.5Q1294.85,2088.26,1265.64,2124.32ZM1217.38,2091q14.17-18.81,14.18-53.48t-14.18-53.37q-14.19-18.7-40.64-18.71T1136,1984.13q-14.29,18.72-14.29,53.37T1136,2091q14.28,18.81,40.75,18.81T1217.38,2091Z" transform="translate(-215.73 -1774.69)"/><path class="cls-1" d="M1371.81,2078.88q1.92,16.1,8.29,22.87,11.28,12.06,41.7,12.06,17.85,0,28.39-5.29t10.53-15.88a17.12,17.12,0,0,0-8.48-15.45q-8.49-5.28-63.12-18.2-39.33-9.73-55.41-24.35-16.08-14.39-16.09-41.49,0-32,25.14-54.93t70.75-23q43.26,0,70.53,17.25t31.29,59.59H1455q-1.27-11.64-6.58-18.42-10-12.27-34-12.28-19.74,0-28.13,6.14t-8.38,14.4c0,6.91,3,11.93,8.92,15q8.89,4.89,63,16.73,36,8.46,54.05,25.61,17.77,17.35,17.78,43.39,0,34.3-25.56,56t-79,21.7q-54.51,0-80.49-23t-26-58.53Z" transform="translate(-215.73 -1774.69)"/><path class="cls-1" d="M1745.54,2124.32q-29.22,36.06-88.7,36.06t-88.69-36.06q-29.2-36.06-29.21-86.82,0-49.9,29.21-86.5t88.69-36.59q59.49,0,88.7,36.59t29.21,86.5Q1774.75,2088.26,1745.54,2124.32ZM1697.27,2091q14.19-18.81,14.19-53.48t-14.19-53.37q-14.18-18.7-40.64-18.71t-40.75,18.71q-14.28,18.72-14.28,53.37t14.28,53.48q14.3,18.81,40.75,18.81T1697.27,2091Z" transform="translate(-215.73 -1774.69)"/><path class="cls-1" d="M1992.75,1946.59q28.24,29.84,28.23,87.63,0,61-27.58,92.93t-71.06,32q-27.69,0-46-13.76-10-7.62-19.6-22.23v120.24H1797V1921.82h57.79v34.08q9.79-15,20.88-23.71,20.23-15.43,48.15-15.45Q1964.53,1916.74,1992.75,1946.59Zm-46.3,43.39q-12.3-20.52-39.88-20.53-33.15,0-45.54,31.11-6.43,16.51-6.42,41.92,0,40.21,21.58,56.51,12.82,9.53,30.37,9.53,25.45,0,38.83-19.48t13.36-51.86Q1958.75,2010.51,1946.45,1990Z" transform="translate(-215.73 -1774.69)"/><path class="cls-1" d="M2249.14,2124.32q-29.2,36.06-88.69,36.06t-88.69-36.06q-29.22-36.06-29.21-86.82,0-49.9,29.21-86.5t88.69-36.59q59.49,0,88.69,36.59t29.22,86.5Q2278.36,2088.26,2249.14,2124.32ZM2200.88,2091q14.19-18.81,14.18-53.48t-14.18-53.37q-14.18-18.7-40.64-18.71t-40.75,18.71q-14.28,18.72-14.29,53.37t14.29,53.48q14.3,18.81,40.75,18.81T2200.88,2091Z" transform="translate(-215.73 -1774.69)"/></svg>', FM = '<svg id="Layer_1" data-name="Layer 1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 2062.63 468.67" height="35px" width="140px"><defs><style>.cls-1{fill:#fff;}</style></defs><title>Prosopo Logo Black</title><path class="cls-1" d="M335.55,1825.19A147.75,147.75,0,0,1,483.3,1972.94h50.5c0-109.49-88.76-198.25-198.25-198.25v50.5Z" transform="translate(-215.73 -1774.69)"/><path class="cls-1" d="M269.36,1891.39A147.74,147.74,0,0,1,417.1,2039.13h50.5c0-109.49-88.75-198.24-198.24-198.24v50.5Z" transform="translate(-215.73 -1774.69)"/><path class="cls-1" d="M414,2157.17a147.75,147.75,0,0,1-147.74-147.74h-50.5c0,109.49,88.75,198.24,198.24,198.24v-50.5Z" transform="translate(-215.73 -1774.69)"/><path class="cls-1" d="M480.17,2091a147.74,147.74,0,0,1-147.74-147.75H281.92c0,109.49,88.76,198.25,198.25,198.25V2091Z" transform="translate(-215.73 -1774.69)"/><path class="cls-1" d="M862.8,2017.5q-27.39,22.86-78.25,22.86h-65v112.19H654.82v-312h134q46.32,0,73.86,24.13t27.55,74.72Q890.2,1994.64,862.8,2017.5ZM813,1905.1q-12.37-10.36-34.7-10.38H719.59v91.87h58.75q22.32,0,34.7-11.22t12.39-35.56Q825.43,1915.48,813,1905.1Z" transform="translate(-215.73 -1774.69)"/><path class="cls-1" d="M1045.69,1916.42c.78.08,2.51.19,5.19.32v61.81c-3.81-.42-7.2-.71-10.16-.85s-5.36-.21-7.2-.21q-36.4,0-48.89,23.71-7,13.33-7,41.06v110.29H916.89V1921.82h57.58V1962q14-23.07,24.34-31.54,16.94-14.18,44-14.18C1044,1916.32,1044.92,1916.35,1045.69,1916.42Z" transform="translate(-215.73 -1774.69)"/><path class="cls-1" d="M1265.64,2124.32q-29.21,36.06-88.69,36.06t-88.69-36.06Q1059,2088.26,1059,2037.5q0-49.9,29.22-86.5t88.69-36.59q59.47,0,88.69,36.59t29.21,86.5Q1294.85,2088.26,1265.64,2124.32ZM1217.38,2091q14.17-18.81,14.18-53.48t-14.18-53.37q-14.19-18.7-40.64-18.71T1136,1984.13q-14.29,18.72-14.29,53.37T1136,2091q14.28,18.81,40.75,18.81T1217.38,2091Z" transform="translate(-215.73 -1774.69)"/><path class="cls-1" d="M1371.81,2078.88q1.92,16.1,8.29,22.87,11.28,12.06,41.7,12.06,17.85,0,28.39-5.29t10.53-15.88a17.12,17.12,0,0,0-8.48-15.45q-8.49-5.28-63.12-18.2-39.33-9.73-55.41-24.35-16.08-14.39-16.09-41.49,0-32,25.14-54.93t70.75-23q43.26,0,70.53,17.25t31.29,59.59H1455q-1.27-11.64-6.58-18.42-10-12.27-34-12.28-19.74,0-28.13,6.14t-8.38,14.4c0,6.91,3,11.93,8.92,15q8.89,4.89,63,16.73,36,8.46,54.05,25.61,17.77,17.35,17.78,43.39,0,34.3-25.56,56t-79,21.7q-54.51,0-80.49-23t-26-58.53Z" transform="translate(-215.73 -1774.69)"/><path class="cls-1" d="M1745.54,2124.32q-29.22,36.06-88.7,36.06t-88.69-36.06q-29.2-36.06-29.21-86.82,0-49.9,29.21-86.5t88.69-36.59q59.49,0,88.7,36.59t29.21,86.5Q1774.75,2088.26,1745.54,2124.32ZM1697.27,2091q14.19-18.81,14.19-53.48t-14.19-53.37q-14.18-18.7-40.64-18.71t-40.75,18.71q-14.28,18.72-14.28,53.37t14.28,53.48q14.3,18.81,40.75,18.81T1697.27,2091Z" transform="translate(-215.73 -1774.69)"/><path class="cls-1" d="M1992.75,1946.59q28.24,29.84,28.23,87.63,0,61-27.58,92.93t-71.06,32q-27.69,0-46-13.76-10-7.62-19.6-22.23v120.24H1797V1921.82h57.79v34.08q9.79-15,20.88-23.71,20.23-15.43,48.15-15.45Q1964.53,1916.74,1992.75,1946.59Zm-46.3,43.39q-12.3-20.52-39.88-20.53-33.15,0-45.54,31.11-6.43,16.51-6.42,41.92,0,40.21,21.58,56.51,12.82,9.53,30.37,9.53,25.45,0,38.83-19.48t13.36-51.86Q1958.75,2010.51,1946.45,1990Z" transform="translate(-215.73 -1774.69)"/><path class="cls-1" d="M2249.14,2124.32q-29.2,36.06-88.69,36.06t-88.69-36.06q-29.22-36.06-29.21-86.82,0-49.9,29.21-86.5t88.69-36.59q59.49,0,88.69,36.59t29.22,86.5Q2278.36,2088.26,2249.14,2124.32ZM2200.88,2091q14.19-18.81,14.18-53.48t-14.18-53.37q-14.18-18.7-40.64-18.71t-40.75,18.71q-14.28,18.72-14.29,53.37t14.29,53.48q14.3,18.81,40.75,18.81T2200.88,2091Z" transform="translate(-215.73 -1774.69)"/></svg>', jM = '<svg id="Layer_1" data-name="Layer 1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 260 348" height="35px"><path id="Vector" d="M95.7053 40.2707C127.005 40.2707 157.022 52.6841 179.154 74.78C201.286 96.8759 213.719 126.844 213.719 158.093H254.056C254.056 70.7808 183.16 -4.57764e-05 95.7053 -4.57764e-05V40.2707Z" fill="#fff"/><path id="Vector_2" d="M42.8365 93.0614C58.3333 93.0614 73.6784 96.1087 87.9955 102.029C102.313 107.95 115.322 116.628 126.279 127.568C137.237 138.508 145.93 151.496 151.86 165.79C157.79 180.084 160.843 195.404 160.843 210.875H201.179C201.179 123.564 130.291 52.7906 42.8365 52.7906V93.0614Z" fill="#fff"/><path id="Vector_3" d="M158.367 305.005C127.07 305.003 97.056 292.59 74.926 270.496C52.796 248.402 40.3626 218.437 40.3604 187.191H0.0239563C0.0239563 274.503 70.9123 345.276 158.367 345.276V305.005Z" fill="#fff"/><path id="Vector_4" d="M211.219 252.239C195.722 252.239 180.376 249.191 166.059 243.27C151.741 237.349 138.732 228.67 127.774 217.729C116.816 206.788 108.123 193.799 102.194 179.505C96.2637 165.21 93.2121 149.889 93.2132 134.417H52.8687C52.8687 221.729 123.765 292.509 211.219 292.509V252.239Z" fill="#fff"/></g><defs><clipPath id="clip0_1_2"><rect width="254" height="345" fill="white"/></clipPath></defs></svg>', WM = '<svg id="Layer_1" data-name="Layer 1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 260 348" height="35px"><path id="Vector" d="M95.7053 40.2707C127.005 40.2707 157.022 52.6841 179.154 74.78C201.286 96.8759 213.719 126.844 213.719 158.093H254.056C254.056 70.7808 183.16 -4.57764e-05 95.7053 -4.57764e-05V40.2707Z" fill="#000000"/><path id="Vector_2" d="M42.8365 93.0614C58.3333 93.0614 73.6784 96.1087 87.9955 102.029C102.313 107.95 115.322 116.628 126.279 127.568C137.237 138.508 145.93 151.496 151.86 165.79C157.79 180.084 160.843 195.404 160.843 210.875H201.179C201.179 123.564 130.291 52.7906 42.8365 52.7906V93.0614Z" fill="#000000"/><path id="Vector_3" d="M158.367 305.005C127.07 305.003 97.056 292.59 74.926 270.496C52.796 248.402 40.3626 218.437 40.3604 187.191H0.0239563C0.0239563 274.503 70.9123 345.276 158.367 345.276V305.005Z" fill="#000000"/><path id="Vector_4" d="M211.219 252.239C195.722 252.239 180.376 249.191 166.059 243.27C151.741 237.349 138.732 228.67 127.774 217.729C116.816 206.788 108.123 193.799 102.194 179.505C96.2637 165.21 93.2121 149.889 93.2132 134.417H52.8687C52.8687 221.729 123.765 292.509 211.219 292.509V252.239Z" fill="#000000"/></g><defs><clipPath id="clip0_1_2"><rect width="254" height="345" fill="white"/></clipPath></defs></svg>';
export {
  $M as default
};
