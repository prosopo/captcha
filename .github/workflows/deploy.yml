# Publish / release / deploy packages after a release

name: deploy

on:
    push:
        branches: [main, staging]
    workflow_dispatch:

jobs:
    deploy:
        runs-on: ubuntu-latest
        steps:
            - name: Print contexts
              env:
                  GITHUB_CONTEXT: ${{ toJson(github) }}
                  ENV_CONTEXT: ${{ toJson(env) }}
                  VARS_CONTEXT: ${{ toJson(vars) }}
                  JOB_CONTEXT: ${{ toJson(job) }}
                  STEPS_CONTEXT: ${{ toJson(steps) }}
                  RUNNER_CONTEXT: ${{ toJson(runner) }}
                  SECRETS_CONTEXT: ${{ toJson(secrets) }}
                  STRATEGY_CONTEXT: ${{ toJson(strategy) }}
                  MATRIX_CONTEXT: ${{ toJson(matrix) }}
                  NEEDS_CONTEXT: ${{ toJson(needs) }}
                  INPUTS_CONTEXT: ${{ toJson(inputs) }}
              run: |
                  echo "******************************"
                  echo "github:" "$GITHUB_CONTEXT"
                  echo "******************************"
                  echo "env:" "$ENV_CONTEXT"
                  echo "******************************"
                  echo "vars:" "$VARS_CONTEXT"
                  echo "******************************"
                  echo "job:" "$JOB_CONTEXT"
                  echo "******************************"
                  echo "steps:" "$STEPS_CONTEXT"
                  echo "******************************"
                  echo "runner:" "$RUNNER_CONTEXT"
                  echo "******************************"
                  echo "secrets:" "$SECRETS_CONTEXT"
                  echo "******************************"
                  echo "strategy:" "$STRATEGY_CONTEXT"
                  echo "******************************"
                  echo "matrix:" "$MATRIX_CONTEXT"
                  echo "******************************"
                  echo "needs:" "$NEEDS_CONTEXT"
                  echo "******************************"
                  echo "inputs:" "$INPUTS_CONTEXT"
                  echo "******************************"

            # Add support for more platforms with QEMU (optional)
            # https://github.com/docker/setup-qemu-action
            - name: Set up QEMU
              uses: docker/setup-qemu-action@v3

            - name: Set up Docker Buildx
              uses: docker/setup-buildx-action@v3

            - name: Dockerhub login
              run: |
                  echo "Logging into Docker Hub."
                  echo "${{ secrets.DOCKER_PASSWORD }}" | docker login -u ${{ secrets.DOCKER_USERNAME }} --password-stdin 2> /dev/null

            - uses: actions/checkout@v3

            - name: Detect env
              id: env
              run: |
                
                set -euxo pipefail # stop on errors, print commands, fail on pipe fails

                VERSION=$(jq -r '.version' < package.json)

                # if version not detected, error
                    if [[ -z "$VERSION" ]]; then
                        echo "Failed to get version"
                        exit 1
                    fi
                    # or if version null
                    if [[ "$VERSION" == "null" ]]; then
                        echo "Failed to get version"
                        exit 1
                    fi

                echo "version=$VERSION"

                # export the next version numbers
                # shellcheck disable=SC2086
                echo "version=$VERSION" >> $GITHUB_OUTPUT

                # if branch is main, then prod, else staging
                if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
                    echo "production"
                    # shellcheck disable=SC2086
                    { 
                        echo "env=production"; 
                        echo "production=true"; 
                        echo "docker_latest_tag=latest"; 
                        echo "docker_version_tag=$VERSION" 
                    } >> $GITHUB_OUTPUT
                elif [[ "${{ github.ref }}" == "refs/heads/staging" ]]; then
                    echo "staging"
                    # shellcheck disable=SC2086
                    { 
                        echo "env=staging"; 
                        echo "staging=true"; 
                        echo "docker_latest_tag=staging"; 
                        echo "docker_version_tag=staging" 
                    } >> $GITHUB_OUTPUT
                else
                    echo "cannot deploy from branch ${{ github.ref }}"
                    exit 1
                fi

            - uses: actions/setup-node@v3
              with:
                  node-version-file: '.nvmrc'
            - run: npm i -g "npm@$(jq -r .engines.npm < package.json)"

            - run: npm ci

            # build from scratch to ensure nothing bought over from cache

            - name: Build packages
              run: |
                  echo "Building packages..."
                  npm run build:all
                  npm run build:all:cjs

            - name: Build JS bundle
              run: |
                  set -euxo pipefail # stop on errors, print commands, fail on pipe fails

                    # Copy the rococo env file to production env file
                    echo "Copying the rococo env to production env file in procaptcha-bundle"
                    cp ./dev/scripts/env.${{ steps.env.outputs.env }} ./packages/procaptcha-bundle/.env.${{ steps.env.outputs.env }}

                    # Navigate to the JS bundle directory and build
                    echo "Building JS bundle..."

                    NODE_ENV="${{ steps.env.outputs.env }}" npm -w @prosopo/procaptcha-bundle run bundle

            - name: Push the JS Bundle to the js-bundle branch
              run: |
                 set -euxo pipefail # stop on errors, print commands, fail on pipe fails
                    # Checkout js-bundle branch
                    git fetch origin js-bundle:js-bundle
                    git checkout js-bundle
                    
                    # Copy built bundle to js-bundle branch
                    cp packages/procaptcha-bundle/dist/bundle/* .
                    
                    # set the author in git
                    git config user.name "prosoponator[bot]"
                    git config user.email "dev@prosopo.io"
                    
                    git add -A
                    git commit -m 'Deploy JS bundle from staging' || true
                    
                    # Push the bundle to js-bundle branch
                    git push origin js-bundle --force
                    
                    # Return to the original branch
                    git checkout ${{ github.ref }}


            - name: Deploy staging js bundle
              if: ${{ steps.env.outputs.staging }}
              env:
                GH_TOKEN: ${{ github.token }}
              run: |

                  # stop on errors, print commands, fail on pipe fails
                  set -euo pipefail

                  # the tag for the release
                  TAG=${{ steps.env.outputs.env }}-release

                  # find the staging release, list the assets, then delete each asset. This stops any assets being carried over from one staging release to the next
                  gh release view $TAG --json assets | jq '.assets[].name' | tr -d '"' | xargs -P 1 --verbose -I {} gh release delete-asset $TAG {} -y

                  # upload the bundle to the staging release
                  gh release upload $TAG packages/procaptcha-bundle/dist/bundle/*

            - name: Build docker js_server
              run: |
                  set -euxo pipefail # stop on errors, print commands, fail on pipe fails

                  # technically, if the release is for a version which is less than a published version, the following code will have bundles from versions ahead of this one. However, this isn't really a problem, as we just want the latest bundle to be available alongside old ones, not so bothered about newer ones.

                    # Set the JS location in the container
                    JS_FOLDER="/usr/share/nginx/html/js"

                    # Get the most recent version of the js_server image
                    docker pull "prosopo/js_server:${{ steps.env.outputs.docker_latest_tag }}"

                    # Create a temporary container from the latest image
                    echo "Building Docker image..."
                    OLD_CONTAINER_ID="$(docker create "prosopo/js_server:${{ steps.env.outputs.docker_latest_tag }}")"

                    # Remove the old js temp folder
                    rm -rf ./js_bundles_host_temp

                    # Copy out the old files
                    docker cp "$OLD_CONTAINER_ID:$JS_FOLDER" ./js_bundles_host_temp

                    # Build the new image
                    docker build --file ./docker/images/js.server.dockerfile . -t "prosopo/js_server:${{ steps.env.outputs.docker_version_tag }}" --no-cache

                    # Run the new image
                    NEW_CONTAINER_ID="$(docker create "prosopo/js_server:${{ steps.env.outputs.docker_version_tag }}")"

                    # Copy the legacy files across
                    docker cp ./js_bundles_host_temp/ "$NEW_CONTAINER_ID:$JS_FOLDER/"

                    # Copy the new bundle files to the container into a folder with the version name
                    docker cp packages/procaptcha-bundle/dist/bundle/. "$NEW_CONTAINER_ID:$JS_FOLDER"

                    # Start the new container
                    docker start "$NEW_CONTAINER_ID"

                    # Move procaptcha.bundle.js
                    docker exec "$NEW_CONTAINER_ID" mv "$JS_FOLDER/procaptcha.bundle.js" "$JS_FOLDER/procaptcha.bundle.${{ steps.env.outputs.docker_version_tag }}.js"

                    # Symlink JS_FOLDER/procaptcha.bundle.js to JS_FOLDER/procaptcha.bundle.VERSION.js
                    docker exec "$NEW_CONTAINER_ID" ln -sf "$JS_FOLDER/procaptcha.bundle.${{ steps.env.outputs.docker_version_tag }}.js" "$JS_FOLDER/procaptcha.bundle.js"

                    # Commit the changes to the container
                    docker commit "$NEW_CONTAINER_ID" "prosopo/js_server:${{ steps.env.outputs.docker_version_tag }}"

                    # Check this new docker image works locally
                    docker run -d -p 3080:80 "prosopo/js_server:${{ steps.env.outputs.docker_version_tag }}"

                    # Start the bundle demo & run the cypress tests against the new bundle
                    # npx concurrently "npm run start:bundle" "npm run -w @prosopo/cypress-shared cypress:run:client-bundle-example:js_server" --success "first" --kill-others

            - name: Build the production CLI package
              run: |
                  set -euxo pipefail # stop on errors, print commands, fail on pipe fails

                    echo "Building the production CLI package..."
                    # Copy the rococo env file to production env file
                    echo "Copying the rococo env to production env file in cli package"
                    cp ./dev/scripts/env.${{ steps.env.outputs.env }} ./packages/cli/.env.${{ steps.env.outputs.env }}

                    # Navigate to the provider CLI directory and build
                    NODE_ENV="${{ steps.env.outputs.env }}" npm run -w @prosopo/cli build
                    NODE_ENV="${{ steps.env.outputs.env }}" npm run -w @prosopo/cli bundle

            # this will error if there's already a release for this version. This is by design, if you need to fix a release (e.g. because a deploy failed) then bump the version and try again
            - name: Github release
              id: github_release
              if: ${{ steps.env.outputs.production }}
              env:
                  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
              run: |
                  # do a gh release with the contract sources + bundle
                  gh release create --generate-notes "v${{ steps.env.outputs.version }}" "./packages/procaptcha-bundle/dist/bundle/procaptcha.bundle.js"

            - name: Npm release
              if: ${{ steps.env.outputs.production }}
              run: |
                  if [[ "${{ vars.HOST_GITHUB_ACTIONS }}" == true ]]; then
                    echo "Running on GitHub Actions"
                    # Write the npm token to ~/.npmrc
                    echo "//registry.npmjs.org/:_authToken=${{ secrets.NPM_TOKEN }}" > ~/.npmrc
                    echo "Publishing to npm dry-run..."
                    npm run publish:dry-run
                    echo "Publishing to npm..."
                    npm run publish
                  else
                    echo "Running locally via act, skipping npm publish."
                  fi

            - name: Docker js_server release
              id: docker_js_server_release
              run: |
                  # Push the new image to Docker Hub
                  echo "Pushing Docker image..."
                  docker push prosopo/js_server:${{ steps.env.outputs.docker_version_tag }}

                  # Push latest
                  docker tag prosopo/js_server:${{ steps.env.outputs.docker_version_tag }} prosopo/js_server:${{ steps.env.outputs.docker_latest_tag }}
                  docker push prosopo/js_server:${{ steps.env.outputs.docker_latest_tag }}

            - name: Get Prosopo JS Server Flux App Name
              run: |
                # shellcheck disable=SC2086
                { 
                    echo "JS_SERVER_FLUX_APP_NAME=${{ steps.env.outputs.env }}_JS_SERVER_FLUX_APP_NAME"  | tr '[:lower:]' '[:upper:]';
                } >> $GITHUB_ENV

            - name: Redeploy flux docker js_server
              env:
                  PROSOPO_ZELCORE_PRIVATE_KEY: ${{ secrets.PROSOPO_ZELCORE_PRIVATE_KEY }}
                  PROSOPO_ZELCORE_PUBLIC_KEY: ${{ secrets.PROSOPO_ZELCORE_PUBLIC_KEY }}
              run: |
                  if [[ "${{ steps.docker_js_server_release.outcome }}" == 'success' ]]; then
                    echo "Installing @prosopo/flux..."
                    npm i -g @prosopo/flux
                    echo "Soft redeploying flux docker js_server."
                    npx flux redeploy --app ${{ secrets[env.JS_SERVER_FLUX_APP_NAME] }}
                  else
                    echo "Skipping flux redeploy."
                  fi

            - name: Build and push the Provider Container
              uses: docker/build-push-action@v5
              with:
                  context: ${{github.workspace}}
                  file: ${{github.workspace}}/docker/images/provider.dockerfile
                  platforms: linux/amd64,linux/arm64
                  push: true
                  tags: prosopo/provider:${{ steps.env.outputs.docker_version_tag }},prosopo/provider:${{ steps.env.outputs.docker_latest_tag }}

            - name: Deploy fail notification
              if: failure()
              run: |
                  echo "Deploy failed"
                  curl -X POST -H 'Content-type: application/json' --data "{\"text\":\":check-failed: Deploy <${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|${{ steps.env.outputs.env }} v${{ steps.env.outputs.version }}> failed.\"}"  ${{ secrets.SLACKBOT_DEVOPS }}

            - name: Deploy success notification
              if: success()
              run: |
                  echo "Deploy succeeded"
                  curl -X POST -H 'Content-type: application/json' --data "{\"text\":\":check-passed: Deploy <${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|${{ steps.env.outputs.env }} v${{ steps.env.outputs.version }}> succeeded.\"}"  ${{ secrets.SLACKBOT_DEVOPS }}
